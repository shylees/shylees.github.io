<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shylees&#39; Blog</title>
  
  <subtitle>低头往前走就好了</subtitle>
  <link href="https://shylees.github.io/public/atom.xml" rel="self"/>
  
  <link href="https://shylees.github.io/"/>
  <updated>2022-09-23T15:47:51.000Z</updated>
  <id>https://shylees.github.io/</id>
  
  <author>
    <name>shylees</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>保姆级理解js各种继承方案</title>
    <link href="https://shylees.github.io/furtherNotes/further/04%E7%BB%A7%E6%89%BF"/>
    <id>https://shylees.github.io/furtherNotes/further/04%E7%BB%A7%E6%89%BF</id>
    <published>2022-09-17T08:37:38.000Z</published>
    <updated>2022-09-23T15:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js继承方案">js继承方案<a title="#js继承方案" href="#js继承方案"></a></h1><p>继承本质：复制，重写原型对象，代之以一个新类型的实例</p><h2 id="1.-原型链继承">1. 原型链继承<a title="#1.-原型链继承" href="#1.-原型链继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">property</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getProperty</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">property</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">son.<span class="title function_">getName</span>();    <span class="comment">// son</span></span><br><span class="line">son.<span class="title function_">getProperty</span>(); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype</span></span><br><span class="line"><span class="title class_">Parent</span>: &#123;</span><br><span class="line">    <span class="attr">getPrototype</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">getName</span>: <span class="title function_">f</span>(),</span><br><span class="line">        <span class="attr">constructor</span>: f <span class="title class_">Parent</span>(),</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son</span></span><br><span class="line"><span class="title class_">Son</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;son&#x27;</span>,</span><br><span class="line">    <span class="attr">prototype</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Parent</span> &#123;       <span class="comment">// 原型对象指向 Parent</span></span><br><span class="line">        <span class="attr">getPrototype</span>: <span class="title function_">f</span>(),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原Son.prototype</span></span><br><span class="line"><span class="attr">constructor</span>: f &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：<code> Son.prototype = new Parent()</code></p><p>优点：</p><ol><li>继承了父类原型上的属性和方法</li></ol><p>缺点：</p><ol><li>多个<code>Son</code>实例对<code>new Parent()</code>后拥有的属性进行操作时，都是操作同一个属性；</li><li><code>Son</code>的原型上的 <code>constructor</code> 属性没了；</li><li>给<code>Son</code>的原型增加属性和方法必须在替换原型后，否则会被覆盖；</li><li>创建<code>Son</code>实例时无法向<code>Parent</code>的构造函数传参</li></ol><h2 id="2.-构造函数继承">2. 构造函数继承<a title="#2.-构造函数继承" href="#2.-构造函数继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">son1.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&#x27;blue&#x27;</span>) <span class="comment">// this.color = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;]</span></span><br><span class="line">son1.<span class="title function_">getColor</span>();  <span class="comment">// getColor is not defined!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">son2.<span class="property">color</span> <span class="comment">// [&#x27;red&#x27;, &#x27;pink&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype</span></span><br><span class="line"><span class="attr">constructor</span>:f &#123;     <span class="comment">// 原型链继承是 Parent</span></span><br><span class="line">    <span class="attr">constructor</span>: f <span class="title class_">Son</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">constructor</span>: f <span class="title class_">Object</span>(), <span class="comment">// 原型链继承是 Parent </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son1</span></span><br><span class="line"><span class="title class_">Son</span>&#123;</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;son&#x27;</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;  <span class="comment">// 原型链继承是 Parent&#123;&#125;</span></span><br><span class="line">        <span class="attr">constructor</span>: f <span class="title class_">Son</span>(),  </span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码： <code>Parent.call(this)</code></p><p>在实例化每一个<code>Son</code>时，执行 <code>Parent</code> 的构造函数</p><p>优点：</p><ol><li>对于每一个<code>Son</code>的实例，都能独有一份父类的属性和方法</li><li>能给父类传参</li><li><code>Son</code> 原型上有其原本的 <code>constructor</code></li></ol><p>缺点：</p><ol><li>只能继承父类构造函数里的属性方法，不能继承父类原型上的属性方法</li><li>每个子类在最初都有一样的完整的父类实例副本，无法复用</li></ol><h2 id="3.-组合继承">3. 组合继承<a title="#3.-组合继承" href="#3.-组合继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="title class_">Son</span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;  </span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">son.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&#x27;blue&#x27;</span>)  <span class="comment">// [&#x27;red&#x27;,&#x27;pink&#x27;,&#x27;blue&#x27;]</span></span><br><span class="line">son.<span class="title function_">getName</span>(); <span class="comment">//son</span></span><br><span class="line">son.<span class="title function_">getAge</span>();  <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son1&#x27;</span>, <span class="number">15</span>);</span><br><span class="line">son.<span class="property">color</span>  <span class="comment">// [&#x27;red&#x27;,&#x27;pink&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Son.prototype</span></span><br><span class="line"><span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>],</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">__proto__</span>:&#123;</span><br><span class="line">        <span class="attr">getAge</span>: f (),</span><br><span class="line">        <span class="attr">getName</span>: f (),</span><br><span class="line">        <span class="attr">constructor</span>: f <span class="title class_">Parent</span>(name),</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son</span></span><br><span class="line"><span class="title class_">Son</span>&#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;son&#x27;</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Parent</span>&#123;</span><br><span class="line">        <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>],</span><br><span class="line">        <span class="attr">name</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><ol><li><code>Parent.call(this)</code> 为每一个子类实例，获得独一份父类的属性方法 — <strong>构造函数继承</strong></li><li><code>Son.prototype = new Parent()</code>  讲父类的原型 传递给子类的原型对象<code>__proto__</code>  — <strong>原型链继承</strong></li><li><code>Son.constructor = Son</code> 弥补覆盖原型后 Son 的constructor不存在</li></ol><p>优点：</p><ol><li>继承了父类的原型</li><li>每个子类实例拥有独一份的父类属性方法</li><li>子类的<code>constructor</code>属性存在</li><li>利用原型链取值原则，屏蔽了与子元素同名的属性的获取</li></ol><p>缺点：</p><ol><li><p>在 <code>Son.prototype = new Parent()</code>时，会执行一次父类构造函数，给子类原型增加父类的属性方法；</p><p>在 实例化子类时， 会调用<code>Parent.call(this)</code>， 再执行一次父类构造函数，给子类增加父类的属性方法；</p><blockquote><p>在不用的地方有完全一模一样的属性方法被两次写入，冗余</p></blockquote></li></ol><h2 id="4.-原型式继承">4. 原型式继承<a title="#4.-原型式继承" href="#4.-原型式继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>)&#123; <span class="comment">// obj 父类 返回obj的原型对象</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = obj;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布解读</span></span><br><span class="line"><span class="comment">// 1. function F()&#123;&#125;;</span></span><br><span class="line"><span class="comment">// F.prototype </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">constructor</span>: f <span class="title function_">F</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. F.prototype = Parent;    // 浅复制 Parent</span></span><br><span class="line"><span class="comment">// F.prototype</span></span><br><span class="line"><span class="title class_">Parent</span>()&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// F.prototype = person F.prototye</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dddd,</span></span><br><span class="line"><span class="string">    __proto__: Object</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 3. new F();  返回值 原型对象 指向传入对象 的实例</span></span><br><span class="line"><span class="string">// Parent</span></span><br><span class="line"><span class="string">F&#123;</span></span><br><span class="line"><span class="string">    __proto__: f Parent()&#123;</span></span><br><span class="line"><span class="string">        arguments, caller, length, name:&quot;Parent&quot;,</span></span><br><span class="line"><span class="string">        prototype:&#123;...&#125;,</span></span><br><span class="line"><span class="string">        __proto__: f ()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// person</span></span><br><span class="line"><span class="string">F&#123;</span></span><br><span class="line"><span class="string">    __proto__: &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;</span>dddd<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        __proto__: Object</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name : <span class="string">&#x27;dddd&#x27;</span>;</span><br><span class="line">    color : [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="title function_">object</span>(person);</span><br><span class="line">man.<span class="property">name</span> = <span class="string">&#x27;man&#x27;</span>;</span><br><span class="line">man.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man1 = <span class="title function_">object</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// man</span></span><br><span class="line">F&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// man1</span></span><br><span class="line">F&#123;</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>],</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码：<code>function object(obj)&#123; function F(); F.prototype = obj; return new F();&#125;</code></p><p>优点：</p><ol><li>继承了父类的原型</li></ol><p>缺点：</p><ol><li><code>obj</code>是函数时，子类无法得到父类构造函数的属性和方法</li><li><code>F.prototype = obj </code> 是浅复制，所以所有子类操作的是父类同一个引用类型数据</li><li>无法传递参数</li><li><code>object()</code> 可以用 <code>es5</code> 的 <code>Object.create()</code> 替代</li></ol><h2 id="5.-寄生式继承">5. 寄生式继承<a title="#5.-寄生式继承" href="#5.-寄生式继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">ori</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title function_">object</span>(ori);</span><br><span class="line">    <span class="comment">// 可在此增强对象</span></span><br><span class="line">    clone.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="title function_">create</span>(person);</span><br><span class="line">son.<span class="property">name</span> = <span class="string">&#x27;son&#x27;</span>;</span><br><span class="line">son.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="title function_">create</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// son</span></span><br><span class="line">F &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;son&#x27;</span></span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        color : [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>],</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son1</span></span><br><span class="line">F &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        color : [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>],</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dddd&#x27;</span>,</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心代码：<code>function create(ori)&#123; let clone = object(ori); clone.getName = function()&#123;&#125;; return clone; &#125;</code></p><p>跟原型继承的区别：</p><ol><li>能增强对象，为构造函数新增属性方法，增强函数</li></ol><p>优点：</p><ol><li>继承了父类的原型</li></ol><p>缺点：</p><ol><li><code>obj</code>是函数时，子类无法得到父类构造函数的属性和方法</li><li><code>F.prototype = obj </code> 是浅复制，所以所有子类操作的是父类同一个引用类型数据</li><li>无法传递参数</li><li><code>object()</code> 可以用 <code>es5</code> 的 <code>Object.create()</code> 替代</li></ol><h2 id="6.-寄生组合式继承">6. 寄生组合式继承<a title="#6.-寄生组合式继承" href="#6.-寄生组合式继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">son, parent</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    prototype.<span class="property">constructor</span> = son;</span><br><span class="line">    son.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = [<span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getColor</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inherit</span>(son, parent);    <span class="comment">// 将son的原型对象指向 parent的原型</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">son.<span class="property">name</span> = <span class="string">&#x27;sonson0&#x27;</span>;</span><br><span class="line">son.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son1&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// son</span></span><br><span class="line"><span class="title class_">Son</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sonson0&#x27;</span>,                  <span class="comment">// 继承父类实例</span></span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>],           <span class="comment">// 继承父类实例</span></span><br><span class="line">    <span class="attr">getName</span>: f (),                    <span class="comment">// 继承父类实例</span></span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,                          <span class="comment">// 子类实例</span></span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Son</span> (name, age), </span><br><span class="line">        <span class="attr">getAge</span>: f (),  <span class="comment">// 继承子类原型</span></span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span> &#123;</span><br><span class="line">            <span class="attr">constructor</span>: <span class="title class_">Parent</span>(),   </span><br><span class="line">            <span class="attr">getColor</span>: <span class="title function_">f</span>(),            <span class="comment">// 继承父类原型</span></span><br><span class="line">            <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// son1</span></span><br><span class="line"><span class="title class_">Son</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>],</span><br><span class="line">    <span class="attr">getName</span>: f (),</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Son</span> (name, age),</span><br><span class="line">        <span class="attr">getAge</span>: f (),</span><br><span class="line">        <span class="attr">__proto__</span>: <span class="title class_">Object</span> &#123;</span><br><span class="line">            <span class="attr">constructor</span>: <span class="title class_">Parent</span>(),</span><br><span class="line">            <span class="attr">getColor</span>: <span class="title function_">f</span>(),</span><br><span class="line">            <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心代码：</p><pre><code>`son.prototype = Object.create(parent.prototype); son.prototye.constructor = son `    — **寄生模式**</code></pre><p>​       <code>Parent.call(this)</code> — <strong>构造函数传参</strong></p><p>与组合继承的区别在于：</p><ol><li>组合继承使用 <code>son.prototype = new Parent()</code> ； 而寄生组合使用 <code>son.prototype = Object.create(Parent.prototype)</code></li><li>组合会执行两次<code>Parent.call(this)</code> ；寄生组合只会在实例化 <code>Son</code> 时，执行一次 <code>Parent.call(this)</code></li></ol><p>优点：</p><ol><li>最成熟的继承实现方法，也是库实现的方法</li></ol><h2 id="7.-混入方式继承">7. 混入方式继承<a title="#7.-混入方式继承" href="#7.-混入方式继承"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="title class_">Parent2</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">Parent2</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 将Parent2.prototype 拷贝到 Son.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br></pre></td></tr></table></figure><h2 id="8.-es6类继承-extends">8. es6类继承 extends<a title="#8.-es6类继承-extends" href="#8.-es6类继承-extends"></a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setName = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getAge = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">setAge = <span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;son&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// son</span></span><br><span class="line"><span class="title class_">Son</span> = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;son&#x27;</span>,</span><br><span class="line">    <span class="attr">getAge</span>: <span class="title function_">f</span>(), <span class="attr">setAge</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">getName</span>: <span class="title function_">f</span>(), <span class="attr">setName</span>: <span class="title function_">f</span>(),</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Parent</span>&#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="keyword">class</span> <span class="title class_">Son</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="keyword">class</span> <span class="title class_">Parent</span>,</span><br><span class="line">    <span class="attr">__proto__</span>: <span class="title class_">Object</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends 关键字的核心代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_inherits</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">    <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">    subType.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType &amp;&amp; superType.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">        <span class="attr">constructor</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: subType,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> </span><br><span class="line">            ? <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(subType, superType) </span><br><span class="line">            : subType.<span class="property">__proto__</span> = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://juejin.cn/post/6844903696111763470">https://juejin.cn/post/6844903696111763470</a></p><p><a href="https://muyiy.cn/blog/5/5.2.html">https://muyiy.cn/blog/5/5.2.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js继承方案&quot;&gt;js继承方案&lt;a title=&quot;#js继承方案&quot; href=&quot;#js继承方案&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;继承本质：复制，重写原型对象，代之以一个新类型的实例&lt;/p&gt;
&lt;h2 id=&quot;1.-原型链继承&quot;&gt;1. 原型链继承&lt;a title=&quot;#1.-</summary>
      
    
    
    
    <category term="furtherNotes" scheme="https://shylees.github.io/categories/furtherNotes/"/>
    
    
    <category term="js" scheme="https://shylees.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入js原型 prototype、原型对象 __proto__ [[prototype]]、原型链</title>
    <link href="https://shylees.github.io/furtherNotes/further/03%E5%8E%9F%E5%9E%8B"/>
    <id>https://shylees.github.io/furtherNotes/further/03%E5%8E%9F%E5%9E%8B</id>
    <published>2022-09-16T13:37:00.000Z</published>
    <updated>2022-09-17T09:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>原型： <code>Prototype</code></p><p>原型对象：<code>__proto__ </code>  <code>[[prototype]]</code></p><p>原型链：每个对象有一个原型对象，通过 <code>__proto__</code> 指针 指向上一个原型，并继承其方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。</p><p>通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;function parent name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">create</span>(p);  <span class="comment">// child 是一个新的空对象，有一个指向对象 p 的指针 __proto__</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span> <span class="comment">// function Parent()&#123; this.name = &#x27;...&#x27; &#125;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">constructor</span>   <span class="comment">// Function() &#123; [native code] &#125; 默认值 与其他任何引用or基本类型同</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">// Object类型 &#123; constructor:f Parent() , __proto__:Object &#125;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Parent</span>  <span class="comment">// function Parent()&#123; this.name = &#x27;...&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// f() &#123; [native code] &#125;  </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Parent</span>) <span class="comment">// f() &#123; [native code] &#125; 通常用这个 function get __proto__ === [[prototype]]</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Parent</span>.<span class="property">constructor</span>  <span class="comment">// Function()&#123; [native code] &#125; </span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">__proto__</span> != <span class="title class_">Parent</span>.<span class="property">__proto__</span>.<span class="property">constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">p <span class="comment">// Parent &#123;name: &quot;...&quot;, __proto__: &#123;&#125; &#125;</span></span><br><span class="line">p.<span class="property">constructor</span> <span class="comment">// f Parent() &#123; this.name = &#x27;...&#x27; &#125;  找的是 __proto__ 的</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">contructor</span> === <span class="title class_">Parent</span> === p.<span class="property">constructor</span> <span class="comment">// f Parent() &#123; this.name = &#x27;...&#x27; &#125;</span></span><br><span class="line">p.<span class="property">__proto__</span> === <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">c <span class="comment">// Parent&#123; __proto__: Parent&#123; name:&#x27;...&#x27;, __proto__: &#123;&#125; &#125; &#125;</span></span><br><span class="line"><span class="comment">// c == Parent &#123;__proto__: p&#125;</span></span><br><span class="line">c.<span class="property">constructor</span> <span class="comment">// f Parent() &#123; this.name = &#x27;...&#x27; &#125;</span></span><br><span class="line">c != p != <span class="title class_">Parent</span></span><br><span class="line">c.<span class="property">__proto__</span> === p</span><br><span class="line">c.<span class="property">__proto__</span>.<span class="property">__proto__</span> === p.<span class="property">__proto__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> </span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line">p.<span class="property">__proto__</span> === <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Parent</span>()&#123;</span><br><span class="line">    <span class="variable language_">arguments</span>, caller, length, <span class="attr">name</span>: <span class="string">&quot;Parent&quot;</span>,</span><br><span class="line">    prototype : &#123;...&#125;, <span class="comment">// 这里一整个 循环引用类似</span></span><br><span class="line">__proto__ : <span class="title function_">f</span>(<span class="params"></span>)&#123;...&#125;, <span class="comment">// 一些api apply, constructor, toString, symbol...</span></span><br><span class="line">        [[<span class="title class_">FunctionLocation</span>]]: ...,</span><br><span class="line">        [[<span class="title class_">Scopes</span>]] : <span class="title class_">Scopes</span>[ <span class="title class_">Global</span>: &#123;&#125; ]</span><br><span class="line">&#125;,</span><br><span class="line">        </span><br><span class="line">    <span class="attr">__proto__</span>: &#123;</span><br><span class="line">        <span class="attr">constructor</span>: f <span class="title class_">Object</span>()&#123; <span class="comment">// Object 构造函数</span></span><br><span class="line">            <span class="attr">arguments</span>:&#123;&#125;, <span class="title function_">assign</span>(), <span class="attr">caller</span>:&#123;&#125;, <span class="title function_">create</span>(), <span class="title function_">defineProperties</span>(), <span class="title function_">defineProperty</span>(), <span class="title function_">entries</span>(), <span class="title function_">freeze</span>(), <span class="title function_">formEntries</span>(), <span class="title function_">getOwnPropertyDescriptor</span>()...</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">hasOwnProperty</span>(), </span><br><span class="line">        <span class="title function_">isPrototypeOf</span>(), </span><br><span class="line">        <span class="title function_">propertyIsEnumerable</span>(),</span><br><span class="line">        <span class="title function_">toLocaleString</span>(),</span><br><span class="line">        <span class="title function_">toString</span>(), <span class="title function_">valueOf</span>()...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Symbol 作为构造函数来说不完整，因为不支持 <code>new Symbol()</code>，但其原型上有 <code>constructor</code> 属性 <code>===  Symbol.prototype.constructor</code></p></li><li><p>引用类型 <code>constructor</code> 属性是可以修改的，但对于基本类型是只读的，<code>null undefined</code> 没有 <code>constructor</code></p></li><li><p><code>__proto__</code>  是每个实例都有的属性，<code>prototype</code> 是构造函数的属性，在实例上不存在，但是<code>p.__proto__</code>  <code>Parent.prototype</code> 指向同一个对象</p></li><li><p><code>__proto__</code> 在 <code>es6</code> 被标准化，但性能问题并不推荐使用，推荐使用 <code>Object.getPrototypeOf()</code></p></li><li><p>instanceof 原理：一层层查找 <code>__proto__</code>，如果和 <code>constructor.prototype</code> 相等则返回 <code>true</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原型： &lt;code&gt;Prototype&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原型对象：&lt;code&gt;__proto__ &lt;/code&gt;  &lt;code&gt;[[prototype]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原型链：每个对象有一个原型对象，通过 &lt;code&gt;__proto__&lt;/cod</summary>
      
    
    
    
    <category term="furtherNotes" scheme="https://shylees.github.io/categories/furtherNotes/"/>
    
    
    <category term="js" scheme="https://shylees.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>项目性能优化之缓存和懒加载</title>
    <link href="https://shylees.github.io/workNotes/work/12%20%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%BC%93%E5%AD%98%E5%92%8C%E5%9B%BE%E7%89%87%E6%87%92%E9%A2%84%E5%8A%A0%E8%BD%BD"/>
    <id>https://shylees.github.io/workNotes/work/12%20%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%BC%93%E5%AD%98%E5%92%8C%E5%9B%BE%E7%89%87%E6%87%92%E9%A2%84%E5%8A%A0%E8%BD%BD</id>
    <published>2022-06-07T13:30:47.483Z</published>
    <updated>2022-07-03T13:16:33.210Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在页面跳转的情况下，还是会有资源重新加载的情况，所以使用了 keep-alive</p><ol><li><p>在 router.js 增加允许使用 keep-alive</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./components/Home.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&quot;./components/List.vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title class_">VueRouter</span>.<span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title class_">VueRouter</span>.<span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">requiresAuth</span>: <span class="literal">true</span>, <span class="comment">//</span></span><br><span class="line">        <span class="attr">keepAlive</span>: <span class="literal">true</span>, <span class="comment">// 允许使用缓存</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/list/:category&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">List</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">        <span class="attr">requiresAuth</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">keepAlive</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li><li><p>在 app.js 使用 keep-alive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- vue3 写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- vue2 写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p><font color="red">如果第一个方法没有效果的话，那么要结合第二个看</font></p></blockquote><ol start="2"><li><p>路由回退中 router.go() 与 router.back()</p><blockquote><p><a href="https://blog.csdn.net/qq_42618566/article/details/91045282">https://blog.csdn.net/qq_42618566/article/details/91045282</a></p></blockquote><ul><li><code>go()</code> 原页面表单中的内容会丢失</li><li><code>back()</code> 原页面表单中的内容会保留<ul><li><code>back()</code> 后退</li><li><code>back(0)</code> 刷新</li><li><code>back(1)</code> 前进</li></ul></li></ul></li><li><p>使用 keep-alive，第二次跳转页面后 不会 触发到原先在 onMounted 的 使页面到顶部，就会保持上个页面滚动条的滚动情况</p><ul><li>在 onActived 写一个与 onMounted 一样的逻辑</li><li>页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated，所以别在 mounted 和 activated 方法中写相同的逻辑代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onActivated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">pageYOffset</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">pageYOffset</span> = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>图片懒加载</p><ul><li><p>原理：将图片的 url 放在 <code>&lt;img src=&quot;&quot; :data-src=&quot;url&quot; /&gt;</code> 的 data-src 里，当图片位于用户可视区时就将 url 放到 src 属性里</p></li><li><p>判断图片是否位于可视区的方法:</p><ol><li>scroll 事件监听，用 scrollTop 等属性计算位置判断</li><li>使用 Intersection Observer</li><li>Intersection Observer<blockquote><p><a href="https://juejin.cn/post/7080544007834730510">https://juejin.cn/post/7080544007834730510</a> 这篇文章挺全面的</p></blockquote></li></ol></li><li><p>解决方法</p><blockquote><p>因为 项目是 vue3 + vant，所以使用 vant 自带的 <code>&lt;van-image lazy-load&gt;&lt;/van-image&gt;</code></p></blockquote></li></ul></li><li><p>图片懒加载的前提下，在右滑 or 轮播图切换，及非垂直滚动时做图片预加载，增加用户体验</p><ul><li><p>原理均类似于懒加载的原理，因为图片地址在 src 属性里时，页面就会自动加载图片资源了</p></li><li><p><strong>轮播</strong>原理：在当前图片轮播时，就将下一张图片给加载出来，这部分是取消了懒加载啦</p></li><li><p>实现:</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;w-100vw h-full relative&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;realPic[index]&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮播图 图片懒加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * imgs: 配置文件中的 banner 图片的链接</span></span><br><span class="line"><span class="comment"> * realPic: 真正页面使用的图片的链接</span></span><br><span class="line"><span class="comment"> * changePic: 轮播图 图片切换的时候触发函数，预先加载后一个图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> imgs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> board_1) &#123;</span><br><span class="line">  imgs.<span class="title function_">push</span>(item.<span class="property">banner</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> realPic = <span class="title function_">reactive</span>([imgs[<span class="number">0</span>], imgs[<span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> changePic = <span class="title function_">limit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = imgs[count.<span class="property">value</span>];</span><br><span class="line">  <span class="keyword">if</span> (img.<span class="property">complete</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count.<span class="property">value</span> &lt; imgs.<span class="property">length</span>) &#123;</span><br><span class="line">    realPic.<span class="title function_">push</span>(imgs[count.<span class="property">value</span>]);</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(realPic);</span></span><br><span class="line">&#125;, imgs.<span class="property">length</span> - count.<span class="property">value</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>右滑</strong>原理：所以在需要预加载的图片的 src 为 一个图片数组，初始情况下，数组为空，在懒加载的图片加载完成后就把该数组用 图片 src 填满</p></li><li><p>实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;index &lt; 4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-image</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:src</span>=<span class="string">&quot;item.banner&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;w-full h-full&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">lazy-load</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">load</span>=<span class="string">&quot;load(index)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">van-image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-image</span> <span class="attr">:src</span>=<span class="string">&quot;preimg[index]&quot;</span> <span class="attr">class</span>=<span class="string">&quot;w-full h-full&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">van-image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> preimg = <span class="title function_">reactive</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> load = <span class="title function_">limit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; board_2.<span class="property">list</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    preimg.<span class="title function_">push</span>(board_2.<span class="property">list</span>[i].<span class="property">banner</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>计算首屏时间</p><blockquote><p><a href="https://blog.csdn.net/weixin_40599109/article/details/108622434">https://blog.csdn.net/weixin_40599109/article/details/108622434</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.<span class="property">timing</span>;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.<span class="property">loadEventEnd</span> - t.<span class="property">navigationStart</span>;</span><br><span class="line"><span class="comment">// 在这里pageLoadTime就是首屏时间</span></span><br></pre></td></tr></table></figure></li><li><p>在进入同一个有 keepalive 的组件，但是要展示不同数据时，就要合理修改 reactive 的值</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在页面跳转的情况下，还是会有资源重新加载的情况，所以使用了 keep-alive&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 router.js 增加允许使用 keep-alive&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vite" scheme="https://shylees.github.io/tags/vite/"/>
    
    <category term="vue3" scheme="https://shylees.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>记录 windicss 使用过程中遇到的属性</title>
    <link href="https://shylees.github.io/workNotes/work/11%20vite%20vue3%20windicss%20backgroundImage"/>
    <id>https://shylees.github.io/workNotes/work/11%20vite%20vue3%20windicss%20backgroundImage</id>
    <published>2022-06-07T13:30:41.963Z</published>
    <updated>2022-07-03T13:16:29.270Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>常规使用</p><p><strong>文字 背景</strong></p><ul><li>font-size — text-[12px]</li><li>font-weight — font-[500]</li><li>line-height — leading-[14px]</li><li>color — text-[#5E6673]</li><li>background — bg-[#1A2437]</li><li>opacity — opacity-60</li><li>文本溢出 — line-clamp-3</li></ul><p><strong>盒子模型</strong></p><ul><li>padding — px(横向) py(纵向) pt pb pl pr</li><li>margin</li><li>width — w</li><li>height — h</li><li>圆角边框 — rounded-[4px]</li></ul><p><strong>定位</strong></p><ul><li>position — relative/absolute</li><li>display — block/flex</li><li>flex — flex-col/justify-between/flex-grow-0/items-center</li><li>z-index — z-index-1</li></ul></li></ol><ul><li>first-of-type:mt-0</li></ul><ol start="2"><li><p>使用 backgroundImage 做渐变失效的解决方案</p><ol><li>在 <code>windi.config.js</code> 文件中添加</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extend</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">backgroundImage</span>: &#123;</span><br><span class="line">      <span class="string">&quot;gradient-61&quot;</span>:</span><br><span class="line">        <span class="string">&quot;linear-gradient(184.29deg, rgba(0, 0, 0, 0) 3.48%, rgba(0, 0, 0, 0.8) 96.51%)&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>在 vue 中使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;bg-gradient-61&quot; &gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;常规使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文字 背景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;font-size — text-[12px]&lt;/li&gt;
&lt;li&gt;font-weight — font-[500]&lt;/li&gt;
&lt;li&gt;line-height </summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vite" scheme="https://shylees.github.io/tags/vite/"/>
    
    <category term="vue3" scheme="https://shylees.github.io/tags/vue3/"/>
    
    <category term="windicss" scheme="https://shylees.github.io/tags/windicss/"/>
    
  </entry>
  
  <entry>
    <title>html 标签嵌套规则</title>
    <link href="https://shylees.github.io/workNotes/work/10%20xhtml%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99"/>
    <id>https://shylees.github.io/workNotes/work/10%20xhtml%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99</id>
    <published>2022-04-23T08:28:48.565Z</published>
    <updated>2022-05-06T05:46:38.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由 [nuxtjs 开发 spa](./10 nuxtjs <a href="http://xn--4ru063i.md">报错.md</a>) 引申出的思考</p><p>参考链接：<br><a href="https://cloud.tencent.com/developer/article/1009200">https://cloud.tencent.com/developer/article/1009200</a></p><p><a href="https://cloud.tencent.com/developer/article/1484900">https://cloud.tencent.com/developer/article/1484900</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories">https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories</a></p></blockquote><blockquote><p>其实第一个参考链接的图片已经讲的很清楚了，那我就大概总结一下吧</p></blockquote><ol><li><p>块级元素可以嵌套 块级/行内元素</p><ul><li>其中 <code>&lt;h1&gt;～&lt;h6&gt;</code> <code>&lt;dt&gt;</code> 只能嵌套行内元素</li><li>其中 <code>&lt;p&gt;</code> 可以嵌套 <code>&lt;p&gt;</code> 和 行内元素</li></ul></li><li><p>行内元素 只可以嵌套行内元素</p><ul><li>其中 <code>&lt;a&gt;</code> 可以嵌套除了 <code>&lt;a&gt;</code> 以外的几乎所有元素，包括行内和块级元素</li></ul></li><li><p>块级元素 与 块级元素 并列，行内元素 与 行内元素 并列</p></li></ol><blockquote><p>在使用 nuxtjs 配合 vue 开发的时候，报 <code>[vue warn]</code>的情况，只有 <code>&lt;a&gt; &lt;a&gt;&lt;/a&gt; &lt;/a&gt;</code>，及 a 标签 嵌套 a 标签才会出现，为啥捏？还没有搞懂…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;由 [nuxtjs 开发 spa](./10 nuxtjs &lt;a href=&quot;http://xn--4ru063i.md&quot;&gt;报错.md&lt;/a&gt;) 引申出的思考&lt;/p&gt;
&lt;p&gt;参考链接：&lt;br&gt;
&lt;a href=&quot;https://cloud.tenc</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="html" scheme="https://shylees.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>nuxtjs 开发 spa 遇上的有关 html 标签规则的报错</title>
    <link href="https://shylees.github.io/workNotes/work/10%20nuxtjs%E6%8A%A5%E9%94%99"/>
    <id>https://shylees.github.io/workNotes/work/10%20nuxtjs%E6%8A%A5%E9%94%99</id>
    <published>2022-04-20T13:51:19.513Z</published>
    <updated>2022-04-21T05:26:20.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>博客上线前，老大发现的 [vue warn], 说 “博客详情服务器渲染有问题”、“这个在正式环境会执行错误的”、“沙盒应该就会无法渲染”、“ssr 和 spa 渲染结果不一样”…</p><p>触发报错的操作: “在博客详情页直接刷新 就会提示我截图的错误”</p></blockquote><h3 id="报错信息:">报错信息:<a title="#报错信息:" href="#报错信息:"></a></h3><p>[Vue warn]: The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <code>&lt;p&gt;</code>, or missing <code>&lt;tbody&gt;</code>. Bailing hydration and performing full client-side render.</p><h3 id="报错截图：">报错截图：<a title="#报错截图：" href="#报错截图："></a></h3><img src="https://s1.ax1x.com/2022/04/20/Ls48OK.png"><blockquote><p>大概意思是 HTML 结构嵌套不正确，会导致 srr 渲染的页面跟csr的不一样<br>根据黄色提示，我很快就定位到了代码的位置</p></blockquote><h3 id="报错效果图及其-html-标签:">报错效果图及其 html 标签:<a title="#报错效果图及其-html-标签:" href="#报错效果图及其-html-标签:"></a></h3><img src="https://s1.ax1x.com/2022/04/20/LsI3VO.jpg"><p>最外层的<code>&lt;a class=&quot;pre item&quot;&gt;</code></p><blockquote><p>本来最外层的 <code>&lt;a&gt;</code> 是 <code>&lt;p&gt;</code> 的，但是因为里面的两个 <code>&lt;a&gt;</code> 标签都是跳转同一个链接，所以我就直接把最外层改了，虽然我记得这样嵌套不行，但是我以为没影响！</p></blockquote><blockquote><p>我不知道为什么上个同学要分开写两个? 难道是因为分开 <code>hover</code> 改变样式? 如果有大佬知道分开写的好处, d 我!!! 我很感兴趣!!!</p></blockquote><h3 id="报错解决">报错解决<a title="#报错解决" href="#报错解决"></a></h3><p>因为 html 标签嵌套规则里面有提到 <code>&lt;a&gt;</code> 标签可以嵌套<strong>除本身以外</strong>的块级元素、行内元素，所以直接把里面的两个 <code>&lt;a&gt;</code> 改成其他标签，如 <code>&lt;span&gt;</code> 就解决问题啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;博客上线前，老大发现的 [vue warn], 说 “博客详情服务器渲染有问题”、“这个在正式环境会执行错误的”、“沙盒应该就会无法渲染”、“ssr 和 spa 渲染结果不一样”…&lt;/p&gt;
&lt;p&gt;触发报错的操作: “在博客详情页直接刷新 就会提示我</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="ssr" scheme="https://shylees.github.io/tags/ssr/"/>
    
    <category term="nuxtjs" scheme="https://shylees.github.io/tags/nuxtjs/"/>
    
  </entry>
  
  <entry>
    <title>http 与 tcp keep-alive 的区别</title>
    <link href="https://shylees.github.io/furtherNotes/further/01%20http%20tcp%20keepalive"/>
    <id>https://shylees.github.io/furtherNotes/further/01%20http%20tcp%20keepalive</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根据 连接轮询扩展</p><p>参考链接:</p><p><a href="https://www.jianshu.com/p/95af6727bf6c">https://www.jianshu.com/p/95af6727bf6c</a></p><p><a href="https://www.jianshu.com/p/cb36364ee099">https://www.jianshu.com/p/cb36364ee099</a>   – 详细</p></blockquote><h2 id="http-keep-alive">HTTP keep-alive<a title="#http-keep-alive" href="#http-keep-alive"></a></h2><blockquote><p>决定tcp连接是长连接还是短连接</p></blockquote><ul><li>HTTP是基于TCP传输协议实现的，<strong>客户端与服务段要进行HTTP连接前，需要先建立TCP连接</strong>，然后客户端发送HTTP请求，服务端收到后就返回响应，至此[请求-应答]完成，随后释放连接。</li></ul><ul><li><p>HTTP短连接：每次请求都经历一个建立TCP的连接。一次连接只能请求一次资源。</p></li><li><p>HTTP长连接：HTTP的keepalive实现了这个功能，可以使用同一个TCP连接来发送和接受多个HTTP请求/应答，避免连接建立释放的过程造成的资源消耗</p></li></ul><ul><li>特点：只要任意一端没有明确提出断开连接，则保持TCP连接。</li><li>为了避免资源浪费的情况，web服务器会提供超时连接的参数，用来指定HTTP长连接的超时时间。</li></ul><h2 id="tcp-keep-alive">TCP keep-alive<a title="#tcp-keep-alive" href="#tcp-keep-alive"></a></h2><ul><li><p>是由TCP内核层实现的，称为<strong>TCP的保活机制</strong></p></li><li><p>定义在一个时间段，在这个时间段内，如果<strong>没有任何连接</strong>的相关活动，<strong>TCP保活机制会开始作用</strong> —— 每隔一个时间段，发送一个探测报文，该探测报文包含的数据非常少，<strong>如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡</strong>，系统内核将错误信息通知上层应用程序。</p></li><li><p>如果对端程序是正常工作的。当TCP保活的探测报文发送给对端，对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。</p></li><li><p>如果对端程序崩溃，或对端由于其他原因导致报文不可达。当TCP保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP会报告该TCP连接已死亡。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;根据 连接轮询扩展&lt;/p&gt;
&lt;p&gt;参考链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/95af6727bf6c&quot;&gt;https://www.jianshu.com/p/95af6727bf6c&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="furtherNotes" scheme="https://shylees.github.io/categories/furtherNotes/"/>
    
    
    <category term="网络" scheme="https://shylees.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>长连接短链接 长轮询短轮询</title>
    <link href="https://shylees.github.io/furtherNotes/further/01%20tcp%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E8%BD%AE%E8%AF%A2"/>
    <id>https://shylees.github.io/furtherNotes/further/01%20tcp%E9%95%BF%E7%9F%AD%E8%BF%9E%E6%8E%A5%E8%BD%AE%E8%AF%A2</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://www.jianshu.com/p/3fc3646fad80">https://www.jianshu.com/p/3fc3646fad80</a></p></blockquote><h2 id="短链接">短链接<a title="#短链接" href="#短链接"></a></h2><p>http1.0</p><p>每次http连接都要经历：发送请求 -&gt; 建立tcp连接 -&gt; 传输数据 -&gt; 关闭tcp连接</p><h2 id="长连接">长连接<a title="#长连接" href="#长连接"></a></h2><p>http1.1</p><p>http connection = keep-alive，发送请求 -&gt; 建立tcp长连接 -&gt; 传输所有http请求及其响应数据 -&gt; 在超时时间内 如果没有请求发送的话就断开连接</p><blockquote><p>HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。</p><p>所以长短连接是指 tcp 连接</p></blockquote><p><strong>Q1</strong> 是不是只要设置Connection为keep-alive就算是长连接了？</p><p><strong>A1</strong> 是的，但要服务器和客户端都设置。</p><blockquote><p>都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接</p></blockquote><p><strong>Q2</strong> 我们平时用的是不是长连接？</p><p><strong>A2</strong> 是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上<strong>Connection都是keep-alive</strong>。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）</p><p><strong>Q3</strong> 这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有什么好处？需不需要关掉长连接而使用短连接？</p><p><strong>A3</strong>  长连接是为了复用TCP连接，也就是说，长连接情况下，<strong>多个HTTP请求可以</strong>复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。</p><p>比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那<strong>你每打开一个网</strong>页，基本<strong>要建立几个甚至几十个TCP连接</strong>，这浪费了多少资源就不用LZ去说了吧。</p><p>但如果是长连接的话，那么这么<strong>多次HTTP请求</strong>（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实<strong>使用的都是一个TCP连接</strong>，很显然是可以节省很多消耗的。</p><p>长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的<strong>超时时间</strong>），这个<strong>连接没有HTTP请求发出的话，那么这个长连接就会被断掉</strong>。</p><blockquote><p>首先长连接是为了复用，比如说在请求这个博客的时候，建立了一条tcp连接，在传输完一个html文件后，连接就关闭了，如果还有后续的css文件就需要再开启一个tcp连接，but 如果用了长连接，再与改网站有关的资源还没传输完的时候一直保持着改连接，</p></blockquote><h2 id="短轮询">短轮询<a title="#短轮询" href="#短轮询"></a></h2><p>在一个需要实时更新数据的地方，比如说商品库存量:</p><p>用JS写个死循环，<strong>不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中</strong>，这其实就是所谓的短轮询。<strong>短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。</strong></p><p>坏处：那就是你很浪费服务器和客户端的资源，如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。</p><blockquote><p>短轮询就是在不停得向后端发送请求查询库存量，后端每次都返回当前数据库的值给前端</p><p>如果在很多用户都看这个页面时，后台就要返回很多数据</p></blockquote><h2 id="长轮询">长轮询<a title="#长轮询" href="#长轮询"></a></h2><p>在一个需要实时更新数据的地方，比如说商品库存量:</p><p>其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中**，服务器如果检测到库存量没有变化的话，将会把当前请求挂起<strong>一段时间（这个时间也叫作</strong>超时时间**，一般是几十秒）。在这个时间里，<strong>服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。</strong></p><blockquote><p>长轮询就是发送一个查询库存量的请求，但是后端是在数据库变化的时候才返回给前端</p></blockquote><h2 id="轮询和连接的区别">轮询和连接的区别<a title="#轮询和连接的区别" href="#轮询和连接的区别"></a></h2><ol><li><p><strong>决定的方式</strong>，</p><p>一个TCP连接是否为长连接，是通过设置<strong>HTTP的Connection Header</strong>来决定的，而且是需要<strong>两边都设置</strong>才有效。</p><p>而一种轮询方式是否为长轮询，是根据<strong>服务端的处理方式</strong>来决定的，与客户端没有关系。</p></li><li><p><strong>实现的方式</strong>，</p><p>连接的长短是通过<strong>协议</strong>来规定和实现的。</p><p>而轮询的长短，是<strong>服务器通过编程</strong>的方式手动挂起请求来实现的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://www.jianshu.com/p/3fc3646fad80&quot;&gt;https://www.jianshu.com/p/3fc3646fad80&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;短</summary>
      
    
    
    
    <category term="furtherNotes" scheme="https://shylees.github.io/categories/furtherNotes/"/>
    
    
    <category term="网络" scheme="https://shylees.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>tcp三次握手、四次挥手</title>
    <link href="https://shylees.github.io/furtherNotes/further/02%20tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"/>
    <id>https://shylees.github.io/furtherNotes/further/02%20tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-03-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：</p><p><a href="https://juejin.cn/post/6844904070889603085#heading-1">https://juejin.cn/post/6844904070889603085#heading-1</a></p><p><a href="https://juejin.cn/post/6844903625513238541">https://juejin.cn/post/6844903625513238541</a></p></blockquote><h2 id="三次握手">三次握手<a title="#三次握手" href="#三次握手"></a></h2><h4 id="为什么要进行三次握手：为了确认对方的发送和接收能力。">为什么要进行三次握手：为了确认对方的发送和接收能力。<a title="#为什么要进行三次握手：为了确认对方的发送和接收能力。" href="#为什么要进行三次握手：为了确认对方的发送和接收能力。"></a></h4><h4 id="主要流程：">主要流程：<a title="#主要流程：" href="#主要流程："></a></h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a1dd6df4813b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" style="zoom: 40%;float:flet;" >  <h4 id="为什么不是两次？">为什么不是两次？<a title="#为什么不是两次？" href="#为什么不是两次？"></a></h4><p>根本原因: 无法确认客户端的接收能力。</p><p>如果是两次，你现在发了 SYN 报文想握手，但是这个包<strong>滞留</strong>在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p><p>看似没有问题，但是连接关闭后，如果这个<strong>滞留</strong>在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认<strong>建立连接</strong>，但是现在客户端已经断开了。</p><h4 id="为什么不是四次？">为什么不是四次？<a title="#为什么不是四次？" href="#为什么不是四次？"></a></h4><p>三次握手的目的是确认双方<code>发送</code>和<code>接收</code>的能力，那四次握手可以嘛？</p><p>当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。</p><h4 id="三次握手过程中可以携带数据么？">三次握手过程中可以携带数据么？<a title="#三次握手过程中可以携带数据么？" href="#三次握手过程中可以携带数据么？"></a></h4><p>第三次握手的时候，可以携带。前两次握手不能携带数据。</p><p>如果前两次握手能够携带数据，<strong>那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据</strong>，增大了服务器被攻击的风险。</p><p>第三次握手的时候，客户端已经处于<code>ESTABLISHED</code>状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p><h4 id="同时打开会怎样？">同时打开会怎样？<a title="#同时打开会怎样？" href="#同时打开会怎样？"></a></h4><p>如果双方同时发 <code>SYN</code>报文，状态变化会是怎样的呢？</p><p>在发送方给接收方发<code>SYN</code>报文的同时，接收方也给发送方发<code>SYN</code>报文，两个人刚上了!</p><p>发完<code>SYN</code>，两者的状态都变为<code>SYN-SENT</code>。</p><p>在各自收到对方的<code>SYN</code>后，两者状态都变为<code>SYN-REVD</code>。</p><p>接着会回复对应的<code>ACK + SYN</code>，这个报文在对方接收之后，两者状态一起变为<code>ESTABLISHED</code>。</p><p>这就是同时打开情况下的状态变迁。</p><h2 id="四次挥手">四次挥手<a title="#四次挥手" href="#四次挥手"></a></h2><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a20296de1ff0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" style="zoom:40%;" ><h4 id="等待2msl的意义">等待2MSL的意义<a title="#等待2msl的意义" href="#等待2msl的意义"></a></h4><p>如果不等待，客户端直接跑路，当<strong>服务端还有很多数据包要给客户端发</strong>，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，<strong>最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。</strong></p><ul><li>1 个 MSL 确保四次挥手中<strong>主动关闭方最后的 ACK 报文最终能达到对端</strong></li><li>1 个 MSL 确保<strong>对端没有收到 ACK 重传的 FIN 报文可以到达</strong></li></ul><p>这就是等待 2MSL 的意义。</p><h4 id="为什么是四次挥手而不是三次？">为什么是四次挥手而不是三次？<a title="#为什么是四次挥手而不是三次？" href="#为什么是四次挥手而不是三次？"></a></h4><p>因为服务端在接收到<code>FIN</code>, 往往不会立即返回<code>FIN</code>, <strong>必须等到服务端所有的报文都发送完毕了，才能发<code>FIN</code></strong>。因此先发一个<code>ACK</code>表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？</p><p>等于<strong>说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手</strong>，这个时候<strong>长时间的延迟</strong>可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code></p><h4 id="同时关闭会怎样？">同时关闭会怎样？<a title="#同时关闭会怎样？" href="#同时关闭会怎样？"></a></h4><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723edeb9e8003~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" style="zoom:67%;" >]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904070889603085#heading-1&quot;&gt;https://juejin.cn/post/6844904070889603085#headi</summary>
      
    
    
    
    <category term="furtherNotes" scheme="https://shylees.github.io/categories/furtherNotes/"/>
    
    
    <category term="网络" scheme="https://shylees.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅浅了解闭包</title>
    <link href="https://shylees.github.io/workNotes/work/09%20%E9%97%AD%E5%8C%85"/>
    <id>https://shylees.github.io/workNotes/work/09%20%E9%97%AD%E5%8C%85</id>
    <published>2022-03-02T03:49:00.000Z</published>
    <updated>2022-03-02T06:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2022.03.02 周三</p><p>参考链接：<a href="https://github.com/lgwebdream/FE-Interview/issues/17">https://github.com/lgwebdream/FE-Interview/issues/17</a></p></blockquote><h2 id="对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景">对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景<a title="#对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景" href="#对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景"></a></h2><h3 id="闭包是什么？">闭包是什么？<a title="#闭包是什么？" href="#闭包是什么？"></a></h3><p>函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，就形成了闭包。</p><blockquote><p>简而言之：可以在内部函数访问到外部函数的作用域。</p></blockquote><p>使用闭包的作用：</p><ol><li>读取函数中的变量</li><li>将函数中的变量存储在内存中，保护变量不被污染。<blockquote><p>因此，会对内存有消耗，所以不可以滥用闭包，否则会影响网页性能，造成内存泄漏。<br>在不需要使用闭包时，要及时释放内存，可以将内层函数对象的变量赋值为 null</p></blockquote></li></ol><h3 id="闭包原理">闭包原理<a title="#闭包原理" href="#闭包原理"></a></h3><p>函数执行分成两个阶段：预编译阶段 和 执行阶段</p><ol><li>预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量，如果已存在“闭包”，就只需要增加对应的属性值即可。</li><li>执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但内部函数还持有该“闭包”的引用，所以内部函数可以继续使用外部函数中的变量</li></ol><blockquote><p>利用函数作用域链的特性，一个函数<strong>内部定义的函数</strong> 会将包含的 <strong>外部函数的活动对象</strong> 添加到它的作用域中，函数执行完毕，其函数执行作用域链销毁；但因为 <strong>内部函数的作用域链</strong> 仍然<strong>在引用</strong>这个活动对象，所以其活动对象不会被销毁，直至内部函数被销毁后才被销毁。</p></blockquote><h3 id="优点">优点<a title="#优点" href="#优点"></a></h3><ul><li>可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期存储在内存中，可供后面使用</li><li>避免变量污染全局</li><li>把变量存在独立的作用域，作为私有成员存在</li></ul><h3 id="缺点">缺点<a title="#缺点" href="#缺点"></a></h3><ul><li>对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。</li><li>对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链的长度</li><li>可能获取到意外的值 captured value</li></ul><h3 id="应用场景">应用场景<a title="#应用场景" href="#应用场景"></a></h3><ol><li>模块封装；在各模块规范出现之前，都是用这样的方式防止变量污染全局</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  bar.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ddd</span> = <span class="keyword">function</span> <span class="title function_">ddd</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>在循环中创建闭包，防止取到意外的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++&gt;)&#123;</span><br><span class="line">  <span class="title function_">foo</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2022.03.02 周三&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://github.com/lgwebdream/FE-Interview/issues/17&quot;&gt;https://github.com/lgwebdream/FE-In</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="js" scheme="https://shylees.github.io/tags/js/"/>
    
    <category term="闭包" scheme="https://shylees.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>关于 v-html 内样式不生效</title>
    <link href="https://shylees.github.io/workNotes/work/07%20v-html%20%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88"/>
    <id>https://shylees.github.io/workNotes/work/07%20v-html%20%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88</id>
    <published>2022-02-24T03:53:00.000Z</published>
    <updated>2022-02-25T05:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>free-vpn 读取$t 里面的内容 作为 html 其中有个 a 标签有其他样式<br>参考链接 <a href="https://cloud.tencent.com/developer/article/1485232">https://cloud.tencent.com/developer/article/1485232</a></p></blockquote><p>关于 v-html</p><blockquote><p>在 vue 使用中，指令 v-html 渲染页面经常用到，类似于 jQuery 的$(‘x’).html( )去渲染。通过指令 v-html 渲染出来的内容还会带有原来的标签及其样式，如果需要修改或者重设其样式，应该如何去做呢？</p></blockquote><ul><li><p>采坑<br>   首先，我在 style 中用子级选择器去选中并修改样式，经过猛如虎的操作后，并没生效。F12 打开 Elements 调试，发现在 style 里面样式根本没加载上去，没有 class 中也没有类名出现。除此之外，渲染非该指令元素时，所有的类名会跟有 [data-v-xxxxxx]的东西。</p></li><li><p>排坑</p><ul><li>去掉 style 中的 scoped;</li><li>watch 监测数据变化;</li><li>深度选择器 &gt;&gt;&gt;</li></ul></li></ul><ol><li>在 vue 组件中，我们写 style 时，为了防止页面样式冲突，在每个组件中会加上 scoped 属性。经测试，去掉该属性即可渲染样式成功。但是在组件过多或者项目中大时，经常会出现页面样式冲突，因此该方法不建议使用。</li><li>在 script&gt;exportdefault 中,watch 属性可监听 v-html 所绑定值的变化。如果是后台请求的数据，那么可以在 watch 中监听改数据变化，当数据发生改变驱动视图后，动态绑定一个 class 来改变子级元素样式。此方法有一定局限性。</li><li>深度选择器 &gt;&gt;&gt;，可深度改变子级样式</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.test</span> &gt;&gt;&gt; * &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 scss或者 less等css扩展语言，则用 /deep/替代 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span> <span class="attr">type</span>=<span class="string">&quot;text/scss&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="language-css">    /deep/ * &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>scoped 属性导致 css 仅对当前组件生效，而 html 绑定渲染出的内容可以理解为是子组件的内容，一般情况下子组件不会被加上对应的属性，所以不会应用带有 scoped 的 css。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;free-vpn 读取$t 里面的内容 作为 html 其中有个 a 标签有其他样式&lt;br&gt;
参考链接 &lt;a href=&quot;https://cloud.tencent.com/developer/article/1485232&quot;&gt;https://cl</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vue" scheme="https://shylees.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 一些注意的问题</title>
    <link href="https://shylees.github.io/workNotes/work/06%20vue%20%E9%97%AE%E9%A2%98"/>
    <id>https://shylees.github.io/workNotes/work/06%20vue%20%E9%97%AE%E9%A2%98</id>
    <published>2022-02-21T09:40:00.000Z</published>
    <updated>2022-02-21T11:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-一些注意的问题">vue 一些注意的问题<a title="#vue-一些注意的问题" href="#vue-一些注意的问题"></a></h1><blockquote><p>参考 官方文档</p></blockquote><ol><li><p>v-if 与 v-show<br>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<strong>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开</strong>销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></li><li><p>避免 v-if 与 v-for 一起使用<br>v-for 优先级比 v-if 高，多了不必要的开销</p></li><li><p>v-for 中的 in 可以被 of 替代，它更接近 JavaScript 迭代器的语法；<br>v-for 中的参数依次为(item, keyname, value);<br>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></li><li><p>数组更新检测<br>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br><code>push() pop() shift() unshift() splice() sort() reverse()</code></p></li><li><p>@click=“handle($event)” 在内联语句处理器中访问原始的 DOM 事件</p></li><li><p>v-model</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">&quot;searchText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;searchText = $event.target.value&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><pre><code>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：+ text 和 textarea 元素使用 value property 和 input 事件；+ checkbox 和 radio 使用 checked property 和 change 事件；+ select 字段将 value 作为 prop 并将 change 作为事件。</code></pre><ol start="7"><li><p>一个组件的data必须是 函数<br>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝</p></li><li><p>注册组件</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-a&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-b&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-c&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentA</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentB</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentC</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: <span class="title class_">ComponentA</span>,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: <span class="title class_">ComponentB</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="9"><li><p>prop 的写法<br>在js中:<code>props:[postTitle]</code>;<br>在html中:<code>&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</code></p></li><li><p>prop 可以通过 v-bind 动态赋值</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="11"><li><p>单项数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-一些注意的问题&quot;&gt;vue 一些注意的问题&lt;a title=&quot;#vue-一些注意的问题&quot; href=&quot;#vue-一些注意的问题&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;参考 官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vue" scheme="https://shylees.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue风格指南</title>
    <link href="https://shylees.github.io/workNotes/work/05%20vue%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"/>
    <id>https://shylees.github.io/workNotes/work/05%20vue%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97</id>
    <published>2022-02-21T08:42:00.000Z</published>
    <updated>2022-02-21T09:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优先级a">优先级A<a title="#优先级a" href="#优先级a"></a></h2><h3 id="组件名为多个单词">组件名为多个单词<a title="#组件名为多个单词" href="#组件名为多个单词"></a></h3><p>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><h3 id="组件数据必为函数">组件数据必为函数<a title="#组件数据必为函数" href="#组件数据必为函数"></a></h3><p>当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。</p><blockquote><p>当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。当组件被重用时，因为每个组件的实例都引用了相同的数据对象，更改其中一个对象就是改变到其他使用到该组件的数据</p></blockquote><p>我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。</p><h3 id="prop-定义应该尽量详细">prop 定义应该尽量详细<a title="#prop-定义应该尽量详细" href="#prop-定义应该尽量详细"></a></h3><p>至少要指定数据类型</p><blockquote><p>细致的 prop 定义有两个好处：</p><p>它们写明了组件的 API，所以很容易看懂组件的用法；</p><p>在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</p></blockquote><h3 id="v-for-设置-key">v-for 设置 key<a title="#v-for-设置-key" href="#v-for-设置-key"></a></h3><p>以便维护内部组件及其子树的状态。</p><h3 id="避免-v-if-和-v-for-一起使用">避免 v-if 和 v-for 一起使用<a title="#避免-v-if-和-v-for-一起使用" href="#避免-v-if-和-v-for-一起使用"></a></h3><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。<br>所以当用在一个元素的时候，会先把所有元素遍历渲染出来，在看v-if哪些是不用渲染的</p><h3 id="为组件样式设置作用域">为组件样式设置作用域<a title="#为组件样式设置作用域" href="#为组件样式设置作用域"></a></h3><p>顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的</p><blockquote><p>这条规则只和单文件组件有关。你不一定要使用 scoped attribute。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。</p><p>不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped attribute。</p><p>这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p></blockquote><p>Vue 使用 _ 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 <em>update) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。<br>对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于私有 property 并不合适。<br>不过，我们推荐把这两个前缀结合为 $</em>，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。</p><h2 id="优先级b">优先级B<a title="#优先级b" href="#优先级b"></a></h2><h3 id="组件文件">组件文件<a title="#组件文件" href="#组件文件"></a></h3><h3 id="单文件组件文件名称">单文件组件文件名称<a title="#单文件组件文件名称" href="#单文件组件文件名称"></a></h3><p>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</p><blockquote><p>单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。</p></blockquote><h3 id="基础组件名">基础组件名<a title="#基础组件名" href="#基础组件名"></a></h3><p>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V</p><h3 id="单例组件名-the">单例组件名 The<a title="#单例组件名-the" href="#单例组件名-the"></a></h3><p>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性</p><p>这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。</p><h3 id="紧密耦合的组件名">紧密耦合的组件名<a title="#紧密耦合的组件名" href="#紧密耦合的组件名"></a></h3><p>和父组件紧密耦合的子组件应该以父组件名作为前缀命名</p><h3 id="自闭合组件">自闭合组件<a title="#自闭合组件" href="#自闭合组件"></a></h3><p>组件名中的单词顺序在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</p><p>自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。</p><p>不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。<br>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 DOM 模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模版中的组件名大小写">模版中的组件名大小写<a title="#模版中的组件名大小写" href="#模版中的组件名大小写"></a></h3><p>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</p><blockquote><p>PascalCase 相比 kebab-case 有一些优势：</p></blockquote><blockquote><p>编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。<br><code>&lt;MyComponent&gt;</code> 视觉上比 <code>&lt;my-component&gt;</code> 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。<br>如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。<br>不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 DOM 模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or 在所有地方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js/jsx-中组件名大小写">js/jsx 中组件名大小写<a title="#js/jsx-中组件名大小写" href="#js/jsx-中组件名大小写"></a></h3><p>JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整单词组件名">完整单词组件名<a title="#完整单词组件名" href="#完整单词组件名"></a></h3><p>组件名应该倾向于完整单词而不是缩写。</p><p>编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p><h3 id="prop名-大小写">prop名 大小写<a title="#prop名-大小写" href="#prop名-大小写"></a></h3><p>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。</p><p><strong>我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</strong></p><h3 id="多-attr-元素">多 attr 元素<a title="#多-attr-元素" href="#多-attr-元素"></a></h3><p>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</p><p>在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。</p><h3 id="模版中简单表达式">模版中简单表达式<a title="#模版中简单表达式" href="#模版中简单表达式"></a></h3><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</p><p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p><h3 id="简单计算属性">简单计算属性<a title="#简单计算属性" href="#简单计算属性"></a></h3><p>应该把复杂计算属性分割为尽可能多的更简单的 property。</p><blockquote><p>易于测试、易于阅读、更好的“拥抱变化”</p></blockquote><h3 id="带引号的-attr-值">带引号的 attr 值<a title="#带引号的-attr-值" href="#带引号的-attr-值"></a></h3><p>非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。</p><p>在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里不写空格，导致可读性变差。</p><h3 id="指令缩写">指令缩写<a title="#指令缩写" href="#指令缩写"></a></h3><p>指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。</p><h2 id="优先级-c">优先级 C<a title="#优先级-c" href="#优先级-c"></a></h2><h3 id="组件/实例的选项顺序">组件/实例的选项顺序<a title="#组件/实例的选项顺序" href="#组件/实例的选项顺序"></a></h3><p>推荐</p><ol><li>副作用 - 触发组件外的影响<ul><li>el</li></ul></li><li>全局感知 - 要求组件外的知识<ul><li>name</li><li>parent</li></ul></li><li>组件类型 - 更改组件类型<ul><li>functional</li></ul></li><li>模版修改器 - 改变模版的编译方式<ul><li>delimiters</li><li>comments</li></ul></li><li>模版依赖 - 模版内使用的资源<ul><li>components</li><li>directives</li><li>filters</li></ul></li><li>组合 - 向选项里合并 property<ul><li>extends</li><li>mixins</li></ul></li><li>接口 - 组件接口<ul><li>inheritAttrs</li><li>model</li><li>props/propsData</li></ul></li><li>本地状态 - 本地响应式 property<ul><li>data</li><li>computed</li></ul></li><li>事件 - 通过响应式事件触发的回调函数<ul><li>watch</li><li>生命周期钩子</li></ul></li><li>非响应式的 property - 不依赖响应式系统的 property<ul><li>methods</li></ul></li><li>渲染 - 组件输出声明描述<ul><li>template/render</li><li>renderError</li></ul></li></ol><h3 id="元素-attr-顺序">元素 attr 顺序<a title="#元素-attr-顺序" href="#元素-attr-顺序"></a></h3><ol><li>定义 - 提供组件的选项<ul><li>is</li></ul></li><li>列表渲染<ul><li>v-for</li></ul></li><li>条件渲染<ul><li>v-if</li><li>v-else-if</li><li>v-else</li><li>v-show</li><li>v-cloak</li></ul></li><li>渲染方式<ul><li>v-pre</li><li>v-once</li></ul></li><li>全局感知 - 需要超越组件的知识<ul><li>id</li></ul></li><li>唯一的attr<ul><li>ref</li><li>key</li></ul></li><li>双向绑定<ul><li>v-model</li></ul></li><li>其他 attr - 所有普通的绑定或未绑定的 attr</li><li>事件<ul><li>v-on</li></ul></li><li>内容<ul><li>v-html</li><li>v-text</li></ul></li></ol><h3 id="组件/实例选项中的空行">组件/实例选项中的空行<a title="#组件/实例选项中的空行" href="#组件/实例选项中的空行"></a></h3><p>你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。</p><p>当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。</p><h3 id="单文件组件的顶级元素的顺序">单文件组件的顶级元素的顺序<a title="#单文件组件的顶级元素的顺序" href="#单文件组件的顶级元素的顺序"></a></h3><p>单文件组件应该总是让 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code> 和 <code>&lt;style&gt;</code> 标签的顺序保持一致。且 <code>&lt;style&gt;</code> 要放在最后，因为另外两个标签至少要有一个。</p><h2 id="优先级d-谨慎使用">优先级D 谨慎使用<a title="#优先级d-谨慎使用" href="#优先级d-谨慎使用"></a></h2><h3 id="不在-v-if/v-else-if/v-else-➕-key">不在 v-if/v-else-if/v-else ➕ key<a title="#不在-v-if/v-else-if/v-else-➕-key" href="#不在-v-if/v-else-if/v-else-➕-key"></a></h3><p>如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <div> 元素)。</p><p>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。</p><h3 id="scoped-避免出现元素选择器">scoped 避免出现元素选择器<a title="#scoped-避免出现元素选择器" href="#scoped-避免出现元素选择器"></a></h3><p>在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p><h3 id="隐性父子组件通信">隐性父子组件通信<a title="#隐性父子组件通信" href="#隐性父子组件通信"></a></h3><p>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。</p><p>一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。</p><p>问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p><h3 id="非-flux-的全局状态管理">非 flux 的全局状态管理<a title="#非-flux-的全局状态管理" href="#非-flux-的全局状态管理"></a></h3><p>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。</p><p>通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。</p><p>Vuex 是 Vue 的官方类 flux 实现，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 Vue DevTools 支持)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优先级a&quot;&gt;优先级A&lt;a title=&quot;#优先级a&quot; href=&quot;#优先级a&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;组件名为多个单词&quot;&gt;组件名为多个单词&lt;a title=&quot;#组件名为多个单词&quot; href=&quot;#组件名为多个单词&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这样做可以</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vue" scheme="https://shylees.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>nuxtjs 的生命周期</title>
    <link href="https://shylees.github.io/workNotes/work/04%20nuxtjs%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"/>
    <id>https://shylees.github.io/workNotes/work/04%20nuxtjs%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F</id>
    <published>2022-02-21T03:28:00.000Z</published>
    <updated>2022-02-21T03:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="asyncdata">asyncData<a title="#asyncdata" href="#asyncdata"></a></h2><blockquote><p>可能想要在服务器端获取并渲染数据。Nuxt.js添加了asyncData方法使得你能够在渲染组件之前异步获取数据。</p></blockquote><p>asyncData 是最常用最重要的生命周期，同时也是服务端渲染的关键点。<br>该生命周期只限于页面组件调用，第一个参数为 context。<br>它调用的时机在组件初始化之前，运作在服务端环境。<br>所以在 asyncData 生命周期中，我们<strong>无法通过 this 引用当前的 Vue 实例</strong>，也<strong>没有 window 对象和 document 对象</strong>，这些是我们需要注意的。<br>一般在 asyncData 会对主要<strong>页面数据进行预先请求</strong>，获取到的数据会交由服务端拼接成 html 返回前端渲染，以此提高首屏加载速度和进行 seo 优化。</p><h2 id="fecth">fecth<a title="#fecth" href="#fecth"></a></h2><blockquote><p>用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它<strong>不会设置组件的数据。</strong></p></blockquote><p>得知该生命周期用于填充 Vuex 状态树，与 asyncData 同样，它在组件初始化前调用，第一个参数为 context。但这并不是说我们只能在 fetch 中填充状态树，在 asyncData 中同样可以。</p><h2 id="validate">validate<a title="#validate" href="#validate"></a></h2><blockquote><p>但这并不是说我们只能在 fetch 中填充状态树，在 asyncData 中同样可以。</p></blockquote><p>在验证路由参数合法性时，它能够帮助我们，第一个参数为 context。与上面有点不同的是，我们能够访问实例上的方法 <a href="http://this.methods.xxx">this.methods.xxx</a>。</p><h2 id="watchquery">watchQuery<a title="#watchquery" href="#watchquery"></a></h2><blockquote><p>监听参数字符串更改并在更改时执行组件方法 (asyncData, fetch, validate, layout, …)</p></blockquote><p>watchQuery 可设置 Boolean 或 Array (默认: [])。使用 watchQuery 属性可以监听参数字符串的更改。 如果定义的字符串发生变化，将调用所有组件方法(asyncData, fetch, validate, layout, …)。 为了提高性能，默认情况下禁用。<br>使用 watchQuery有点好处就是，当我们使用浏览器后退按钮或前进按钮时，页面数据会刷新，因为参数字符串发生了变化。</p><h2 id="head">head<a title="#head" href="#head"></a></h2><blockquote><p>Nuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性。</p></blockquote><p>使用 head 方法设置当前页面的头部标签，该方法里能通过 this 获取组件的数据。<br>除了好看以外，正确的设置 meta 标签，还能有利于页面被搜索引擎查找，进行 seo 优化。<br>一般都会设置 description(简介) 和 keyword(关键词)。</p><h2 id="生命周期的调用顺序">生命周期的调用顺序<a title="#生命周期的调用顺序" href="#生命周期的调用顺序"></a></h2><p>validate  =&gt;  asyncData  =&gt;  fetch  =&gt;  head</p><blockquote><p>参考链接 <a href="https://juejin.cn/post/6844904160324747278#heading-12">https://juejin.cn/post/6844904160324747278#heading-12</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;asyncdata&quot;&gt;asyncData&lt;a title=&quot;#asyncdata&quot; href=&quot;#asyncdata&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可能想要在服务器端获取并渲染数据。Nuxt.js添加了asyncData方法使得你能够在渲染</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="ssr" scheme="https://shylees.github.io/tags/ssr/"/>
    
  </entry>
  
  <entry>
    <title>ssr - Server Side Render</title>
    <link href="https://shylees.github.io/workNotes/work/03%20ssr"/>
    <id>https://shylees.github.io/workNotes/work/03%20ssr</id>
    <published>2022-02-18T10:13:00.000Z</published>
    <updated>2022-02-18T11:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://juejin.cn/post/7002198277462442014">https://juejin.cn/post/7002198277462442014</a></p></blockquote><p>服务端渲染 ssr，是指一种传统的渲染开发方式，就是在页面请求url的时候，<strong>服务端将我们需要的 html 文本组装好，并返回给浏览器</strong>，这个HTML文本被浏览器解析之后，不需要<strong>经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树</strong>并展示到页面中。</p><p>ssr 有两种模式，单页面 和 非单页面 模式</p><ul><li>单页面：后端首次渲染的单页面应用</li><li>非单页面：完全使用后端路由的后端模版渲染模式</li></ul><blockquote><p>区别于 使用后端路由的程度</p></blockquote><h2 id="csr---client-side-render">csr - Client Side Render<a title="#csr---client-side-render" href="#csr---client-side-render"></a></h2><p>csr与ssr其对应的，一种目前流行的渲染方式，它<strong>依赖的是运行在客户端的JS</strong>，用户首次发送请求<strong>只能得到小部分的指引性HTML代码</strong>。第二次请求将会请求更多包含HTML字符串的JS文件。</p><h2 id="需要ssr的原因">需要ssr的原因<a title="#需要ssr的原因" href="#需要ssr的原因"></a></h2><p>SPA应用的<strong>首屏打开速度很慢</strong>，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，且 <strong>SPA 应用不利于 SEO 优化</strong>。</p><p>想着是不是可以<strong>将应用首页先加载出来，然后让首页用不到的其他 JS 文件再慢慢加载</strong>。但是由于 JS 引擎是单线程的，数据的组装过程会受到阻塞，单靠浏览器端的话不容易实现。</p><p>SSR 契机就在此，如果<strong>将组装数据、渲染 HTML 页面的过程放在服务端</strong>，而<strong>浏览器端只负责显示接收到的 HTML 文</strong>件，那首屏的打开速度无疑会快很多。</p><h2 id="优缺点">优缺点<a title="#优缺点" href="#优缺点"></a></h2><ul><li>优点<ul><li><strong>更快的响应时间</strong>，相对于客户端渲染，服务端渲染在浏览器请求URL之后已经<strong>得到了一个带有数据的HTML文本</strong>，浏览器只需要解析HTML，直接构建DOM树就可以</li><li><strong>有利于 SEO</strong> ，可以<strong>将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据</strong>，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高。</li></ul></li><li>缺点<ul><li>相<strong>对于只需要提供静态文件的服务器</strong>，SSR中使用的渲染程序自然会<strong>占用更多的CPU和内存资源</strong></li><li>一些<strong>常用的浏览器API可能无法正常使用</strong>，比如<code>window</code>、<code>docment</code>和<code>alert</code>等，如果使用的话需要对运行的环境加以判断</li><li>开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于<strong>SPA的一些组件的生命周期的管理会变得复杂</strong></li><li>可能会由于某些因素导致服务器端渲染的结果与浏览器端的<strong>结果不一致</strong></li></ul></li><li>总结<ul><li>最适用于静态展示页面，如果页面动态数据较多时需要谨慎使用。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://juejin.cn/post/7002198277462442014&quot;&gt;https://juejin.cn/post/7002198277462442014&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="vue" scheme="https://shylees.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用</title>
    <link href="https://shylees.github.io/workNotes/work/02%20spa%E4%BC%98%E7%BC%BA%E7%82%B9"/>
    <id>https://shylees.github.io/workNotes/work/02%20spa%E4%BC%98%E7%BC%BA%E7%82%B9</id>
    <published>2022-02-18T09:23:00.000Z</published>
    <updated>2022-02-18T09:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://juejin.cn/post/6950100237985775623">https://juejin.cn/post/6950100237985775623</a></p></blockquote><p>单页面应用程序将所有的活动局限于一个Web页面中，在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成，单页面应用不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，单页面应用可以提供较为流畅的用户体验。</p><h2 id="1.-优点">1. 优点<a title="#1.-优点" href="#1.-优点"></a></h2><ul><li>良好的交互体验<br>内容改变不需要重新加载整个页面，获取数据通过 ajax 异步获取，没有页面之间的切换，不会在跳转的时候出现 “白屏现象”，页面显示流畅。</li><li>良好的前后端工作分离模式<br>后端不负责模版渲染、输出页面工作，后端 api 通用化</li><li>减轻服务器压力<br>相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力提高</li></ul><h2 id="2.-缺点">2. 缺点<a title="#2.-缺点" href="#2.-缺点"></a></h2><ul><li><p>首屏加载慢<br>解决：</p><ol><li>vue-router 懒加载<br>vue-router 是按需加载组件，只有当路由被访问时才会加载对应组件，而不是在加载首页时加载，项目越大，对首屏加载的速度提升得越明显</li><li>使用 cdn 加速<br>在做项目时，我们会用到很多库，采用cdn可以加快加载速度</li><li>异步加载组件</li><li>服务端渲染<br>也对 seo 优化起到作用，有利于搜索引擎抓取更多信息r<br>如果页面纯 前端渲染，搜索引擎抓取到的就只是空页面</li></ol></li><li><p>不利于 seo</p><blockquote><p>seo 本质是 一个服务器向另一个服务器发请求，解析请求内容。<br>但一般来说搜索引擎是不会去执行请求到 js 的，即  <strong>搜索引擎的基础爬虫的原理就是抓取 url，然后获取 html 源代码并解析</strong><br>如果是一个 spa ，html 在浏览器才渲染出数据， <strong>seo 请求到的html 是模型页面 而不是 最终数据的 渲染页面</strong>，这样就不利于内容被搜索引擎搜到</p></blockquote><p>解决：</p><ol><li>服务端渲染 ssr<br>服务器合成完整的 html 文件再输出到浏览器</li><li>页面预渲染</li><li>路由采用 h5 history模式</li></ol></li><li><p>不适合开发大型项目</p><blockquote><p>有可能涉及大量 dom 操作、复杂动画效果</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://juejin.cn/post/6950100237985775623&quot;&gt;https://juejin.cn/post/6950100237985775623&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="css" scheme="https://shylees.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>sass -- css 预处理器</title>
    <link href="https://shylees.github.io/workNotes/work/01%20scss%20sass"/>
    <id>https://shylees.github.io/workNotes/work/01%20scss%20sass</id>
    <published>2022-02-18T06:58:00.000Z</published>
    <updated>2022-02-18T08:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2022.02.18 在公司熟悉环境时看到用的 cass 所以先去了解</p><p>参考网站 <a href="https://www.sass.hk/guide/">https://www.sass.hk/guide/</a></p><p>介绍：<a href="https://juejin.cn/post/6844904169313140749">https://juejin.cn/post/6844904169313140749</a></p><p>简洁区别：<a href="https://juejin.cn/post/6844904086676963341">https://juejin.cn/post/6844904086676963341</a></p></blockquote><h1 id="sass-css-预处理器">sass css 预处理器<a title="#sass-css-预处理器" href="#sass-css-预处理器"></a></h1><p>CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。</p><h2 id="0.1-使用-预处理器的原因">0.1 使用 预处理器的原因<a title="#0.1-使用-预处理器的原因" href="#0.1-使用-预处理器的原因"></a></h2><p>CSS仅仅是一个标记语言，不可以自定义变量，不可以引用。<br><strong>CSS有具体以下几个缺点：</strong></p><ul><li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</li><li>预编译很容易造成后代选择器的滥用</li></ul><p><strong>使用预处理器的优点:</strong></p><ul><li>提供CSS层缺失的样式层复用机制</li><li>减少冗余代码</li><li>提高样式代码的可维护性</li></ul><p>Sass 和 Less 这类语言，其实可以理解成 <strong>CSS 的超集</strong>，它们在CSS 原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 CSS 代码更容易维护和复用。</p><p>但浏览器最终肯定是只认识 CSS 文件的，它无法处理 CSS 中的那些变量、逻辑语句，<strong>所以需要有一个编译的过程，将 Sass 或 Less 写的代码转换成标准的 CSS 代码，这个过程就称为 CSS 预处理。</strong></p><h2 id="0.2-less-&amp;-sass">0.2 less &amp; sass<a title="#0.2-less-&amp;-sass" href="#0.2-less-&amp;-sass"></a></h2><ul><li><p>Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。因为 Less 和 CSS 非常像，<strong>Less 仅对 CSS 语言增加了少许方便的扩展，学习很容易</strong> .</p></li><li><p>sass，作为”世界上最成熟、最稳定、最强大的专业级CSS扩展语言”。<strong>兼容所有版本的css，且有无数框架使用sass构建</strong>，如Compass，Bourbon，和Susy。</p></li></ul><blockquote><p>SASS版本3.0之前的后缀名为.sass，而版本3.0之后的后缀名.scss。</p></blockquote><p><strong>相同之处：</strong><br>1、混入(Mixins)—class中的class；<br>2、参数混入—可以传递参数的class，就像函数一样；<br>3、嵌套规则—Class中嵌套class，从而减少重复的代码；<br>4、运算—CSS中用上数学；<br>5、颜色功能—可以编辑颜色；<br>6、名字空间(namespace)—分组样式，从而可以被调用；<br>7、作用域—局部修改样式；<br>8、JavaScript 赋值—在CSS中使用JavaScript表达式赋值。</p><p><strong>不同之处：</strong></p><blockquote><p>sass less</p></blockquote><ul><li><p>环境: dart或其他  |  基于javascript,可以运行在 Node 或浏览器</p></li><li><p>使用: 复杂  |  简单(相对而言)</p></li><li><p>功能: 复杂  |  简单(相对而言)</p></li><li><p>处理机制: 服务端处理  |  可以运行在 Node 或浏览器端<br>变量: 以 $ 开头  |  以 @ 开头<br>文件后缀: .sass 或. scss  |  .less</p></li><li><p>在Less中，<strong>仅允许循环数值</strong>。<br>在Sass中，我们可以<strong>遍历任何类型的数据</strong>。但在Less中，我们只能使用递归函数循环数值。</p></li><li><p>条件语句<br>Less 中并<strong>不支持</strong>条件语句，当然，可以通过内置函数 if 以及 and，or，not 这些来模拟条件语句。<br>在 Sass 中是<strong>支持</strong>条件语句的，但也不是像其他编程语言直接 if 这样通过保留字来编写，需要加个 @ 符号</p></li></ul><h2 id="1.-使用变量">1. 使用变量<a title="#1.-使用变量" href="#1.-使用变量"></a></h2><p>sass 使用 <code>$</code> 作为标识变量</p><blockquote><p>老版的 scss 使用 <code>!</code> 作为标识，改变的原因 – 太丑了 ?</p></blockquote><ol><li>声明 引用 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    $highlight-<span class="attribute">color</span>: <span class="number">#F90</span>;</span><br><span class="line">    <span class="selector-class">.selected</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: $highlight-border;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2</span>. 变量名用中划线 / 下划线</span><br><span class="line">    随便、爱用啥用啥，且 sass 将其视为一样的，都指向一个变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">2</span>. 嵌套 css 规则</span><br><span class="line">~~~css </span><br><span class="line">    <span class="selector-id">#content</span> &#123;</span><br><span class="line">        <span class="selector-tag">article</span> &#123;</span><br><span class="line">            <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: <span class="number">#333</span> &#125;</span><br><span class="line">            <span class="selector-tag">p</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">aside</span> &#123; <span class="attribute">background-color</span>: <span class="number">#EEE</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="1.1-父选择器标识符-&amp;">1.1 父选择器标识符 <code>&amp;</code><a title="#1.1-父选择器标识符-&amp;" href="#1.1-父选择器标识符-&amp;"></a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*编译后*/</span></span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red &#125;</span><br></pre></td></tr></table></figure><h3 id="1.2-群组选择器-,">1.2 群组选择器 <code>,</code><a title="#1.2-群组选择器-," href="#1.2-群组选择器-,"></a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;<span class="attribute">margin-bottom</span>: .<span class="number">8em</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1.3-子组合选择器和同层组合选择器-&gt;-+-~">1.3 子组合选择器和同层组合选择器 <code>&gt;</code> <code>+</code> <code>~</code><a title="#1.3-子组合选择器和同层组合选择器-&gt;-+-~" href="#1.3-子组合选择器和同层组合选择器-&gt;-+-~"></a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子 */</span></span><br><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">section</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同层相邻组合 */</span></span><br><span class="line"><span class="selector-tag">header</span> + <span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.1em</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同层全体组合 */</span></span><br><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123; <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="1.4-嵌套属性">1.4 嵌套属性<a title="#1.4-嵌套属性" href="#1.4-嵌套属性"></a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">  style: solid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3.-导入-sass-文件">3. 导入 sass 文件<a title="#3.-导入-sass-文件" href="#3.-导入-sass-文件"></a></h2><ul><li><p>css 中不常用的特性：<code>@import</code> 规则，它允许在一个<code>css</code> 文件中导入其他 <code>css</code> 文件。然而，后果是<strong>只有执行到 <code>@import</code> 时，浏览器才会去下载其他 <code>css</code> 文件，这导致页面加载起来特别慢。</strong></p></li><li><p>sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。</p></li></ul><h3 id="3.1-局部文件-/-部分文件">3.1 局部文件 / 部分文件<a title="#3.1-局部文件-/-部分文件" href="#3.1-局部文件-/-部分文件"></a></h3><p>当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为<strong>局部文件</strong>。</p><p>此约定即，<strong>sass局部文件的文件名以下划线开头</strong>。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。</p><h3 id="3.2-默认变量值-!default">3.2 默认变量值 <code>!default</code><a title="#3.2-默认变量值-!default" href="#3.2-默认变量值-!default"></a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$fancybox-<span class="attribute">width</span>: <span class="number">400px</span> !default;</span><br><span class="line"><span class="selector-class">.fancybox</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: $fancybox-width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果用户在导入你的sass局部文件之前声明了一个<code>$fancybox-width</code>变量，那么你的局部文件中对<code>$fancybox-width</code>赋值<code>400px</code>的操作就无效。如果用户没有做这样的声明，则<code>$fancybox-width</code>将默认为<code>400px</code>。</p></blockquote><h3 id="3.3-嵌套导入">3.3 嵌套导入<a title="#3.3-嵌套导入" href="#3.3-嵌套导入"></a></h3><p>跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  blue-theme 文件 */</span></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用文件 */</span></span><br><span class="line"><span class="selector-class">.blue-theme</span> &#123;<span class="keyword">@import</span> <span class="string">&quot;blue-theme&quot;</span>&#125;</span><br><span class="line">.blue-theme &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3.4-原生-css-导入">3.4 原生 css 导入<a title="#3.4-原生-css-导入" href="#3.4-原生-css-导入"></a></h3><p>由于sass兼容原生的css，所以它也支持原生的CSS <code>@import</code>。<br>尽管通常在sass中使用<code>@import</code>时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS<code>@import</code>，这会造成浏览器解析css时的额外下载：</p><ul><li>被导入文件的名字以.css结尾；</li><li>被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</li><li>被导入文件的名字是CSS的url()值。</li></ul><p>so 不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。</p><p>但是，因为sass的语法完全兼容css，所以你可以<strong>把原始的css文件改名为.scss后缀，即可直接导入了</strong></p><h2 id="4.-静默注释">4. 静默注释<a title="#4.-静默注释" href="#4.-静默注释"></a></h2><p>sass 提供了一种不同于 css 标准的注释格式 <code>//</code> , 在编译成 css 后，这些用 <code>//</code> 的注释语句都会被抹去</p><h2 id="5.-混合器-@mixin-@include">5. 混合器 <code>@mixin</code> <code>@include</code><a title="#5.-混合器-@mixin-@include" href="#5.-混合器-@mixin-@include"></a></h2><p>需要大段大段的重用样式的代码，可以通过sass的混合器实现大段样式的重用。</p><p>混合器使用<code>@mixin</code>标识符定义。这个标识符给一大段样式赋予一个名字，可以通过引用这个名字重用这段样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> rounded-corners &#123;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notice &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#00aa00</span>;</span><br><span class="line">  <span class="keyword">@include</span> rounded-corners;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* less */</span></span><br><span class="line"><span class="selector-class">.post</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  rounded-corners();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5.1-使用混合器的时间">5.1 使用混合器的时间<a title="#5.1-使用混合器的时间" href="#5.1-使用混合器的时间"></a></h3><p>混合器是在样式表中应用的。混合器是展示性的描述，用来描述一条css规则应用之后会产生怎样的效果。</p><p>混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。</p><h3 id="5.2-混合器中css规则">5.2 混合器中css规则<a title="#5.2-混合器中css规则" href="#5.2-混合器中css规则"></a></h3><p>不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> no-bullets &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-image</span>: none;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5.3-给混合器传参">5.3 给混合器传参<a title="#5.3-给混合器传参" href="#5.3-给混合器传参"></a></h3><p>可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors($normal, $<span class="attribute">hover</span>, $visited) &#123;</span><br><span class="line">  <span class="attribute">color</span>: $normal;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: $hover; &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: $visited; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过$name: value的形式指定每个参数的值 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> link-colors(</span><br><span class="line">      $<span class="attribute">normal</span>: blue,</span><br><span class="line">      $<span class="attribute">visited</span>: green,</span><br><span class="line">      $<span class="attribute">hover</span>: red</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5.4-默认参数值">5.4 默认参数值<a title="#5.4-默认参数值" href="#5.4-默认参数值"></a></h3><p>参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(</span><br><span class="line">    $normal,</span><br><span class="line">    $<span class="attribute">hover</span>: $normal,</span><br><span class="line">    $<span class="attribute">visited</span>: $normal</span><br><span class="line">  )&#123;</span><br><span class="line">  <span class="attribute">color</span>: $normal;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: $hover; &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: $visited; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6.-使用选择器继承-@extend">6. 使用选择器继承 <code>@extend</code><a title="#6.-使用选择器继承-@extend" href="#6.-使用选择器继承-@extend"></a></h2><blockquote><p>if 想重用语义化</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>.seriousError</code>将会继承样式表中任何位置处为<code>.error</code>定义的所有样式<br>==<br>以<code>class=&quot;seriousError&quot;</code> 修饰的html元素最终的展示效果就好像是<code>class=&quot;seriousError error&quot;</code>。</p></blockquote><h3 id="6.1-什么时候使用继承">6.1 什么时候使用继承<a title="#6.1-什么时候使用继承" href="#6.1-什么时候使用继承"></a></h3><p><strong>混合器</strong>主要用于展示性样式的重用，而类名用于语义化样式的重用。因为<strong>继承是基于类</strong>的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。</p><h3 id="6.2-继承的高级用法">6.2 继承的高级用法<a title="#6.2-继承的高级用法" href="#6.2-继承的高级用法"></a></h3><p>最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>if 一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式</p></blockquote><h3 id="6.3-继承的工作细节">6.3 继承的工作细节<a title="#6.3-继承的工作细节" href="#6.3-继承的工作细节"></a></h3><p><code>@extend</code>背后最基本的想法是:<br>如果<code>.seriousError @extend .error</code>， 那么样式表中的任何一处<code>.error</code>都用<code>.error.seriousError</code>这一选择器组进行替换。这就意味着相关样式会如预期那样应用到<code>.error</code>和<code>.seriousError</code></p><blockquote><ul><li>跟混合器相比，<strong>继承生成的css代码相对更少</strong>。<br>因为<strong>继承仅仅是重复选择器，而不会重复属性</strong>，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。</li></ul></blockquote><ul><li><strong>继承遵从css层叠</strong>的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，根据权重选择。</li><li><strong>混合器本身不会引起css层叠的问题</strong>，因为混合器把样式直接放到了css规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2022.02.18 在公司熟悉环境时看到用的 cass 所以先去了解&lt;/p&gt;
&lt;p&gt;参考网站 &lt;a href=&quot;https://www.sass.hk/guide/&quot;&gt;https://www.sass.hk/guide/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介</summary>
      
    
    
    
    <category term="workNotes" scheme="https://shylees.github.io/categories/workNotes/"/>
    
    
    <category term="css" scheme="https://shylees.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>WEB 开发的安全之旅 - 字节青训营</title>
    <link href="https://shylees.github.io/learningNotes/ByteDance/10%20%E5%88%98%E5%AE%87%E6%99%A8%20web%20%E5%BC%80%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E6%97%85"/>
    <id>https://shylees.github.io/learningNotes/ByteDance/10%20%E5%88%98%E5%AE%87%E6%99%A8%20web%20%E5%BC%80%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E6%97%85</id>
    <published>2022-01-26T16:00:00.000Z</published>
    <updated>2022-01-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两个角度看安全：hacker 攻击、开发者 防御</p></blockquote><h2 id="攻击者">攻击者<a title="#攻击者" href="#攻击者"></a></h2><h3 id="xss-—-cross-site-scripting">XSS — Cross-Site Scripting<a title="#xss-—-cross-site-scripting" href="#xss-—-cross-site-scripting"></a></h3><p>攻击者在网站上提交一段恶意脚本 &lt;script&gt;&lt;/script&gt; ，网站将其当成自身dom执行编译。</p><ul><li><p>主要利用了：</p><ul><li>盲目信任用户提交内容</li><li>把用户提交的string 直接转化为 DOM<ul><li>document.write</li><li>element.innerHTML = anyString;</li><li>SSR(user_data)</li></ul></li></ul></li><li><p>特点：</p><ul><li>难以从 UI 上感知，暗地执行脚本</li><li>窃取用户信息 cookie/token</li><li>绘制 UI 例如弹窗，诱骗用户点击 / 填写表单</li></ul></li></ul><h4 id="存储型-stored-xss：">存储型 Stored XSS：<a title="#存储型-stored-xss：" href="#存储型-stored-xss："></a></h4><ul><li>恶意脚本被<strong>存放在数据库</strong>中</li><li>访问页面 -&gt; 读数据 == 被攻击</li><li>危害最大，对全部用户都可见</li></ul><h4 id="反射型-reflected：">反射型 Reflected：<a title="#反射型-reflected：" href="#反射型-reflected："></a></h4><ul><li><p>不涉及数据库</p></li><li><p><strong>从 URL 上攻击</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 url 为 </span></span><br><span class="line"><span class="comment">// host/path/?param=&lt;script&gt;alert(&#x27;123&#x27;)&lt;/script&gt;</span></span><br><span class="line">public <span class="keyword">async</span> <span class="title function_">render</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; param &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`&lt;div&gt;<span class="subst">$&#123; param &#125;</span>&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于-dom-dom-based：">基于 dom DOM-based：<a title="#基于-dom-dom-based：" href="#基于-dom-dom-based："></a></h4><ul><li><p>不需要服务器的参与</p></li><li><p>恶意攻击的发起 + 执行，<strong>全在浏览器完成</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 url 为 </span></span><br><span class="line"><span class="comment">// host/path/?param=&lt;script&gt;alert(&#x27;123&#x27;)&lt;/script&gt;</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="keyword">new</span> <span class="title function_">URL</span>(location.<span class="property">href</span>).<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&quot;param&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = content;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(div)</span><br></pre></td></tr></table></figure><blockquote><p>与反射型很像，区别在于 完成注入脚本的地方：反射型在 server端、DOM 在浏览器完成闭环</p></blockquote></li></ul><h4 id="基于-mutation-mutation-based：">基于 mutation Mutation-based：<a title="#基于-mutation-mutation-based：" href="#基于-mutation-mutation-based："></a></h4><ul><li><p>利用了浏览器渲染 DOM 的特性 – 独特优化</p></li><li><p>不同浏览器，会有区别 – 按浏览器进行攻击</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot;&lt;/noscript&gt;&lt;img src=x onerror=alert()&gt;&quot;</span>&gt;</span></span><br><span class="line">// 为</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span> <span class="attr">title</span>=<span class="string">&quot; &lt;/noscript&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;img src=&quot;</span><span class="attr">x</span>&quot; <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span></span><br><span class="line">    &quot;&quot;&quot;&gt;&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="csrf-跨站伪造请求-—-cross-site-request-forgery">CSRF 跨站伪造请求 — Cross-site request forgery<a title="#csrf-跨站伪造请求-—-cross-site-request-forgery" href="#csrf-跨站伪造请求-—-cross-site-request-forgery"></a></h3><p>在用户不知情的前提下，利用用户权限 cookie，构造指定 HTTP 请求，窃取或修改用户铭感信息</p><p>例子：银行转账</p><h4 id="get">GET<a title="#get" href="#get"></a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://bank.com/transfer?to=hacker&amp;amount=100&quot;</span>&gt;</span>点我抽奖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://bank.com/transfer?to=hacker&amp;amount=100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="post">POST<a title="#post" href="#post"></a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://bank.com/transfer_tons_of_money&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;to&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="injection-注入">Injection 注入<a title="#injection-注入" href="#injection-注入"></a></h3><h4 id="sql">SQL<a title="#sql" href="#sql"></a></h4><p>请求：SQL 参数 恶意注入</p><p>Server：运行 SQL code</p><p>获取其他数据、修改数据、删除数据…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取请求字段  直接以字符串的形式拼接 SQL 语句</span></span><br><span class="line">public <span class="keyword">async</span> <span class="title function_">renderForm</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, form_id &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> aql.<span class="title function_">query</span>(<span class="string">`</span></span><br><span class="line"><span class="string">select a,b,c from table</span></span><br><span class="line"><span class="string">where username = <span class="subst">$&#123;username&#125;</span></span></span><br><span class="line"><span class="string">and form_id = <span class="subst">$&#123; from_id &#125;</span></span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="title function_">renderForm</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>:&#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>:<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;any; drop table tabelname;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 造成 select xxx from xxx drop table tablename 删库跑路</span></span><br></pre></td></tr></table></figure><h4 id="injection-不止于-sql">Injection 不止于 SQL<a title="#injection-不止于-sql" href="#injection-不止于-sql"></a></h4><ul><li><p>CLI 命令行</p></li><li><p>OS command 系统命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视频格式转换</span></span><br><span class="line">public <span class="keyword">async</span> <span class="title function_">convertVideo</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; video, options &#125; = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">    <span class="title function_">exec</span>(<span class="string">`convert-cli <span class="subst">$&#123; video &#125;</span> -o <span class="subst">$&#123; options &#125;</span>`</span>);</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">options</span>:<span class="string">`&#x27; &amp;&amp; rm -rf xxx`</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 删除系统文件的命令 </span></span><br><span class="line"><span class="keyword">const</span> command = <span class="string">`convert-cli video -o &amp;&amp; rm -rf xxx`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>除了删除还能进行 读取 修改</p></blockquote></li><li><p>Server-Side Request Forgery — ssrf，服务端伪造请求</p><blockquote><p>严格上说不是 injection ，但是原理类似</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求 用户自定义 的callback url</span></span><br><span class="line"><span class="comment">// web server 通常有内网访问权限</span></span><br><span class="line">public <span class="keyword">async</span> <span class="title function_">webhook</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="comment">// callback 可能是内网 url </span></span><br><span class="line">    <span class="comment">// e.g http://secret.com/get_employ_payrolls</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="keyword">await</span> <span class="title function_">fetch</span>(ctx.<span class="property">query</span>.<span class="property">callback</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 callback === 暴露内网信息</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="dos-—-denial-of-service">Dos — Denial of Service<a title="#dos-—-denial-of-service" href="#dos-—-denial-of-service"></a></h3><p>通过某种方式 构造特定请求，导致服务器资源被显著消耗，来不及响应更多请求，导致请求挤压，进而雪崩效应</p><h4 id="redos：基于正则表达式的-dos">ReDos：基于正则表达式的 Dos<a title="#redos：基于正则表达式的-dos" href="#redos：基于正则表达式的-dos"></a></h4><p>贪婪：n 次不行？n-1次再试试 — 回溯</p><blockquote><p>正则表达式的贪婪模式：</p><p>重复匹配时 <code>?</code>  与 <code>no ?</code>  满足<code>一个即可 </code> 与 <code>尽量多</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greedyRegExp = <span class="string">&quot;/a+/&quot;</span>;  <span class="comment">// 有多少匹配多少</span></span><br><span class="line"><span class="keyword">const</span> nonGreedyRegExp = <span class="string">&quot;/a+?/&quot;</span> <span class="comment">// 有一个就可以</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(greedyRegExp)[<span class="number">0</span>]) <span class="comment">//aaaaa</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(nonGreedyRegExp)[<span class="number">0</span>]) <span class="comment">//a</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="logical-dos">Logical Dos<a title="#logical-dos" href="#logical-dos"></a></h4><ul><li>耗时的同步操作</li><li>数据库写入</li><li>SQL join</li><li>文件备份</li><li>循环执行逻辑</li></ul><h4 id="ddos-—-distributed-dos">DDos — Distributed Dos<a title="#ddos-—-distributed-dos" href="#ddos-—-distributed-dos"></a></h4><p>短时间内，来自大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积，进而雪崩效应，无法响应新请求。</p><p>特点：直接访问 IP、任意 API、消耗大量带宽</p><p>demo：SYN Flood 洪水攻击：攻击者发送很多 SYN 与服务器进行连接，但是不进行确认连接，</p><p>​              导致，握手没有完成， connection 不能被释放，达到最大可连接数，无法连接新请求</p><h3 id="传输层-—-中间人攻击">传输层 — 中间人攻击<a title="#传输层-—-中间人攻击" href="#传输层-—-中间人攻击"></a></h3><img src = 'https://i.bmp.ovh/imgs/2022/01/3c7be4efb4995095.png' style="zoom: 50%;" /><p>原因：</p><ul><li>明文传输</li><li>信息篡改不可知</li><li>对方身份未验证</li></ul><h2 id="防御篇">防御篇<a title="#防御篇" href="#防御篇"></a></h2><h3 id="xss">XSS<a title="#xss" href="#xss"></a></h3><ul><li><p>永远不信任用户的提交内容</p></li><li><p>不要将用户提交内容直接转换成 DOM</p></li><li><p>现成工具：</p><ul><li>前端：主流框架默认防御 xss、google-closure-library</li><li>服务端 node：DOMPurify</li></ul></li><li><p>用户需求：需要动态生成 DOM，需要注意的点：</p><ul><li><p>string 转 DOM：注意转译 new DOMParse()</p></li><li><p>上传 svg：对其进行扫描，避免生成图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义跳转链接：要过滤，因为可以写js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=radio]</span><span class="selector-class">.income-gt10k</span><span class="selector-pseudo">:checked</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;https://hacker.com/?income=gt10k&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="csp---content-security-policy-内容安全策略">CSP - Content Security Policy 内容安全策略<a title="#csp---content-security-policy-内容安全策略" href="#csp---content-security-policy-内容安全策略"></a></h3><ul><li>哪些源被认为是安全的</li><li>来自安全源的脚本可以执行，否则直接抛错</li><li>禁止 eval + inline script</li></ul><p>设置的方式：</p><ol><li><p>服务器的响应头部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>: script-src <span class="string">&#x27;self&#x27;</span> <span class="comment">// 同源</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>: script-src <span class="string">&#x27;self&#x27;</span> <span class="attr">https</span>:<span class="comment">//domain.com //同源加 后面这个可以访问</span></span><br></pre></td></tr></table></figure></li><li><p>浏览器 meta：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">htpp-eqiuv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;script-src self&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="csrf">CSRF<a title="#csrf" href="#csrf"></a></h3><p>因为其是<strong>伪造请求</strong>，是<strong>异常来源</strong>，then <strong>限制请求来源</strong>，也就<strong>限制了 伪造请求</strong></p><ul><li><p>方法</p><ul><li><p>服务端开发人员可以通过校验 <strong>Origin (同源请求中，GET + HEAD 不发送)，Referer（更广泛应用）</strong></p></li><li><p>token：</p><p>Browser      →1. 请求页面 →            Server</p><p>​                    ← 2.页面 + token ←</p><p>​                     →3. 请求API+token →</p><p>​                     ← 4.验证 token + 数据←</p></li></ul><p>注意：</p><ol><li>要进行用户绑定</li><li>要设置过期时间</li></ol><blockquote><p>因为 请求来自合法页面，服务器接收过页面请求，服务器就可以表示</p></blockquote></li></ul><h4 id="csrf-—-iframe-攻击">CSRF — iframe 攻击<a title="#csrf-—-iframe-攻击" href="#csrf-—-iframe-攻击"></a></h4><p>因为这样就是同源的发送请求了，没办法用 Origin 限制了，</p><ul><li><p>方法</p><p>使用 响应头部：<code>X-Frame-Options:deny/sameorigin</code></p><p>deny：不能访问</p><p>sameorigin：同源可以访问</p></li></ul><h4 id="csrf-anti-pattern">CSRF anti-pattern<a title="#csrf-anti-pattern" href="#csrf-anti-pattern"></a></h4><p>GET != GET + POST、明确 get、post 请求各自的功能</p><blockquote><p>如果写成下面的样子，攻击者很容易一石二鸟</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将更新 获取 逻辑放到同一个 get</span></span><br><span class="line">public <span class="keyword">async</span> <span class="title function_">getAndUpdate</span>(<span class="params">ctx</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; update, id &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    <span class="keyword">if</span>(update)&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">get</span>(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免用户信息被携带：samesite-cookie">避免用户信息被携带：SameSite Cookie<a title="#避免用户信息被携带：samesite-cookie" href="#避免用户信息被携带：samesite-cookie"></a></h4><p>从根源上解决了 csrf，csrf 是利用用户权限及 cookie，去伪造自己是该用户来进行恶意操作，如果攻击者无法获取到 用户的 cookie 那就没用办法进行伪造了。</p><p>sameSite 限制了 <strong>cookie domain、页面域名；</strong></p><blockquote><p>如果是有 cookie 依赖第三方服务的，可以设置</p><p><code>Set-Cookie: SameSite=None; Secure;</code></p></blockquote><p>SameSite 与 CORS 对比：</p><p>SameSite：Cookie 发送、domain 与 页面域名</p><p>CORS：资源读写 http请求、资源域名 与 页面域名、白名单</p><h4 id="正确防御-csrf-—-中间件">正确防御 CSRF — 中间件<a title="#正确防御-csrf-—-中间件" href="#正确防御-csrf-—-中间件"></a></h4><h2 id="injection">Injection<a title="#injection" href="#injection"></a></h2><h4 id="sql-1">SQL<a title="#sql-1" href="#sql-1"></a></h4><p>找到项目中查询 SQL 的地方，使用 prepared statement</p><h4 id="beyond-sql">beyond SQL<a title="#beyond-sql" href="#beyond-sql"></a></h4><ol><li><p>最小权限原则</p><p>不允许访问 sudo || root</p></li><li><p>建立允许名单 + 过滤</p><p>不允许进行 rm 这种系统操作</p></li><li><p>对 URL 类型参数进行协议、域名、ip等限制</p><p>禁止访问内网</p></li></ol><h2 id="dos">DoS<a title="#dos" href="#dos"></a></h2><h4 id="regex-dos">Regex DoS<a title="#regex-dos" href="#regex-dos"></a></h4><ol><li>进行 code review，避免出现 贪婪模式的 正则</li><li>代码扫描 + 正则性能测试</li><li>禁止使用用户提供的正则</li></ol><h4 id="logical-dos-1">Logical Dos<a title="#logical-dos-1" href="#logical-dos-1"></a></h4><ol><li>不是非黑即白：有些情况只有再在请求量大到一定之后才会体现</li><li>分析代码中的性能瓶颈</li><li>限流</li></ol><h4 id="ddos">DDos<a title="#ddos" href="#ddos"></a></h4><ol><li>流量治理<ul><li>负载均衡 – 过滤</li><li>api 网关 – 过滤</li><li>cdn – 抗量</li></ul></li><li>快速自动扩容 – 抗量</li><li>非核心服务降级 – 抗量</li></ol><h2 id="传输层-—-防御中间人">传输层 — 防御中间人<a title="#传输层-—-防御中间人" href="#传输层-—-防御中间人"></a></h2><p>使用 https = http + TLS</p><p>https的特性：</p><ul><li>可靠性：加密，非明文传输</li><li>完整性：MAC 验证，禁止篡改   — 通过 验证 hash</li><li>不可抵赖性：数字签名，进行身份验证  — 密码学</li></ul><h4 id="hsts---http-strict-transport-security">HSTS - HTTP Strict-Transport-Security<a title="#hsts---http-strict-transport-security" href="#hsts---http-strict-transport-security"></a></h4><p>将 HTTP 升级到 HTTPS</p><p>设置请求头：<code>Strict-Transport-Security：max-age=3600</code></p><h4 id="sri-—-subresource-integrity">SRI — Subresource Integrity<a title="#sri-—-subresource-integrity" href="#sri-—-subresource-integrity"></a></h4><p>防止 CDN 静态资源被篡改：对比 hash</p><h4 id="feature-/-permission-policy">Feature / Permission Policy<a title="#feature-/-permission-policy" href="#feature-/-permission-policy"></a></h4><p>限制一个页面下，可以使用哪些功能</p><p>iframe 也可以通过 allow=“xxx” 设置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;两个角度看安全：hacker 攻击、开发者 防御&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;攻击者&quot;&gt;攻击者&lt;a title=&quot;#攻击者&quot; href=&quot;#攻击者&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;xss-—-cross-site-sc</summary>
      
    
    
    
    <category term="learningNotes" scheme="https://shylees.github.io/categories/learningNotes/"/>
    
    
    <category term="青训营" scheme="https://shylees.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
    <category term="前端安全" scheme="https://shylees.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>构建 webpack 知识体系 - 字节青训营</title>
    <link href="https://shylees.github.io/learningNotes/ByteDance/12%20%E6%9D%8E%E6%96%87%E6%9D%B0%20webpack"/>
    <id>https://shylees.github.io/learningNotes/ByteDance/12%20%E6%9D%8E%E6%96%87%E6%9D%B0%20webpack</id>
    <published>2022-01-24T16:00:00.000Z</published>
    <updated>2022-01-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建-webpack-知识体系">构建 webpack 知识体系<a title="#构建-webpack-知识体系" href="#构建-webpack-知识体系"></a></h1><p>知识体系：<a href="https://gitmind.cn/app/doc/fac1c196e29b8f9052239f16cff7d4c7">https://gitmind.cn/app/doc/fac1c196e29b8f9052239f16cff7d4c7</a></p><h2 id="1.-什么是webpack">1. 什么是webpack<a title="#1.-什么是webpack" href="#1.-什么是webpack"></a></h2><p>本质上是一种前端资源编译、打包工具</p><ul><li>多份资源文件打包成一个Bundle</li><li>支持 Babel、Eslint、TS、CoffeScript、Less、Sass</li><li>支持模块化处理 css、图片等资源文件</li><li>支持 HMR + 开发服务器</li><li>支持持续监听、持续构建</li><li>支持代码分离</li><li>支持 Tree-shaking</li><li>支持 Sourcemap</li><li>…</li></ul><h2 id="2.-使用-webpack">2. 使用 webpack<a title="#2.-使用-webpack" href="#2.-使用-webpack"></a></h2><h3 id="1.-示例">1. 示例<a title="#1.-示例" href="#1.-示例"></a></h3><ol><li><p>安装</p><p><code>npm i -D webpack webpack-cli</code></p></li><li><p>编辑配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&quot;[name].js&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">join</span>(__dirname,<span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[&#123;</span><br><span class="line">            <span class="attr">test</span>:<span class="regexp">/\.less$/i</span>,</span><br><span class="line">            <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行编译命令</p><p><code>npx webpack</code></p></li></ol><h3 id="2.-核心流程-—-极简化版">2. 核心流程 — 极简化版<a title="#2.-核心流程-—-极简化版" href="#2.-核心流程-—-极简化版"></a></h3><ol><li>入口处理 ： 从entry文件开始启动编译流程</li><li>依赖解析 ：根据require、import等找到依赖资源</li><li>资源解析 ：根据module配置，调用资源转移器，将css等非标准js资源转译为 js 内容</li><li>资源合并打包 ：将转译后的资源内容合并打包为可直接在浏览器运行的js</li></ol><h3 id="3.-配置项概览">3. 配置项概览<a title="#3.-配置项概览" href="#3.-配置项概览"></a></h3><p>使用 webpack 的方法：<strong>基本围绕 “配置”展开，可分为</strong></p><ul><li>流程类：作用于流程中某个 or 若干个环节，直接影响打包效果的配置项<ul><li>输入：entry、context</li><li>模块解析：resolve、externals</li><li>模块转译：module</li><li>后处理：optimization、mode、target</li></ul></li><li>工具类：主流程之外，提供更多工程化能力的配置项<ul><li>开发效率类：watch、devtool、devServer</li><li>性能优化类：cache、performance</li><li>日志类：stats、infrastructureLogging</li><li>其他：amd、bail</li></ul></li></ul><p>配置项的使用频率：</p><ul><li>entry/output</li><li>module/plugins</li><li>mode</li><li>watch/devServer/devtools</li></ul><h4 id="3.1-处理-css-–-style-loader,css-loader">3.1 处理 css – style-loader,css-loader<a title="#3.1-处理-css-–-style-loader,css-loader" href="#3.1-处理-css-–-style-loader,css-loader"></a></h4><ol><li>安装loader</li><li>编辑配置项</li></ol><blockquote><p>loader 有什么作用？为什么要用到 css-loader、style-loader？</p><p>A: 因为 webpack 只认识 js，为了处理非标准js资源，设计出的资源翻译模块 — loader，将资源翻译为标准 js</p><p>与在 html 文件中维护 css 相比，这种方式会有什么优劣？</p><p>如何在webpack接入less、sass、stylus？</p></blockquote><h4 id="3.2-处理-js-–-接入-babel">3.2 处理 js – 接入 Babel<a title="#3.2-处理-js-–-接入-babel" href="#3.2-处理-js-–-接入-babel"></a></h4><ol><li>安装依赖 <code>npm i -D @babel/core @babel/preset-env babel-loader</code></li><li>声明 output</li><li>执行 npx webpack</li></ol><blockquote><p>Babel 有什么功能</p><p>Babel 与 webpack 分别解决了什么问题</p></blockquote><h4 id="3.3-生成-html">3.3 生成 HTML<a title="#3.3-生成-html" href="#3.3-生成-html"></a></h4><ol><li>安装依赖 <code>npm i -D html-webpack-plugin</code></li><li>声明产物出口 output</li><li>使用插件 <code>plugins:[new HtmlWebpackPlugin]</code></li><li>执行 <code>npx webpack</code></li></ol><blockquote><p>相比于手工维护的 HTML 内容，这种自动生成的方式有什么优缺点？</p></blockquote><h3 id="4.-工具线">4. 工具线<a title="#4.-工具线" href="#4.-工具线"></a></h3><h4 id="4.1-hmr-浏览器热替换">4.1 HMR 浏览器热替换<a title="#4.1-hmr-浏览器热替换" href="#4.1-hmr-浏览器热替换"></a></h4><ol><li>更改配置项 devServer: { hot: true, open: true } ,watch: true // 持续监听，生成新的</li><li>执行 npx webpack server</li></ol><h4 id="4.2-tree-shaking-树摇">4.2 Tree-Shaking 树摇<a title="#4.2-tree-shaking-树摇" href="#4.2-tree-shaking-树摇"></a></h4><p>开启树摇</p><p>更改配置项：</p><ul><li><p>mode: ”production“,</p></li><li><p>optimization: { usedExports: true }</p></li></ul><blockquote><p>对工具库如Lodash有奇效</p><p>require 不能进行 tree-shaking</p></blockquote><h4 id="4.3-其他工具">4.3 其他工具<a title="#4.3-其他工具" href="#4.3-其他工具"></a></h4><ul><li>缓存 webpack5后的缓存效果才比较好</li><li>Sourcemap</li><li>性能监控</li><li>日志</li><li>代码压缩</li><li>分包</li><li>…</li></ul><blockquote><p>还有哪些可被划分为”流程类“？</p><p>工具类配置具体有什么作用，包括 devtool/cache/stat</p></blockquote><h2 id="3.-理解-loader">3. 理解 Loader<a title="#3.-理解-loader" href="#3.-理解-loader"></a></h2><p><strong>为了处理非标准 js 资源，设计出资源翻译模块 — Loader，用于将资源翻译为标准  JS</strong></p><h3 id="3.1-使用：">3.1 使用：<a title="#3.1-使用：" href="#3.1-使用："></a></h3><ol><li>安装 Loader</li><li>添加 module 处理 需要翻译的文件</li></ol><h3 id="3.2-认识loader">3.2 认识Loader<a title="#3.2-认识loader" href="#3.2-认识loader"></a></h3><h4 id="链式调用">链式调用<a title="#链式调用" href="#链式调用"></a></h4><p>前面的输出 == 后面的输入，每个 loader 比较内聚，</p><p>以 处理 less 文件为例：</p><ul><li>less-loader：实现 less 到 css 的转换</li><li>css-loader：将 css 包装成类似于 module.exports = “${css}” 的内容，包装后的内容符合js 语法</li><li>style-loader：将 css 模块包进 require 语句，并在运行时调用 injectStyle 等函数将内容注入到页面的style标签</li></ul><p>debug工具： ndb <code>ndb npx webpack</code></p><p>特点：</p><ul><li>链式调用</li><li>支持异步执行</li><li>分 normal、pitch 两种模式</li></ul><h4 id="如何编写">如何编写<a title="#如何编写" href="#如何编写"></a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source,sourceMap,data?</span>)&#123;</span><br><span class="line">    <span class="comment">// source 为 文件输入</span></span><br><span class="line">    <span class="comment">// 可能是文件内容，也可以是上一个 loader 处理结果</span></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eslint-loader/index.js</span></span><br><span class="line"><span class="keyword">import</span> getOptions <span class="keyword">from</span> <span class="string">&#x27;./getOptions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Linter</span> <span class="keyword">from</span> <span class="string">&#x27;./Linter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cacheLoader <span class="keyword">from</span> <span class="string">&#x27;./cacheLoader&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> defalut <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content, map</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">const</span> linter = <span class="keyword">new</span> <span class="title class_">Linter</span>(<span class="variable language_">this</span>, options);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cacheable</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(options.<span class="property">cache</span>)&#123;</span><br><span class="line">        <span class="title function_">cacheLoader</span>(linter, content, map);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    linter.<span class="title function_">printOutput</span>(linter.<span class="title function_">lint</span>(content));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：Webpack 原理系列七：如何编写loader</p><h4 id="常见loader">常见loader<a title="#常见loader" href="#常见loader"></a></h4><p>理解</p><ul><li>js：babel、eslint、ts、buble、vue、angular2-template   - loader</li><li>css：css、style、less、sass、stylus、postcss - loader</li><li>html：html、pug、pisthtml - loader</li><li>assets：file、val、url、json5 - loader</li></ul><blockquote><p>loader 输入是什么？要求输出的是什么？</p><p>loader 的链式调用是什么意思？如何串联多个 loader？</p><p>loader 中如何处理异步场景？</p></blockquote><h2 id="4.-理解插件">4. 理解插件<a title="#4.-理解插件" href="#4.-理解插件"></a></h2><h3 id="4.1-插件是什么，为什么这么设计？">4.1 插件是什么，为什么这么设计？<a title="#4.1-插件是什么，为什么这么设计？" href="#4.1-插件是什么，为什么这么设计？"></a></h3><p>插件架构精髓：对扩展开放、对修改封闭</p><h3 id="4.2-理解插件">4.2 理解插件<a title="#4.2-理解插件" href="#4.2-理解插件"></a></h3><p>插件围绕钩子展开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomePlugin</span>&#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>)&#123;</span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;SomePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>钩子的核心信息：</p><ol><li>时机：编译过程的特定节点，Webpack 会以钩子的形式通知插件此刻正在发生什么事请</li><li>上下文：通过 tapable 提供的回调机制，以参数方式传递上下文信息；</li><li>交互：在上下文参数对象中附带了很多存在 side effect 的交互接口，插件可以通过这些接口改变</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EntryPlugin</span>&#123;</span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>)&#123;</span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>( <span class="comment">// 时机 compiler.hooks.compilation</span></span><br><span class="line">            <span class="string">&#x27;EntryPlugin&#x27;</span>,</span><br><span class="line">             <span class="function">(<span class="params">compilation,&#123; normalModuleFactory &#125;</span>) =&gt;</span> &#123;  <span class="comment">// 参数 compilation</span></span><br><span class="line">                 compilation.<span class="property">dependencyfactories</span>.<span class="title function_">set</span>(  <span class="comment">// 交互 dependencyfactories.set</span></span><br><span class="line">                 <span class="title class_">EntryDenpendency</span>,</span><br><span class="line">                    noemalModuleFactory</span><br><span class="line">                 );</span><br><span class="line">             &#125;);</span><br><span class="line">        </span><br><span class="line">        compiler.<span class="property">hooks</span>.<span class="property">make</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;EntryPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;entry,options, context &#125; = <span class="variable language_">this</span>;</span><br><span class="line">            <span class="keyword">const</span> dep = <span class="title class_">EntryPlugin</span>.<span class="title function_">createDependency</span>(entry, options);</span><br><span class="line">            compilation.<span class="title function_">addEntry</span>(context, dep, options, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">callback</span>(err);</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>loader 与插件有什么区同点？</p><p>”钩子“有什么作用？如何监听钩子函数？</p></blockquote><h2 id="5.-学习方法">5. 学习方法<a title="#5.-学习方法" href="#5.-学习方法"></a></h2><ol><li>入门应用<ul><li>理解打包流程</li><li>熟练掌握常用配置项、loader、插件的使用方法、能够灵活搭建集成 Vue、React、Babel、Eslint、Less、Sass、图片处理等工具的webpack环境</li><li>掌握常见脚手架工具，例如 Vue-cli、create-react-app、@angular/cli</li></ul></li><li>进阶<ul><li>理解Loader、Plugin机制，能够自行开发 Webpack 组件</li><li>理解常见性能优化手段，并能用于解决实际问题</li><li>理解前端工程化概念与生态现状</li></ul></li><li>大师级<ul><li>阅读源码，理解 编译、打包原理，能参与共建</li></ul></li></ol><h2 id="q&amp;a">Q&amp;A<a title="#q&amp;a" href="#q&amp;a"></a></h2><h5 id="面试掌握程度？">面试掌握程度？<a title="#面试掌握程度？" href="#面试掌握程度？"></a></h5><ul><li>loader 有什么作用，怎么写 loader、常见的 loader有什么</li><li>怎么写一个 插件</li><li>bundle、chunk、module 是什么含义？</li></ul><h5 id="require-与-import-导入的区别？">require 与 import 导入的区别？<a title="#require-与-import-导入的区别？" href="#require-与-import-导入的区别？"></a></h5><ul><li>动态/静态代码</li></ul><h5 id="webpack-与-vite-？">webpack 与 vite ？<a title="#webpack-与-vite-？" href="#webpack-与-vite-？"></a></h5><ul><li>vite：速度快 ，无 bundle，对开发性友好</li><li>webpack：生态成熟，</li></ul><h5 id="loader-与-plugin-区别？">loader 与 plugin 区别？<a title="#loader-与-plugin-区别？" href="#loader-与-plugin-区别？"></a></h5><ul><li>loader：内容翻译为js</li><li>plugin：没有明确输入输出，作用于整个生命周期，在任意时间修改任意webpack组件</li></ul><h5 id="webpack-与-rollup">webpack 与 rollup<a title="#webpack-与-rollup" href="#webpack-与-rollup"></a></h5><ul><li>webpack 更重，应对浏览器</li><li>rollup 用来构建npm包，扩展性弱，应对库的场景</li></ul><h5 id="webpack-优化">webpack 优化<a title="#webpack-优化" href="#webpack-优化"></a></h5><h5 id="npx-与-npm">npx 与 npm<a title="#npx-与-npm" href="#npx-与-npm"></a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构建-webpack-知识体系&quot;&gt;构建 webpack 知识体系&lt;a title=&quot;#构建-webpack-知识体系&quot; href=&quot;#构建-webpack-知识体系&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;知识体系：&lt;a href=&quot;https://gitmind.cn/ap</summary>
      
    
    
    
    <category term="learningNotes" scheme="https://shylees.github.io/categories/learningNotes/"/>
    
    
    <category term="青训营" scheme="https://shylees.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
    <category term="webpack" scheme="https://shylees.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端必须知道的开发调试知识 - 字节青训营</title>
    <link href="https://shylees.github.io/learningNotes/ByteDance/05%20%E7%A7%83%E5%A4%B4%E6%8A%AB%E9%A3%8E%E4%BE%A0%20%E5%89%8D%E7%AB%AF%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86"/>
    <id>https://shylees.github.io/learningNotes/ByteDance/05%20%E7%A7%83%E5%A4%B4%E6%8A%AB%E9%A3%8E%E4%BE%A0%20%E5%89%8D%E7%AB%AF%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%9F%A5%E8%AF%86</id>
    <published>2022-01-23T16:00:00.000Z</published>
    <updated>2022-01-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1.-bug-与-debug">1. Bug 与 Debug<a title="#1.-bug-与-debug" href="#1.-bug-与-debug"></a></h2><h3 id="1.1-bug来源">1.1 bug来源<a title="#1.1-bug来源" href="#1.1-bug来源"></a></h3><h3 id="1.2-bug-特点">1.2 bug 特点<a title="#1.2-bug-特点" href="#1.2-bug-特点"></a></h3><ul><li>多平台：浏览器、hybrid、nodejs、小程序、桌面应用</li><li>多环境：本地开发环境、线上环境</li><li>多工具：chrome devtools、charles、spy-debugger、whistie、vconsole</li><li>多技巧：console、breakpoint、sourceMap、代理</li></ul><h2 id="2.-chrome-devtool">2. Chrome devTool<a title="#2.-chrome-devtool" href="#2.-chrome-devtool"></a></h2><h3 id="2.1-elements-–-修改元素和样式">2.1 Elements – 修改元素和样式<a title="#2.1-elements-–-修改元素和样式" href="#2.1-elements-–-修改元素和样式"></a></h3><blockquote><p>.cls 添加删除类名</p><p>右键元素 → fouce state → ± 伪类 / ：hov<br>对结点进行截图：元素右键 → capture node screenshot</p></blockquote><h3 id="2.2-console-–-日志页面">2.2 Console – 日志页面<a title="#2.2-console-–-日志页面" href="#2.2-console-–-日志页面"></a></h3><blockquote><p>对 log 的值 进行 修改样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%s %o,%c%s&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;hello&#x27;</span>,          <span class="comment">// %s字符串 </span></span><br><span class="line">         &#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;,     <span class="comment">// o 对象</span></span><br><span class="line">         <span class="string">&#x27;color:red&#x27;</span>,      <span class="comment">// c 样式？</span></span><br><span class="line">         <span class="string">&#x27;welcome&#x27;</span>)        <span class="comment">// </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>console.table 具象化 JSON 数据 转换为 table 格式</p><p>console.dir 树形结构</p></blockquote><h3 id="2.3-sources">2.3 sources<a title="#2.3-sources" href="#2.3-sources"></a></h3><ol><li><p>组成</p><ul><li><p>页面资源文件目录树</p></li><li><p>代码预览区</p></li><li><p>debug 工具栏</p><blockquote><p>暂停 继续 断点间</p><p>单步跳过</p><p>进入函数</p><p>跳出函数</p><p>单步执行</p><p>激活 / 关闭 所有断电</p><p>代码执行异常处自动</p></blockquote></li><li><p>断点调试器</p><blockquote><p>xhr/fetch ：当有请求发生时触发断点</p><p>dom ：右键 break on，增删结点触发</p><p>scope：作用域 closure 闭包</p><p>call stack：调用栈</p></blockquote></li></ul></li><li><p>查看暂停下 变量的值：</p><ul><li>breakPoint：debugger; 区域4 的 breakpoints 可以勾选 或 取消 可以打断点；直接鼠标移动可以查看值</li><li>区域4 watch：点击 + 可以添加 变量 查看值</li></ul></li><li><p>压缩代码如何调试：</p><ul><li><p>用webpack压缩，在webpack.config.js 中 devtools：‘source-map’，</p><blockquote><p>多导出一个 bundle.js.map 把压缩的代码和源码进行映射</p><ul><li>mappings 字段存储了源文件和source map 映射<ul><li>英文，表源码及压缩代码的位置关联</li><li>逗号，分割一行的内容</li><li>分号，换行</li></ul></li></ul><p>映射见：<a href="http://murzwin.com/base64vlqhtml">murzwin.com/base64vlqhtml</a></p><p>source map 标准：<a href="http://docs.google.com/document/d/1URGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit">docs.google.com/document/d/1URGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit</a></p></blockquote></li></ul></li></ol><h3 id="2.4-performance-—-性能">2.4 performance — 性能<a title="#2.4-performance-—-性能" href="#2.4-performance-—-性能"></a></h3><ol><li><p>组成 — 开始录制页面  stop</p><ul><li><p>控制面板</p></li><li><p>概览面板</p><p>FPS：每秒帧数</p><p>CPU：处理各个任务花费的时间</p><p>NET：各个请求花费的时间</p></li><li><p>线程面板</p><p>Frames：帧线程</p><p>Main：主线程、负责执行js，解析html css 完成绘制</p><p>Raster：raster 线程，负责完成某个layer 或 某些块 tile 的绘制</p></li><li><p>统计面板</p></li></ul></li></ol><h3 id="2.5-network-—-请求相关">2.5 Network — 请求相关<a title="#2.5-network-—-请求相关" href="#2.5-network-—-请求相关"></a></h3><p>可以自定义网速</p><img src="https://i.bmp.ovh/imgs/2022/01/38b5ba1f5f907e8d.png"><h3 id="2.6-application-—-本地存储相关">2.6 application — 本地存储相关<a title="#2.6-application-—-本地存储相关" href="#2.6-application-—-本地存储相关"></a></h3><h3 id="2.7-storage中点击-clean-site-data-清除缓存">2.7 storage中点击 clean site data 清除缓存<a title="#2.7-storage中点击-clean-site-data-清除缓存" href="#2.7-storage中点击-clean-site-data-清除缓存"></a></h3><h2 id="3.-移动端-h5-调试">3. 移动端 h5 调试<a title="#3.-移动端-h5-调试" href="#3.-移动端-h5-调试"></a></h2><ol><li><p>真机调试：推荐扫码</p></li><li><p>代理调试：</p></li><li><p>常用工具：</p><p>charles：适合查看、控制网络请求，分析数据</p><p>fiddler：与上面类似，适合windows 平台</p><p>spy-debugger：远程调试手机页面、抓包</p><p>whistie：基于node实现的跨平台web调试代理工具</p></li></ol><h2 id="4.-常用开发技巧：">4. 常用开发技巧：<a title="#4.-常用开发技巧：" href="#4.-常用开发技巧："></a></h2><ul><li><p>source：oversides，勾选，在修改后刷新会保留，右边竖三点，more tools -&gt; change 面板会显示 修改的内容</p></li><li><p>跨域问题：报 cors error 跨域错误</p><p>使用代理工具</p><p>代理：解决了同源策略的哪一项，为什么能解决跨域</p><blockquote><p>同源限制只显示了浏览器</p></blockquote><img src="https://i.bmp.ovh/imgs/2022/01/20d4963af61cfd07.png"></li><li><p>启用本地source map：</p><p>可以把 source map 代理到本地</p></li><li><p>前端埋点</p></li><li><p>小黄鸭</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1.-bug-与-debug&quot;&gt;1. Bug 与 Debug&lt;a title=&quot;#1.-bug-与-debug&quot; href=&quot;#1.-bug-与-debug&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;1.1-bug来源&quot;&gt;1.1 bug来源&lt;a title=&quot;#1.1</summary>
      
    
    
    
    <category term="learningNotes" scheme="https://shylees.github.io/categories/learningNotes/"/>
    
    
    <category term="js" scheme="https://shylees.github.io/tags/js/"/>
    
    <category term="青训营" scheme="https://shylees.github.io/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    
  </entry>
  
</feed>
