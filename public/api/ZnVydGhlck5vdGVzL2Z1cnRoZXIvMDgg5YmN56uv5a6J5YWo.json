{"title":"关于网络攻击那些事儿~","date":"2021-11-13T16:00:00.000Z","date_formatted":{"ll":"Nov 14, 2021","L":"11/14/2021","MM-DD":"11-14"},"link":"furtherNotes/further/08 前端安全","tags":["前端安全"],"categories":["furtherNotes"],"updated":"2021-12-03T16:00:00.000Z","content":"<blockquote>\n<p>参考链接：</p>\n<p><a href=\"https://blog.poetries.top/browser-working-principle/guide/part6/lesson33.html\" target=\"_blank\">xss</a> <a href=\"https://juejin.cn/post/6844903685122703367\" target=\"_blank\">xss</a></p>\n<p><a href=\"https://blog.poetries.top/browser-working-principle/guide/part6/lesson34.htm\" target=\"_blank\">csrf</a>  <a href=\"https://juejin.cn/post/6844903465634758669\" target=\"_blank\">csrf</a>  <a href=\"https://juejin.cn/post/6844903689702866952\" target=\"_blank\">csrf</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/112894574\" target=\"_blank\">ddos</a></p>\n<p><a href=\"https://juejin.cn/post/6844903757919027208\" target=\"_blank\">cdn</a></p>\n<p><a href=\"https://www.cnblogs.com/lovesong/p/5248483.html\" target=\"_blank\">点击劫持</a>  <a href=\"https://www.jianshu.com/p/251704d8ff18\" target=\"_blank\">点击劫持</a>  <a href=\"https://zhuanlan.zhihu.com/p/53197562\" target=\"_blank\">点击劫持</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/25537440\" target=\"_blank\">HTST</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/83865185\" target=\"_blank\">前端安全</a></p>\n</blockquote>\n<h2 id=\"前端安全\">前端安全<a title=\"#前端安全\" href=\"#前端安全\"></a></h2>\n<blockquote>\n<ol>\n<li>XSS</li>\n<li>CSRF</li>\n<li>DDoS</li>\n<li>CDN 劫持</li>\n<li>iframe</li>\n<li>opener</li>\n<li>ClickJacking 点击劫持</li>\n<li>HSTS（HTTP严格传输安全）</li>\n<li>泛洪</li>\n</ol>\n</blockquote>\n<h3 id=\"1.-xss攻击-—-跨站脚本攻击\">1. XSS攻击 — 跨站脚本攻击<a title=\"#1.-xss攻击-—-跨站脚本攻击\" href=\"#1.-xss攻击-—-跨站脚本攻击\"></a></h3>\n<h4 id=\"1.1-简介\">1.1 简介<a title=\"#1.1-简介\" href=\"#1.1-简介\"></a></h4>\n<p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>\n<p>本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行</p>\n<h4 id=\"1.2-攻击的危害\">1.2 攻击的危害<a title=\"#1.2-攻击的危害\" href=\"#1.2-攻击的危害\"></a></h4>\n<ul>\n<li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>\n<li>可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>\n<li>可以通过修改 DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>\n<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li>\n</ul>\n<h4 id=\"1.3-注入方式\">1.3 注入方式<a title=\"#1.3-注入方式\" href=\"#1.3-注入方式\"></a></h4>\n<ul>\n<li>在 html 中内嵌的文本中，恶意内容以 script 标签形式注入；</li>\n<li>在内联的 javascript 中，拼接的数据突破了原本的限制（字符串、变量、方法名等）</li>\n<li>在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签；</li>\n<li>在标签的href、src等属性中，包含 javascript: 等可执行代码；</li>\n<li>在 onload、onerror、onclick 等事件中，注入不受控制代码；</li>\n<li>在 style 属性和标签中，包含类似 <code>background-image:url(‘javascript : ...’);</code>的代码</li>\n<li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的css表达式代码</li>\n</ul>\n<p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 html 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造成恶意的代码指令，进而利用恶意代码危害数据安全。</p>\n<h4 id=\"1.3-分类\">1.3 分类<a title=\"#1.3-分类\" href=\"#1.3-分类\"></a></h4>\n<h5 id=\"1.3.1存储型-xss-攻击\">1.3.1<strong>存储型 XSS 攻击</strong><a title=\"#1.3.1存储型-xss-攻击\" href=\"#1.3.1存储型-xss-攻击\"></a></h5>\n<p>在表单输入一段 脚本，然后这段脚本会存在数据库里，每当其他用户从数据库拿到数据渲染到页面上时，会有这一段脚本存在，当用户触发后，自己的数据就会被发送到非法服务器。</p>\n<blockquote>\n<ul>\n<li>攻击者将恶意代码<strong>提交到目标网站的数据库</strong>中。</li>\n<li>用户<strong>打开目标网站</strong>时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ul>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n</blockquote>\n<h5 id=\"1.3.2-反射型-xss-攻击\">1.3.2 <strong>反射型 XSS 攻击</strong><a title=\"#1.3.2-反射型-xss-攻击\" href=\"#1.3.2-反射型-xss-攻击\"></a></h5>\n<p>url 里面 放 脚本，发送请求，该请求的 查询字符串会被作为 dom 节点的 内容 放到html里执行，黑客就可以利用该脚本做一些恶意操作。</p>\n<blockquote>\n<ol>\n<li>攻击者<strong>构造出特殊的 URL</strong>，其中包含恶意代码。</li>\n<li>用户<strong>打开带有恶意代码的 URL 时</strong>，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>反射型 XSS 跟存储型 XSS 的<strong>区别</strong>是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>\n<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>\n<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>\n</blockquote>\n<h5 id=\"1.3.3-基于-dom-的-xss-攻击\">1.3.3 <strong>基于 DOM 的 XSS 攻击</strong><a title=\"#1.3.3-基于-dom-的-xss-攻击\" href=\"#1.3.3-基于-dom-的-xss-攻击\"></a></h5>\n<p>跟 web 服务器没有关系</p>\n<blockquote>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL。</li>\n<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>\n<p>具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据</p>\n</blockquote>\n<h4 id=\"1.4-阻止预防\">1.4 阻止预防<a title=\"#1.4-阻止预防\" href=\"#1.4-阻止预防\"></a></h4>\n<h5 id=\"1.4.1-总结上述攻击特点\">1.4.1 总结上述攻击特点<a title=\"#1.4.1-总结上述攻击特点\" href=\"#1.4.1-总结上述攻击特点\"></a></h5>\n<p><a href=\"https://juejin.cn/post/6844903685122703367#heading-8\">https://juejin.cn/post/6844903685122703367#heading-8</a></p>\n<p>通过前面的介绍可以得知，XSS 攻击有两大要素：</p>\n<ol>\n<li>攻击者提交恶意代码。</li>\n<li>浏览器执行恶意代码。</li>\n</ol>\n<p>针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？</p>\n<p><strong>输入过滤:</strong></p>\n<ul>\n<li><strong>前端过滤输入，然后提交到后端</strong>？<strong>不可行</strong>，一旦攻击者绕过前端过滤，直接构造请求，就可以提交尔恶意代码了</li>\n<li><strong>后端写入数据库前，对输入进行过滤，然后将安全内容返回给前端？不可行</strong>在提交阶段，不确定内容要输出到哪里：可能同时提供给 前端和客户端，if 转码 客户端显示的内容是转码后的内容；在前端中不同的位置所需的编码也不一样。</li>\n</ul>\n<blockquote>\n<p>输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。</p>\n<p>对于<strong>明确的输入类型</strong>，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的</p>\n</blockquote>\n<p>那就只能：</p>\n<p><strong>防止浏览器执行恶意代码</strong></p>\n<ul>\n<li>防止 html 中出现注入</li>\n<li>防止 JavaScript 执行时，执行恶意代码</li>\n</ul>\n<h5 id=\"1.4.2-预防存储型和反射型xss攻击\">1.4.2 预防存储型和反射型xss攻击<a title=\"#1.4.2-预防存储型和反射型xss攻击\" href=\"#1.4.2-预防存储型和反射型xss攻击\"></a></h5>\n<p>存储型和反射型 XSS 都是在<strong>服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</strong></p>\n<p>预防这两种漏洞，有两种常见做法：</p>\n<ul>\n<li>\n<p>改成纯前端渲染，把代码和数据分隔开。</p>\n</li>\n<li>\n<p>对 HTML 做充分转义。</p>\n<blockquote>\n<p><strong>转义应该在输出 HTML 时进行，而不是在提交用户输入时</strong></p>\n</blockquote>\n</li>\n</ul>\n<h6 id=\"1.4.2.1-纯前端渲染\">1.4.2.1 纯前端渲染<a title=\"#1.4.2.1-纯前端渲染\" href=\"#1.4.2.1-纯前端渲染\"></a></h6>\n<p>纯前端渲染的过程：</p>\n<ol>\n<li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li>\n<li>然后浏览器执行 HTML 中的 JavaScript。</li>\n<li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li>\n</ol>\n<p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p>\n<p><strong>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞</strong>（例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。</p>\n<p>在很多<strong>内部、管理</strong>系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p>\n<h6 id=\"1.4.2.2-转义-html\">1.4.2.2 转义 html<a title=\"#1.4.2.2-转义-html\" href=\"#1.4.2.2-转义-html\"></a></h6>\n<p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。</p>\n<p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 <code>&amp; &lt; &gt; &quot; ' /</code> 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>XSS 安全漏洞</th>\n<th>简单转义是否有防护作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML 标签文字内容</td>\n<td>有</td>\n</tr>\n<tr>\n<td>HTML 属性值</td>\n<td>有</td>\n</tr>\n<tr>\n<td>CSS 内联样式</td>\n<td>无</td>\n</tr>\n<tr>\n<td>内联 JavaScript</td>\n<td>无</td>\n</tr>\n<tr>\n<td>内联 JSON</td>\n<td>无</td>\n</tr>\n<tr>\n<td>跳转链接</td>\n<td>无</td>\n</tr>\n</tbody>\n</table></div></div><p>所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。</p>\n<h6 id=\"1.4.2.3-总结\">1.4.2.3 总结<a title=\"#1.4.2.3-总结\" href=\"#1.4.2.3-总结\"></a></h6>\n<p>存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。</p>\n<p>而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此<strong>基于 DOM 的 XSS 攻击是属于前端的安全漏洞</strong>。</p>\n<p><strong>共同点</strong>：先往浏览器中注入恶意脚本，再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>\n<p>所以<strong>可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</strong></p>\n<h5 id=\"1.4.3-预防-dom-型\">1.4.3 预防 dom 型<a title=\"#1.4.3-预防-dom-型\" href=\"#1.4.3-预防-dom-型\"></a></h5>\n<p>DOM 型 XSS 攻击，实际上就是<strong>网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了</strong>。</p>\n<ul>\n<li>\n<p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应<strong>尽量使用 <code>.textContent</code>、<code>.setAttribute()</code></strong> 等。</p>\n</li>\n<li>\n<p>如果用 <strong>Vue/React 技术栈</strong>，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p>\n</li>\n<li>\n<p><strong>DOM 中的内联事件监听器</strong>，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p>\n</li>\n</ul>\n<h5 id=\"1.4.4-其他通用预防方案\">1.4.4 其他通用预防方案<a title=\"#1.4.4-其他通用预防方案\" href=\"#1.4.4-其他通用预防方案\"></a></h5>\n<ol>\n<li>\n<p><strong>利用 <a href=\"https://juejin.cn/post/6844903665224908807\" target=\"_blank\">CSP</a></strong></p>\n<p>CSP 的功能</p>\n<ul>\n<li>限制加载其他域下的资源文件</li>\n<li>禁止向第三方域提交数据，用户数据不会外泄</li>\n<li>禁止执行内联脚本和未授权脚本</li>\n<li>提供上报机制，帮助发现 XSS 攻击</li>\n</ul>\n</li>\n<li>\n<p><strong>使用 httpOnly</strong></p>\n<p>因为很多 XSS 攻击都是用来盗 cookie 的，可以通过使用 httpOnly 属性来爆出cookie</p>\n<p>通常服务器可以将 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的</p>\n<p><strong>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</strong></p>\n<blockquote>\n<p>打开谷歌的响应头</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set-<span class=\"attr\">cookie</span>: <span class=\"variable constant_\">NID</span>=<span class=\"number\">189</span>=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-<span class=\"title class_\">BzEYsNVa7TZmjAYTxYTOM9L</span>_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; </span><br><span class=\"line\">expires=<span class=\"title class_\">Sat</span>, <span class=\"number\">18</span>-<span class=\"title class_\">Apr</span>-<span class=\"number\">2020</span> <span class=\"number\">06</span>:<span class=\"number\">52</span>:<span class=\"number\">22</span> <span class=\"variable constant_\">GMT</span>; </span><br><span class=\"line\">path=/; </span><br><span class=\"line\">domain=.<span class=\"property\">google</span>.<span class=\"property\">com</span>; </span><br><span class=\"line\"><span class=\"title class_\">HttpOnly</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li>\n<p><strong>使用组件</strong></p>\n</li>\n</ol>\n<ul>\n<li>\n<p>前端防御组件 js-xss</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install xss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xss = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;xss&#x27;</span>)</span><br><span class=\"line\">$(<span class=\"string\">&#x27;btnSure&#x27;</span>).<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"title function_\">xss</span>($(<span class=\"string\">&#x27;.input&#x27;</span>).<span class=\"title function_\">val</span>())</span><br><span class=\"line\">    putout.<span class=\"title function_\">html</span>(result)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li>\n<p><strong>限制输入内容长度</strong></p>\n<p>不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>\n</li>\n</ol>\n<h5 id=\"1.4.5-减少攻击的产生\">1.4.5 减少攻击的产生<a title=\"#1.4.5-减少攻击的产生\" href=\"#1.4.5-减少攻击的产生\"></a></h5>\n<ul>\n<li>利用模板引擎：自带html转移功能</li>\n<li>避免内联事件</li>\n<li>避免拼接 html</li>\n<li>增加攻击难度，降低攻击后果</li>\n<li>主动检测和发现：用 xss 攻击字符串和自动扫描工具寻找潜在的 xss 漏洞</li>\n</ul>\n<h3 id=\"2.-csrf攻击-—-跨站请求伪造\">2. CSRF攻击 — 跨站请求伪造<a title=\"#2.-csrf攻击-—-跨站请求伪造\" href=\"#2.-csrf攻击-—-跨站请求伪造\"></a></h3>\n<p>CSRF（Cross-site request forgery）<strong>跨站请求伪造</strong>，是一种利用网站可信用户的权限去执行未授权的命令的一种恶意攻击。也称作 one-click attack 或者 session riding，其简写有时候也会使用 <strong>XSRF</strong>。</p>\n<ul>\n<li>CSRF ： 攻击者利用受害者的身份，以受害者的名义发送恶意请求。利用用户当前身份做一些未经过授权的事。</li>\n<li>XSS   ： 目的是获取用户的身份信息。攻击者窃取用户身份( session / cookie )。</li>\n</ul>\n<h4 id=\"2.1-csrf-的危害\">2.1 CSRF 的危害<a title=\"#2.1-csrf-的危害\" href=\"#2.1-csrf-的危害\"></a></h4>\n<p>CSRF可以盗用受害者的身份，完成受害者在web浏览器有权限进行的任何操作…</p>\n<ul>\n<li>以你的名义发送诈骗邮件，消息</li>\n<li>用你的账号购买商品</li>\n<li>用你的名义完成虚拟货币转账</li>\n<li>泄露个人隐私</li>\n</ul>\n<h4 id=\"2.2-产生-csrf-条件\">2.2 产生 CSRF 条件<a title=\"#2.2-产生-csrf-条件\" href=\"#2.2-产生-csrf-条件\"></a></h4>\n<ul>\n<li>目标站点一定要有 CSRF 漏洞；</li>\n<li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>\n<li>受害者有意或者无意的访问了攻击者发布的页面或者链接地址</li>\n</ul>\n<blockquote>\n<p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href=\"https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3Dbob2\" target=\"_blank\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。<br>\n黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href=\"https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3DMallory\" target=\"_blank\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a>。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。<br>\n这时，Mallory <strong>想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码</strong>： src=”<a href=\"https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3DMallory\" target=\"_blank\">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，**并且通过广告等诱使 Bob 来访问他的网站。**当 Bob 访问该网站时，<strong>上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器</strong>。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，**如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，**钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>\n</blockquote>\n<blockquote>\n<p>与 XSS 不同，CSRF 不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以对于 CSRF 我们主要的防护手段是提升服务器的安全性</p>\n</blockquote>\n<h4 id=\"2.3-产生的方式\">2.3 产生的方式<a title=\"#2.3-产生的方式\" href=\"#2.3-产生的方式\"></a></h4>\n<ol>\n<li>\n<p><strong>GET 请求</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://a.com/user/grant_super_user/121&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>攻击者 121 想将自己的身份添加为网站管理员，然后他发了一个网站会加载的图片到帖子上，其地址为上述 图片地址 ，请求到了后台数据</p>\n</blockquote>\n</li>\n<li>\n<p><strong>POST 请求</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">$(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    $(<span class=\"string\">&#x27;#CSRF_forCSRFm&#x27;</span>).<span class=\"title function_\">trigger</span>(<span class=\"string\">&#x27;submit&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;http://a.com/user/grant_super_user&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;CSRF_form&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;uid&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;121&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>伪造一个用户打开黑客站点时能自动提交的表单发送 POST 请求</p>\n</blockquote>\n</li>\n<li>\n<p><strong>诱导用户点击链接</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;...&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">herf</span>=<span class=\"string\">&quot;放黑客要操作的链接&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上</p>\n<p>一旦用户点击了这个链接，那么就会被黑客利用他的账户做一些没有被本人授权的事情</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>利用服务器的漏洞和用户的登录状态来实施攻击</strong></p>\n<h4 id=\"2.4-如何防止-csrf-攻击\">2.4 如何防止 CSRF 攻击<a title=\"#2.4-如何防止-csrf-攻击\" href=\"#2.4-如何防止-csrf-攻击\"></a></h4>\n<h5 id=\"2.4.1-利用-cookie-的-samesite-属性\">2.4.1 利用 Cookie 的 SameSite 属性<a title=\"#2.4.1-利用-cookie-的-samesite-属性\" href=\"#2.4.1-利用-cookie-的-samesite-属性\"></a></h5>\n<p>黑客会<strong>利用用户的登录状态</strong>来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据。</p>\n<p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，最好能实现<strong>从第三方站点发送请求时禁止 Cookie 的发送</strong>，因此在浏览器通过不同来源发送 http 请求时，有如下区别：</p>\n<ul>\n<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器</li>\n<li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送</li>\n</ul>\n<p>SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效降低 CSRF 攻击的风险。</p>\n<p>做法：在 HTTP 响应头，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p>\n<p>SameSite 的值：</p>\n<ul>\n<li><strong>Strict</strong>：浏览器会完全禁止第三方Cookie；</li>\n<li><strong>Lax</strong>：跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果使用 Post 方法，或通过 img、iframe 等标签加载的 URL，都不会携带 Cookie。</li>\n<li><strong>None</strong>：在任何请求的会发送 Cookie 数据</li>\n</ul>\n<h5 id=\"2.4.2-同源检测\">2.4.2 同源检测<a title=\"#2.4.2-同源检测\" href=\"#2.4.2-同源检测\"></a></h5>\n<p>服务器验证请求的来源站点。在 HTTP 协议中，每一个异步请求都会携带上两个 Header，用户标记来源域名：</p>\n<ul>\n<li>\n<p><strong>Origin</strong>：通过 XMLHttpRequest、Fecth 发起跨站请求或通过 Post 方法发送请求时，都会带上 Origin 属性</p>\n<blockquote>\n<p>只包含域名信息</p>\n<p>且再两种情况下不会存在： IE11同源策略、302重定向</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Referer</strong>：记录了该 HTTP 请求的来源地址</p>\n<blockquote>\n<p>if 从 极客时间的官网打开 InfoQ 的站点，那么 Referer 为 极客时间<strong>详细的 url</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>所以服务器的策略是优先判断 Origin，if 无 Origin，再根据实际情况判断是否使用 referer.</p>\n<h5 id=\"2.4.3-csrf-token\">2.4.3 CSRF Token<a title=\"#2.4.3-csrf-token\" href=\"#2.4.3-csrf-token\"></a></h5>\n<p>CSRF 中 攻击者无法直接窃取到用户的信息— cookie、header、网站内容等，仅仅是毛用 cookie 的信息。</p>\n<p>而 CSRF 成功的原因是，<strong>服务器误把攻击者发送的请求当成用户自己的请求</strong>。所以可以要求所有的<strong>用户请求都携带一个 CSRF 无法获取到的 Token</strong>。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开。</p>\n<ul>\n<li>浏览器向服务器发送请求时，服务器生成一个 CSRF Token，然后将该字符串植入到返回的页面中</li>\n<li>浏览器若要发起什么请求时，需要带上页面的 CSRF token，服务器会验证其是否合法。若时第三方站点发出的请求，就无法获取到 CSRF token，所以即使发出了请求，服务器也会拒绝。</li>\n</ul>\n<h3 id=\"3.-ddos-攻击-—-分布式拒绝服务攻击\">3. DDos 攻击 — 分布式拒绝服务攻击<a title=\"#3.-ddos-攻击-—-分布式拒绝服务攻击\" href=\"#3.-ddos-攻击-—-分布式拒绝服务攻击\"></a></h3>\n<h4 id=\"3.1-简介\">3.1 简介<a title=\"#3.1-简介\" href=\"#3.1-简介\"></a></h4>\n<p>其前身：<strong>DoS( Denial of Service )攻击，拒绝服务攻击</strong>，这种攻击行为使网站服务器充斥大量的要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷而停止提供正常的网络服务。</p>\n<p><strong>DDOS ( Distributed Denial of Service ) 分布式拒绝服务攻击</strong>，主要利用网络上现有的机器及系统的漏洞，攻占大量联网主机，使其成为攻击者的代理。当被控制的机器达到一定数量后，攻击者通过发送指令操纵这些攻击机同时向目标主机或网络发起 DoS 攻击，大量消耗其网络带宽和系统资源，导致该网络或系统瘫痪或停止提供正常的网络服务。</p>\n<h4 id=\"3.2-原理\">3.2 原理<a title=\"#3.2-原理\" href=\"#3.2-原理\"></a></h4>\n<p>一个比较完善的 DDoS 攻击体系分为：<strong>攻击者（ attacker / master ）、控制傀儡机（ demon / agent ）、受害者（ victim ）。</strong></p>\n<blockquote>\n<p>第2和第3部分，分别用做控制和实际发起攻击。第2部分的控制机只发布令而不参与实际的攻击，第3部分攻击傀儡机上发出DDoS的实际攻击包。</p>\n<p>对第2和第3部分计算机，攻击者有控制权或者是部分的控制权，并把相应的DDoS程序上传到这些平台上，这些程序与正常的程序一样运行并等待来自攻击者的指令，通常它还会利用各种手段隐藏自己不被别人发现。</p>\n<p>在平时，这些傀儡机器并没有什么异常，只是一旦攻击者连接到它们进行控制，并发出指令的时候，攻击愧儡机就成为攻击者去发起攻击了。</p>\n</blockquote>\n<p>之所以采用这样的结构，一个重要的目的是隔离网络联系，保护攻击者，使其不会在攻击进行时受到监控系统的跟踪。同时也能够更好地协调进攻，因为攻击执行器的数目太多，同时由一个系统发布命令会造成控制系统的网络阻塞，影响攻击的突然性和协同性。</p>\n<p>其过程为：</p>\n<ol>\n<li>\n<p>扫描大量主机以寻找可入侵主机目标</p>\n</li>\n<li>\n<p>有安全漏洞的主机并获取控制器</p>\n</li>\n<li>\n<p>入侵主机中安装攻击程序</p>\n</li>\n<li>\n<p>用已入侵主机继续进行扫描和入侵</p>\n</li>\n<li>\n<p>当受控制的攻击代理机达到攻击者满意的数量时。攻击者就可以通过攻击主控机随时发出击指令，一旦命令传送到攻击操纵机，主控机就可以关闭或脱离网络，以逃避追踪。</p>\n</li>\n<li>\n<p>攻击操纵机将命令发布到攻击代理机，其接收到后，就开始向目标主机发出大量的服务请求数据包。</p>\n<blockquote>\n<p>这些数据包经过伪装，使被攻击者无法识别它的来源面且，这些包所请求的服务往往要消耗较大的系统资源，如CP或网络带宽。如果数百台甚至上千台攻击代理机同时攻击一个目标，就会导致<strong>目标主机网络和系统资源的耗尽，从而停止服务。有时，甚至会导致系统崩溃。</strong></p>\n</blockquote>\n</li>\n</ol>\n<p>这样还可以阻塞目标网络的防火墙和路由器等网络设备，进一步加重网络拥塞状况。于是，目标主机根本无法为用户提供任何服务。攻击者所用的协议都是一些非常常见的协议和服务。这样，系统管理员就难于区分恶意请求和正连接请求，从而无法有效分离出攻击数据包</p>\n<h4 id=\"3.3-表现形式\">3.3 表现形式<a title=\"#3.3-表现形式\" href=\"#3.3-表现形式\"></a></h4>\n<p>主要目的是让指定目标无注提供正常服务，甚至从互联网上消失</p>\n<p>表现形式：</p>\n<ol>\n<li>\n<p><strong>流量攻击</strong>：主要是针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机</p>\n</li>\n<li>\n<p><strong>资源耗尽攻击</strong>：主要是针对服务器主机的政击，即通过大量攻击包导致主机的内存被耗尽或CPU内核及应用程序占完而造成无法提供网络服务</p>\n</li>\n</ol>\n<h4 id=\"3.4-识别\">3.4 识别<a title=\"#3.4-识别\" href=\"#3.4-识别\"></a></h4>\n<ol>\n<li>Ping测试</li>\n<li>Telnet测试</li>\n</ol>\n<h4 id=\"3.5-攻击方式\">3.5 攻击方式<a title=\"#3.5-攻击方式\" href=\"#3.5-攻击方式\"></a></h4>\n<ol>\n<li>SYN/ACK Flood攻击</li>\n<li>TCP全连接攻击</li>\n<li>TCP刷 Script脚本攻击</li>\n</ol>\n<h4 id=\"3.6-防护策略\">3.6 防护策略<a title=\"#3.6-防护策略\" href=\"#3.6-防护策略\"></a></h4>\n<ol>\n<li>采用高性能的网络设备</li>\n<li>尽量避免NAT的使用</li>\n<li>充足的网络带宽保证</li>\n<li>升级主机服务器硬件</li>\n<li>把网站做成静态页面</li>\n</ol>\n<h3 id=\"4.-点击劫持\">4. 点击劫持<a title=\"#4.-点击劫持\" href=\"#4.-点击劫持\"></a></h3>\n<h3 id=\"5.-cdn-劫持\">5. CDN 劫持<a title=\"#5.-cdn-劫持\" href=\"#5.-cdn-劫持\"></a></h3>\n<h4 id=\"5.1-简介\">5.1 简介<a title=\"#5.1-简介\" href=\"#5.1-简介\"></a></h4>\n<p>[CDN（Content Delivery Network）内容分发网络](./08 <a href=\"http://cdn.md\">cdn.md</a>)</p>\n<p>CDN 劫持：CDN 资源存在于第三方服务器，在安全性上并不完全可控。CDN 劫持是一种非常难以定位的问题，首先劫持者会利用某种算法或者随机的方式进行劫持，所以非常难以复现，很多用户出现后刷新页面就不再出现了。</p>\n<p><strong>开启 SRI 能有效保证页面引用资源的完整性，避免恶意代码执行。</strong></p>\n<h4 id=\"5.2-sri-简介\">5.2 SRI 简介<a title=\"#5.2-sri-简介\" href=\"#5.2-sri-简介\"></a></h4>\n<p>SRI（Subresource Integrity）子资源完整性，指浏览器通过验证资源的完整性（通常从 CDN 获取）来判断其是否被篡改的安全特性。</p>\n<p>通过给 link / script 标签添加 integrity 属性可开启 SRI 功能，</p>\n<p>eg：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;//s.url.cn/xxxx/aaa.js&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">integrity</span>=<span class=\"string\">&quot;sha256-xxx sha384-yyy&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>integrity 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。上述例子中使用了 sha256 和 sha384 两种 hash 方案。</p>\n<p><code>crossorigin=&quot;anonymous&quot;</code> 的作用是引入跨域脚本，在 HTML5 中有一种方式可以获取到跨域脚本的错误信息，首先跨域脚本的服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取错误信息，然后是当前域名的 script 标签也必须声明支持跨域，也就是 crossorigin 属性。link、img 等标签均支持跨域脚本。如果上述两个条件无法满足的话， 可以使用 <code>try catch</code> 方案。</p>\n</blockquote>\n<h4 id=\"5.3-浏览器处理-sri\">5.3 浏览器处理 SRI<a title=\"#5.3-浏览器处理-sri\" href=\"#5.3-浏览器处理-sri\"></a></h4>\n<ul>\n<li>\n<p>当浏览器在 script 或者 link 标签中遇到 integrity 属性之后，会在执行脚本或者应用样式表之前<strong>对比所加载文件的哈希值和期望的哈希值</strong>。</p>\n</li>\n<li>\n<p>当脚本或者样式表的哈希值和期望的不一致时，浏览器必须<strong>拒绝执行</strong>脚本或者应用样式表，并且必须返回一个网络错误说明获得脚本或样式表失败。</p>\n</li>\n</ul>\n<p><strong>Q：那么当 script 或者 link 资源 SRI 校验失败的时候应该怎么做？</strong></p>\n<p>A：通过 script 的 onerror 事件，当遇到 onerror 的时候重新 load 静态文件服务器之间的资源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span> src=<span class=\"string\">&quot;//11.url.cn/aaa.js&quot;</span></span><br><span class=\"line\">        integrity=<span class=\"string\">&quot;sha256-xxx sha384-yyy&quot;</span></span><br><span class=\"line\">        crossorigin=<span class=\"string\">&quot;anonymous&quot;</span></span><br><span class=\"line\">        onerror=<span class=\"string\">&quot;loadScriptError.call(this, event)&quot;</span></span><br><span class=\"line\">        onsuccess=<span class=\"string\">&quot;loadScriptSuccess&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>Q：如何判断发送 CDN 劫持</strong></p>\n<p>A：再请求一次数据，比较两次得到文件的内容（当然不必全部比较），如果内容不一致，就可以得出结论了。</p>\n<blockquote>\n<p>可以只比较前1000字符，CDN 劫持者会在 js 文件最前面注入一些代码来达到他们的目的，注入中间代码需要 AST 解析，成本较高，所以比较全部字符串没有意义。</p>\n</blockquote>\n<h3 id=\"6.-clickjacking-—-点击劫持\">6. ClickJacking — 点击劫持<a title=\"#6.-clickjacking-—-点击劫持\" href=\"#6.-clickjacking-—-点击劫持\"></a></h3>\n<h4 id=\"6.1-简介\">6.1 简介<a title=\"#6.1-简介\" href=\"#6.1-简介\"></a></h4>\n<p>点击劫持 ( ClickJacking ) / UI-覆盖攻击（UI redress attack），是一种视觉上的欺骗手段。</p>\n<blockquote>\n<p>通过覆盖不可见的框架误导受害者点击,虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了HTML中<iframe>标签的透明属性。</p>\n</blockquote>\n<p>一般有两种方式：</p>\n<ol>\n<li>攻击者使用一个透明的 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户在不知情的情况下点击透明的iframe页面；</li>\n<li>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义</li>\n</ol>\n<h4 id=\"6.2-原理\">6.2 原理<a title=\"#6.2-原理\" href=\"#6.2-原理\"></a></h4>\n<p>攻击者在点击劫持漏洞利用实现过程中使用 iframe 作为目标网页载体。iframe 是 HTML 标准中的一个标签，可以创建包含另外一个页面的内联框架，在点击劫持漏洞利用中主要用来载入目标网页。</p>\n<h4 id=\"6.3-防御\">6.3 防御<a title=\"#6.3-防御\" href=\"#6.3-防御\"></a></h4>\n<h5 id=\"6.3.1-服务器防御\">6.3.1 服务器防御<a title=\"#6.3.1-服务器防御\" href=\"#6.3.1-服务器防御\"></a></h5>\n<ol>\n<li>\n<p><strong>X-FRAME-OPTIONS 机制</strong></p>\n<p>微软提出的一个请求头，专门用来防御 iframe 嵌套的点击劫持攻击，其值有：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">DENY</span> <span class=\"comment\">// 拒绝任何域加载</span></span><br><span class=\"line\"><span class=\"variable constant_\">SAMEORIGIN</span> <span class=\"comment\">// 允许同源域下加载</span></span><br><span class=\"line\"><span class=\"variable constant_\">ALLOW</span>-<span class=\"variable constant_\">FROM</span> <span class=\"comment\">// 可以定义允许frame加载的页面地址</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>使用 FrameBusting 代码</strong></p>\n<p>​\t\tWeb安全研究人员针对 iframe 特性提出 Frame Busting 代码，使用 JavaScript 脚本阻止恶意网站载入网页。如果检测到网页被非法网页载入，就执行自动跳转功能。</p>\n<blockquote>\n<p>Frame Busting代码是一种有效防御网站被攻击者恶意载入的方法，网站开发人员使用Frame Busting代码阻止页面被非法载入。需要指出的情况是，如果用户浏览器禁用JavaScript脚本，那么FrameBusting代码也无法正常运行。所以，该类代码只能提供部分保障功能。</p>\n</blockquote>\n<blockquote>\n<p>具体代码在第八点，iframe</p>\n</blockquote>\n</li>\n<li>\n<p><strong>使用认证码认证用户</strong></p>\n<blockquote>\n<p>点击劫持漏洞通过伪造网站界面进行攻击，网站开发人员可以通过认证码识别用户，确定是用户发出的点击命令才执行相应操作。识别用户的方法中最有效的方法是认证码认证。例如，在网站上广泛存在的发帖认证码，要求用户输入图形中的字符，输入某些图形的特征等。</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"6.3.2-客户端防御\">6.3.2 客户端防御<a title=\"#6.3.2-客户端防御\" href=\"#6.3.2-客户端防御\"></a></h5>\n<p>由于点击劫持攻击的代码在客户端执行，因此客户端有很多机制可以防御此漏洞。</p>\n<ol>\n<li><strong>升级浏览器</strong><br>\n最新版本的浏览器提供很多防御点击劫持漏洞的安全机制，对于普通的互联网用户，经常更新修复浏览器的安全漏洞，能够最有效的防止恶意攻击。</li>\n<li><strong>NoScript 扩展</strong><br>\n对于Firefox的用户，使用 NoScript 扩展能够在一定程度上检测和阻止点击劫持攻击。利用 NoScript 中 ClearClick 组件能够检测和警告潜在的点击劫持攻击，自动检测页面中可能不安全的页面。</li>\n</ol>\n<h3 id=\"7.-hsts-—-http严格传输安全\">7. HSTS — HTTP严格传输安全<a title=\"#7.-hsts-—-http严格传输安全\" href=\"#7.-hsts-—-http严格传输安全\"></a></h3>\n<h4 id=\"7.1-场景介绍\">7.1 场景介绍<a title=\"#7.1-场景介绍\" href=\"#7.1-场景介绍\"></a></h4>\n<p>有很多网站只通过 HTTPS 对外提供服务，但用户在访问某个网站的时候，只输入 <a href=\"http://baidu.com\">baidu.com</a> 或者 <a href=\"http://www.baidu.com\">www.baidu.com</a> 就会302重定向到 https…。这就存在安全风险，当第一次通过 http 或域名进行访问时，302重定向可能会被劫持，篡改成一个恶意网站。（左边是正常访问流程，右边是被劫持的）</p>\n<p><img src=\"https://pic1.zhimg.com/v2-d1188ce4a87a3f4f743b6661a4745aa0_r.jpg\" alt=\"preview\" style=\"zoom:70%;float:left\" /><img src=\"https://pic3.zhimg.com/80/v2-73c0c5babeb7991c998ee9c1a9dddcfe_720w.jpg\" alt=\"img\" style=\"zoom:70%;float:left\" /></p>\n<blockquote>\n<p>正常流程：浏览器向网站发起一次 HTTP 请求，在得到一个重定向响应后，发起一次 HTTPS 请求并得到最终的响应。在用户眼里：在浏览器直接输入域名可以用 https 协议和网站进行安全通信</p>\n<p>被劫持流程：浏览器发起一次明文 HTTP 请求，但实际上会被攻击者拦截，攻击者作为代理，把当前请求转发给恶意网站，恶意网站返回假的网页内容，攻击者把假的网页内容返回给浏览器。</p>\n</blockquote>\n<h4 id=\"7.2-解决方式-hsts\">7.2 解决方式 HSTS<a title=\"#7.2-解决方式-hsts\" href=\"#7.2-解决方式-hsts\"></a></h4>\n<p>解决思路：避免出现一开始有可能会被劫持的 HTTP 的明文请求和重定向。</p>\n<p>当用户让浏览器发起 HTTP 请求时，浏览器将其转换为 HTTPS 请求，略和过 HTTP 请求和重定向。</p>\n<img src=\"https://pic2.zhimg.com/80/v2-06b98237cb541f4d60c697bb429dcbd5_720w.jpg\" alt=\"img\" style=\"zoom:70%;float:left\" />\n<p>解决方式：用户在浏览器输入网站域名，<strong>浏览器得知该域名要使用 HTTPS 进行通信</strong>，浏览器直接向网站发起 HTTPS 请求，网站返回相应内容。</p>\n<h4 id=\"7.3-浏览器怎么知道哪个网站应该发-https-请求？\">7.3 浏览器怎么知道哪个网站应该发 HTTPS 请求？<a title=\"#7.3-浏览器怎么知道哪个网站应该发-https-请求？\" href=\"#7.3-浏览器怎么知道哪个网站应该发-https-请求？\"></a></h4>\n<p>HSTS（HTTP Strict Transport Security）HTTP严格传输安全，是一个 Web 安全策略机制。</p>\n<p>其核心是一个 HTTP 响应头，其可以让浏览器知道，在接下来的一段时间内，当前域名只能通过 HTTPS 进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。</p>\n<h5 id=\"7.3.1-语法\">7.3.1 语法<a title=\"#7.3.1-语法\" href=\"#7.3.1-语法\"></a></h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Strict</span>-<span class=\"title class_\">Transport</span>-<span class=\"title class_\">Security</span>: <span class=\"language-xml\">&lt;max-age=&gt;[; includeSubDomains][; preload]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。</li>\n<li>includeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。</li>\n<li>preload是可选参数，只有当你申请将自己的域名加入到浏览器内置列表的时候才需要使用到它。关于浏览器内置列表，下文有详细介绍。</li>\n</ul>\n<blockquote>\n<p>在有效期内，都强制发起 HTTPS 请求</p>\n</blockquote>\n<h3 id=\"8.-iframe\">8. iframe<a title=\"#8.-iframe\" href=\"#8.-iframe\"></a></h3>\n<h5 id=\"8.1-如何让自己的网站不被其他网站的iframe引用？\">8.1 如何让自己的网站不被其他网站的iframe引用？<a title=\"#8.1-如何让自己的网站不被其他网站的iframe引用？\" href=\"#8.1-如何让自己的网站不被其他网站的iframe引用？\"></a></h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检测当前网站是否被第三方iframe引用</span></span><br><span class=\"line\"><span class=\"comment\">// 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(top.<span class=\"property\">location</span> != self.<span class=\"property\">location</span>)&#123;</span><br><span class=\"line\">    top.<span class=\"property\">location</span>.<span class=\"property\">href</span> = <span class=\"string\">&#x27;http://www.baidu.com&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"8.2-如何禁用-被使用的-iframe-对当前网站的某些操作？\">8.2 如何禁用 被使用的 iframe 对当前网站的某些操作？<a title=\"#8.2-如何禁用-被使用的-iframe-对当前网站的某些操作？\" href=\"#8.2-如何禁用-被使用的-iframe-对当前网站的某些操作？\"></a></h5>\n<p><strong>sandbox</strong> 是html5的新属性，主要是提高iframe安全系数。iframe因安全问题而臭名昭著，这主要是因为iframe常被用于嵌入到第三方中，然后执行某些恶意操作。<br>\n现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作DOM、不想加载某些js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。如使用多项用空格分隔。</p>\n<ul>\n<li>allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等</li>\n<li>allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载</li>\n<li>allow-forms：允许表单提交</li>\n<li>allow-scripts：允许执行脚本文件</li>\n<li>allow-popups：允许浏览器打开新窗口进行跳转</li>\n<li>“”：设置为空时上面所有允许全部禁止</li>\n</ul>\n<h3 id=\"9.-opener\">9. opener<a title=\"#9.-opener\" href=\"#9.-opener\"></a></h3>\n<p>如果在项目中需要 <strong>打开新标签</strong> 进行跳转一般会有两种方式：</p>\n<ol>\n<li>HTML -&gt; <code>&lt;a target='_blank' href='http://www.baidu.com'&gt;</code></li>\n<li>JS  -&gt; <code>window.open('http://www.baidu.com')</code></li>\n</ol>\n<blockquote>\n<p>这两种方式看起来没有问题，但是存在漏洞。<br>\n通过这两种方式打开的页面可以<strong>使用 window.opener 来访问源页面的 window 对象</strong>。<br>\n场景：A 页面通过 <a> 或 window.open 方式，打开 B 页面。但是 B 页面存在恶意代码如下：</p>\n<p><code>window.opener.location.replace('https://www.baidu.com') </code>【此代码仅针对打开新标签有效】</p>\n<p>此时，用户正在浏览新标签页，但是原来网站的标签页已经被导航到了百度页面。恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。<br>\n即使在跨域状态下 opener 仍可以调用 location.replace 方法</p>\n</blockquote>\n<h5 id=\"9.1-&lt;a-traget='_blank'-href=''&gt;\">9.1 <code>&lt;a traget='_blank' href=''&gt;</code><a title=\"#9.1-&lt;a-traget='_blank'-href=''&gt;\" href=\"#9.1-&lt;a-traget='_blank'-href=''&gt;\"></a></h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a target=<span class=\"string\">&quot;_blank&quot;</span> href=<span class=\"string\">&quot;&quot;</span> rel=<span class=\"string\">&quot;noopener noreferrer nofollow&quot;</span>&gt;a标签跳转url&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- </span><br><span class=\"line\">  通过 rel 属性进行控制：</span><br><span class=\"line\">  noopener：会将 <span class=\"variable language_\">window</span>.<span class=\"property\">opener</span> 置空，从而源标签页不会进行跳转（存在浏览器兼容问题）</span><br><span class=\"line\">  noreferrer：兼容老浏览器/火狐。禁用<span class=\"variable constant_\">HTTP</span>头部<span class=\"title class_\">Referer</span>属性（后端方式）。</span><br><span class=\"line\">  nofollow：<span class=\"variable constant_\">SEO</span>权重优化，详情见 <span class=\"attr\">https</span>:<span class=\"comment\">//blog.csdn.net/qq_33981438/article/details/80909881</span></span><br><span class=\"line\"> --&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"9.2-window.open()\">9.2 window.open()<a title=\"#9.2-window.open()\" href=\"#9.2-window.open()\"></a></h5>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onclick=<span class=\"string\">&#x27;openurl(&quot;http://www.baidu.com&quot;)&#x27;</span>&gt;click跳转&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">openurl</span>(<span class=\"params\">url</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newTab = <span class=\"variable language_\">window</span>.<span class=\"title function_\">open</span>();</span><br><span class=\"line\">    newTab.<span class=\"property\">opener</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    newTab.<span class=\"property\">location</span> = url;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","prev":{"title":"触底事件","link":"furtherNotes/further/07 滚动条触底事件"},"next":{"title":"滚轮事件","link":"furtherNotes/further/04 滚轮事件"},"plink":"https://shylees.github.io/furtherNotes/further/08 前端安全/","toc":[{"id":"前端安全","title":"前端安全","index":"1","children":[{"id":"1.-xss攻击-—-跨站脚本攻击","title":"1. XSS攻击 — 跨站脚本攻击","index":"1.1"},{"id":"2.-csrf攻击-—-跨站请求伪造","title":"2. CSRF攻击 — 跨站请求伪造","index":"1.2"},{"id":"3.-ddos-攻击-—-分布式拒绝服务攻击","title":"3. DDos 攻击 — 分布式拒绝服务攻击","index":"1.3"},{"id":"4.-点击劫持","title":"4. 点击劫持","index":"1.4"},{"id":"5.-cdn-劫持","title":"5. CDN 劫持","index":"1.5"},{"id":"6.-clickjacking-—-点击劫持","title":"6. ClickJacking — 点击劫持","index":"1.6"},{"id":"7.-hsts-—-http严格传输安全","title":"7. HSTS — HTTP严格传输安全","index":"1.7"},{"id":"8.-iframe","title":"8. iframe","index":"1.8"},{"id":"9.-opener","title":"9. opener","index":"1.9"}]}],"copyright":{"custom":"不许转载😡！！！"},"reading_time":"9269 words in 46 min"}