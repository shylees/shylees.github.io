{"title":"vue风格指南","date":"2022-02-21T08:42:00.000Z","date_formatted":{"ll":"Feb 21, 2022","L":"02/21/2022","MM-DD":"02-21"},"link":"workNotes/work/05 vue 风格指南","tags":["vue"],"categories":["workNotes"],"updated":"2022-02-21T09:37:00.000Z","content":"<h2 id=\"优先级a\">优先级A<a title=\"#优先级a\" href=\"#优先级a\"></a></h2>\n<h3 id=\"组件名为多个单词\">组件名为多个单词<a title=\"#组件名为多个单词\" href=\"#组件名为多个单词\"></a></h3>\n<p>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>\n<h3 id=\"组件数据必为函数\">组件数据必为函数<a title=\"#组件数据必为函数\" href=\"#组件数据必为函数\"></a></h3>\n<p>当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。</p>\n<blockquote>\n<p>当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。当组件被重用时，因为每个组件的实例都引用了相同的数据对象，更改其中一个对象就是改变到其他使用到该组件的数据</p>\n</blockquote>\n<p>我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。</p>\n<h3 id=\"prop-定义应该尽量详细\">prop 定义应该尽量详细<a title=\"#prop-定义应该尽量详细\" href=\"#prop-定义应该尽量详细\"></a></h3>\n<p>至少要指定数据类型</p>\n<blockquote>\n<p>细致的 prop 定义有两个好处：</p>\n<p>它们写明了组件的 API，所以很容易看懂组件的用法；</p>\n<p>在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</p>\n</blockquote>\n<h3 id=\"v-for-设置-key\">v-for 设置 key<a title=\"#v-for-设置-key\" href=\"#v-for-设置-key\"></a></h3>\n<p>以便维护内部组件及其子树的状态。</p>\n<h3 id=\"避免-v-if-和-v-for-一起使用\">避免 v-if 和 v-for 一起使用<a title=\"#避免-v-if-和-v-for-一起使用\" href=\"#避免-v-if-和-v-for-一起使用\"></a></h3>\n<p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。<br>\n所以当用在一个元素的时候，会先把所有元素遍历渲染出来，在看v-if哪些是不用渲染的</p>\n<h3 id=\"为组件样式设置作用域\">为组件样式设置作用域<a title=\"#为组件样式设置作用域\" href=\"#为组件样式设置作用域\"></a></h3>\n<p>顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的</p>\n<blockquote>\n<p>这条规则只和单文件组件有关。你不一定要使用 scoped attribute。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。</p>\n<p>不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped attribute。</p>\n<p>这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p>\n</blockquote>\n<p>Vue 使用 _ 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 <em>update) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。<br>\n对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于私有 property 并不合适。<br>\n不过，我们推荐把这两个前缀结合为 $</em>，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。</p>\n<h2 id=\"优先级b\">优先级B<a title=\"#优先级b\" href=\"#优先级b\"></a></h2>\n<h3 id=\"组件文件\">组件文件<a title=\"#组件文件\" href=\"#组件文件\"></a></h3>\n<h3 id=\"单文件组件文件名称\">单文件组件文件名称<a title=\"#单文件组件文件名称\" href=\"#单文件组件文件名称\"></a></h3>\n<p>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</p>\n<blockquote>\n<p>单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。</p>\n</blockquote>\n<h3 id=\"基础组件名\">基础组件名<a title=\"#基础组件名\" href=\"#基础组件名\"></a></h3>\n<p>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V</p>\n<h3 id=\"单例组件名-the\">单例组件名 The<a title=\"#单例组件名-the\" href=\"#单例组件名-the\"></a></h3>\n<p>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性</p>\n<p>这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。</p>\n<h3 id=\"紧密耦合的组件名\">紧密耦合的组件名<a title=\"#紧密耦合的组件名\" href=\"#紧密耦合的组件名\"></a></h3>\n<p>和父组件紧密耦合的子组件应该以父组件名作为前缀命名</p>\n<h3 id=\"自闭合组件\">自闭合组件<a title=\"#自闭合组件\" href=\"#自闭合组件\"></a></h3>\n<p>组件名中的单词顺序在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</p>\n<p>自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。</p>\n<p>不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。<br>\n组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 在 DOM 模板中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"模版中的组件名大小写\">模版中的组件名大小写<a title=\"#模版中的组件名大小写\" href=\"#模版中的组件名大小写\"></a></h3>\n<p>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</p>\n<blockquote>\n<p>PascalCase 相比 kebab-case 有一些优势：</p>\n</blockquote>\n<blockquote>\n<p>编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。<br>\n<code>&lt;MyComponent&gt;</code> 视觉上比 <code>&lt;my-component&gt;</code> 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。<br>\n如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。<br>\n不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">MyComponent</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 在 DOM 模板中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- or 在所有地方 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"js/jsx-中组件名大小写\">js/jsx 中组件名大小写<a title=\"#js/jsx-中组件名大小写\" href=\"#js/jsx-中组件名大小写\"></a></h3>\n<p>JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;MyComponent&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;my-component&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MyComponent</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./MyComponent.vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;MyComponent&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"完整单词组件名\">完整单词组件名<a title=\"#完整单词组件名\" href=\"#完整单词组件名\"></a></h3>\n<p>组件名应该倾向于完整单词而不是缩写。</p>\n<p>编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>\n<h3 id=\"prop名-大小写\">prop名 大小写<a title=\"#prop名-大小写\" href=\"#prop名-大小写\"></a></h3>\n<p>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。</p>\n<p><strong>我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</strong></p>\n<h3 id=\"多-attr-元素\">多 attr 元素<a title=\"#多-attr-元素\" href=\"#多-attr-元素\"></a></h3>\n<p>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</p>\n<p>在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。</p>\n<h3 id=\"模版中简单表达式\">模版中简单表达式<a title=\"#模版中简单表达式\" href=\"#模版中简单表达式\"></a></h3>\n<p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</p>\n<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>\n<h3 id=\"简单计算属性\">简单计算属性<a title=\"#简单计算属性\" href=\"#简单计算属性\"></a></h3>\n<p>应该把复杂计算属性分割为尽可能多的更简单的 property。</p>\n<blockquote>\n<p>易于测试、易于阅读、更好的“拥抱变化”</p>\n</blockquote>\n<h3 id=\"带引号的-attr-值\">带引号的 attr 值<a title=\"#带引号的-attr-值\" href=\"#带引号的-attr-值\"></a></h3>\n<p>非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。</p>\n<p>在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里不写空格，导致可读性变差。</p>\n<h3 id=\"指令缩写\">指令缩写<a title=\"#指令缩写\" href=\"#指令缩写\"></a></h3>\n<p>指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。</p>\n<h2 id=\"优先级-c\">优先级 C<a title=\"#优先级-c\" href=\"#优先级-c\"></a></h2>\n<h3 id=\"组件/实例的选项顺序\">组件/实例的选项顺序<a title=\"#组件/实例的选项顺序\" href=\"#组件/实例的选项顺序\"></a></h3>\n<p>推荐</p>\n<ol>\n<li>副作用 - 触发组件外的影响\n<ul>\n<li>el</li>\n</ul>\n</li>\n<li>全局感知 - 要求组件外的知识\n<ul>\n<li>name</li>\n<li>parent</li>\n</ul>\n</li>\n<li>组件类型 - 更改组件类型\n<ul>\n<li>functional</li>\n</ul>\n</li>\n<li>模版修改器 - 改变模版的编译方式\n<ul>\n<li>delimiters</li>\n<li>comments</li>\n</ul>\n</li>\n<li>模版依赖 - 模版内使用的资源\n<ul>\n<li>components</li>\n<li>directives</li>\n<li>filters</li>\n</ul>\n</li>\n<li>组合 - 向选项里合并 property\n<ul>\n<li>extends</li>\n<li>mixins</li>\n</ul>\n</li>\n<li>接口 - 组件接口\n<ul>\n<li>inheritAttrs</li>\n<li>model</li>\n<li>props/propsData</li>\n</ul>\n</li>\n<li>本地状态 - 本地响应式 property\n<ul>\n<li>data</li>\n<li>computed</li>\n</ul>\n</li>\n<li>事件 - 通过响应式事件触发的回调函数\n<ul>\n<li>watch</li>\n<li>生命周期钩子</li>\n</ul>\n</li>\n<li>非响应式的 property - 不依赖响应式系统的 property\n<ul>\n<li>methods</li>\n</ul>\n</li>\n<li>渲染 - 组件输出声明描述\n<ul>\n<li>template/render</li>\n<li>renderError</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"元素-attr-顺序\">元素 attr 顺序<a title=\"#元素-attr-顺序\" href=\"#元素-attr-顺序\"></a></h3>\n<ol>\n<li>定义 - 提供组件的选项\n<ul>\n<li>is</li>\n</ul>\n</li>\n<li>列表渲染\n<ul>\n<li>v-for</li>\n</ul>\n</li>\n<li>条件渲染\n<ul>\n<li>v-if</li>\n<li>v-else-if</li>\n<li>v-else</li>\n<li>v-show</li>\n<li>v-cloak</li>\n</ul>\n</li>\n<li>渲染方式\n<ul>\n<li>v-pre</li>\n<li>v-once</li>\n</ul>\n</li>\n<li>全局感知 - 需要超越组件的知识\n<ul>\n<li>id</li>\n</ul>\n</li>\n<li>唯一的attr\n<ul>\n<li>ref</li>\n<li>key</li>\n</ul>\n</li>\n<li>双向绑定\n<ul>\n<li>v-model</li>\n</ul>\n</li>\n<li>其他 attr - 所有普通的绑定或未绑定的 attr</li>\n<li>事件\n<ul>\n<li>v-on</li>\n</ul>\n</li>\n<li>内容\n<ul>\n<li>v-html</li>\n<li>v-text</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"组件/实例选项中的空行\">组件/实例选项中的空行<a title=\"#组件/实例选项中的空行\" href=\"#组件/实例选项中的空行\"></a></h3>\n<p>你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。</p>\n<p>当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。</p>\n<h3 id=\"单文件组件的顶级元素的顺序\">单文件组件的顶级元素的顺序<a title=\"#单文件组件的顶级元素的顺序\" href=\"#单文件组件的顶级元素的顺序\"></a></h3>\n<p>单文件组件应该总是让 <code>&lt;script&gt;</code>、<code>&lt;template&gt;</code> 和 <code>&lt;style&gt;</code> 标签的顺序保持一致。且 <code>&lt;style&gt;</code> 要放在最后，因为另外两个标签至少要有一个。</p>\n<h2 id=\"优先级d-谨慎使用\">优先级D 谨慎使用<a title=\"#优先级d-谨慎使用\" href=\"#优先级d-谨慎使用\"></a></h2>\n<h3 id=\"不在-v-if/v-else-if/v-else-➕-key\">不在 v-if/v-else-if/v-else ➕ key<a title=\"#不在-v-if/v-else-if/v-else-➕-key\" href=\"#不在-v-if/v-else-if/v-else-➕-key\"></a></h3>\n<p>如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <div> 元素)。</p>\n<p>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。</p>\n<h3 id=\"scoped-避免出现元素选择器\">scoped 避免出现元素选择器<a title=\"#scoped-避免出现元素选择器\" href=\"#scoped-避免出现元素选择器\"></a></h3>\n<p>在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p>\n<h3 id=\"隐性父子组件通信\">隐性父子组件通信<a title=\"#隐性父子组件通信\" href=\"#隐性父子组件通信\"></a></h3>\n<p>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。</p>\n<p>一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。</p>\n<p>问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p>\n<h3 id=\"非-flux-的全局状态管理\">非 flux 的全局状态管理<a title=\"#非-flux-的全局状态管理\" href=\"#非-flux-的全局状态管理\"></a></h3>\n<p>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。</p>\n<p>通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。</p>\n<p>Vuex 是 Vue 的官方类 flux 实现，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 Vue DevTools 支持)。</p>\n","prev":{"title":"vue 一些注意的问题","link":"workNotes/work/06 vue 问题"},"next":{"title":"nuxtjs 的生命周期","link":"workNotes/work/04 nuxtjs 生命周期"},"plink":"https://shylees.github.io/workNotes/work/05 vue 风格指南/","toc":[{"id":"优先级a","title":"优先级A","index":"1","children":[{"id":"组件名为多个单词","title":"组件名为多个单词","index":"1.1"},{"id":"组件数据必为函数","title":"组件数据必为函数","index":"1.2"},{"id":"prop-定义应该尽量详细","title":"prop 定义应该尽量详细","index":"1.3"},{"id":"v-for-设置-key","title":"v-for 设置 key","index":"1.4"},{"id":"避免-v-if-和-v-for-一起使用","title":"避免 v-if 和 v-for 一起使用","index":"1.5"},{"id":"为组件样式设置作用域","title":"为组件样式设置作用域","index":"1.6"}]},{"id":"优先级b","title":"优先级B","index":"2","children":[{"id":"组件文件","title":"组件文件","index":"2.1"},{"id":"单文件组件文件名称","title":"单文件组件文件名称","index":"2.2"},{"id":"基础组件名","title":"基础组件名","index":"2.3"},{"id":"单例组件名-the","title":"单例组件名 The","index":"2.4"},{"id":"紧密耦合的组件名","title":"紧密耦合的组件名","index":"2.5"},{"id":"自闭合组件","title":"自闭合组件","index":"2.6"},{"id":"模版中的组件名大小写","title":"模版中的组件名大小写","index":"2.7"},{"id":"js/jsx-中组件名大小写","title":"js&#x2F;jsx 中组件名大小写","index":"2.8"},{"id":"完整单词组件名","title":"完整单词组件名","index":"2.9"},{"id":"prop名-大小写","title":"prop名 大小写","index":"2.10"},{"id":"多-attr-元素","title":"多 attr 元素","index":"2.11"},{"id":"模版中简单表达式","title":"模版中简单表达式","index":"2.12"},{"id":"简单计算属性","title":"简单计算属性","index":"2.13"},{"id":"带引号的-attr-值","title":"带引号的 attr 值","index":"2.14"},{"id":"指令缩写","title":"指令缩写","index":"2.15"}]},{"id":"优先级-c","title":"优先级 C","index":"3","children":[{"id":"组件/实例的选项顺序","title":"组件&#x2F;实例的选项顺序","index":"3.1"},{"id":"元素-attr-顺序","title":"元素 attr 顺序","index":"3.2"},{"id":"组件/实例选项中的空行","title":"组件&#x2F;实例选项中的空行","index":"3.3"},{"id":"单文件组件的顶级元素的顺序","title":"单文件组件的顶级元素的顺序","index":"3.4"}]},{"id":"优先级d-谨慎使用","title":"优先级D 谨慎使用","index":"4","children":[{"id":"不在-v-if/v-else-if/v-else-➕-key","title":"不在 v-if&#x2F;v-else-if&#x2F;v-else ➕ key","index":"4.1"},{"id":"scoped-避免出现元素选择器","title":"scoped 避免出现元素选择器","index":"4.2"},{"id":"隐性父子组件通信","title":"隐性父子组件通信","index":"4.3"},{"id":"非-flux-的全局状态管理","title":"非 flux 的全局状态管理","index":"4.4"}]}],"copyright":{"custom":"不许转载😡！！！"},"reading_time":"3144 words in 16 min"}