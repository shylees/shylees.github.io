{"title":"红宝书 - 第2章 HTML中的JavaScript","date":"2021-01-24T16:00:00.000Z","date_formatted":{"ll":"Jan 25, 2021","L":"01/25/2021","MM-DD":"01-25"},"link":"readNotes/2","tags":["js"],"categories":["readNotes"],"updated":"2021-01-26T16:00:00.000Z","content":"<blockquote>\n<p>在JavaScript早期，网景公司的工作人员希望在将JavaScript引入HTML页面的同时，不会导致页面在其他浏览器中渲染初问题</p>\n<p>最终他们达成了向网页中引入通用脚本能力的共识</p>\n<p>当初他们的工作得到了保留，并且最终形成了HTML规范</p>\n</blockquote>\n<h2 id=\"2.1-&lt;script&gt;元素\">2.1 <code>&lt;script&gt;</code>元素<a title=\"#2.1-&lt;script&gt;元素\" href=\"#2.1-&lt;script&gt;元素\"></a></h2>\n<blockquote>\n<p>将JavaScript插入HTML的主要方法是使用<code>&lt;script&gt;</code>元素。这个元素是由网景公司创造出来，并最早在Netscape Navigator2 中实现的。后来，这个元素被正式加入到HTML规范。</p>\n</blockquote>\n<ol>\n<li><strong>其有以下8个属性</strong>：</li>\n</ol>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>属性名</th>\n<th>状态</th>\n<th>作用</th>\n<th>使用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>async</td>\n<td>可选</td>\n<td>立即开始下载文件，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载</td>\n<td>外部脚本</td>\n</tr>\n<tr>\n<td>charset</td>\n<td>可选</td>\n<td>使用src属性指定的代码字符集</td>\n<td>少用，大多浏览器不在乎它的值</td>\n</tr>\n<tr>\n<td>crossorigin</td>\n<td>可选</td>\n<td>配置相关请求的CORS（跨源资源共享）设置，<br />crossorigin=“anonymous”配置文件请求不必设置凭据标志<br />crossorigin=“use-credentials”设置凭据标志，意味着出站请求会包含凭据</td>\n<td>默认不使用CORS</td>\n</tr>\n<tr>\n<td>defer</td>\n<td>可选</td>\n<td>表示脚本可以延迟到文档完全被解析和显示之后再执行</td>\n<td>外部脚本，IE7及更早版本，行内也有效</td>\n</tr>\n<tr>\n<td>integrity</td>\n<td>可选</td>\n<td>允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity），如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容</td>\n<td></td>\n</tr>\n<tr>\n<td>language</td>\n<td><font color='red'>废弃</font></td>\n<td>最初用于表示代码块中的脚本语言（如：”JavaScript“、”JavaScript1.2“，”VBScript“）</td>\n<td>大多数浏览器都会忽略这个属性</td>\n</tr>\n<tr>\n<td>src</td>\n<td>可选</td>\n<td>表示包含要执行的代码的外部文件</td>\n<td></td>\n</tr>\n<tr>\n<td>type</td>\n<td>可选</td>\n<td>代替language，表示代码块中脚本语言的内容类型（MIME类型）</td>\n<td></td>\n</tr>\n</tbody>\n</table></div></div><blockquote>\n<p>type中：按照惯例，这个值始终都是”text/javascript“，尽管”text/javascript“和”text/ecmascript“都已经废弃了，</p>\n<p>javascript文件的MIME类型通常是”application/x-javascript“，不过给type这个值有可能导致脚本被忽略。</p>\n<p>在非IE浏览器中有效的其他值还有”application/javascript“和”application/javascript“。</p>\n<p>如果这个值是module，则代码会被当成es6模块，只有这时候代码中才能出现import和export关键字</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>使用<code>&lt;script&gt;</code>的方式</strong>：</li>\n</ol>\n<ul>\n<li>\n<p>通过它直接在网页中嵌入JavaScript代码</p>\n<ul>\n<li>直接把代码放在<code>&lt;script&gt;</code>元素中就行</li>\n<li>在<code>&lt;script&gt;</code>元素中的代码被计算完成前，页面的其余内容不会被加载，也不会被显示</li>\n<li>注意代码中不能出现<code>&lt;/script&gt;</code>字符串，否则会报错</li>\n<li>if要避免上述问题，只需转义字符“\\”</li>\n</ul>\n</li>\n<li>\n<p>通过它在网页中包含外部JavaScript文件</p>\n<ul>\n<li>必须使用src属性</li>\n<li>与解释行内一样，解释外部JavaScript文件时，页面会阻塞（阻塞时间包含下载文件的时间）</li>\n<li>在XHTML中，可以<code>&lt;script src='excample.js' /&gt;</code>，但其是无效的HTML，有些浏览器不能正常处理</li>\n<li>其url指向的资源可以与其HTML页面不在同一个域中\n<ul>\n<li>例如<code>&lt;script src='http://www.somewhere.com/afile.js'&gt;&lt;/script&gt;</code></li>\n<li>浏览器在解析这个资源时，会向src属性指定的路径发送一个GET请求，以取得相应资源</li>\n<li>这个初始请求不受浏览器同源策略限制</li>\n<li>返回并被执行的JavaScript受限制</li>\n<li>这个请求仍然受父页面HTTP/HTTPS协议的限制</li>\n</ul>\n</li>\n<li>来自外部域的代码会被当成加载它的页面的一部分来加载和解释\n<ul>\n<li>这个能力可以让我们通过不同的域分发JavaScript</li>\n<li>若引用了别人服务器上的文件，要确保文件不会被替换</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>使用了src属性的<code>&lt;script&gt;</code>元素不应该在标签中再包含其他JavaScript代码，否则浏览器只会下载执行脚本文件，从而忽略行内代码</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2.1.1-标签位置\">2.1.1 标签位置<a title=\"#2.1.1-标签位置\" href=\"#2.1.1-标签位置\"></a></h3>\n<ul>\n<li>\n<p>放在<code>&lt;head&gt;&lt;/head&gt;</code>标签内（过去）</p>\n<blockquote>\n<p>意味着必须把所有的JavaScript代码都下载、解析和解释完成后，才能开始渲染页面，</p>\n<p>若有很多JavaScript文件的页面，会有明显的延迟</p>\n</blockquote>\n</li>\n<li>\n<p><code>&lt;body&gt;</code>元素中的页面内容后面（现代web应用程序）</p>\n</li>\n</ul>\n<h3 id=\"2.1.2-推迟执行脚本&lt;font-color='red'&gt;defer&lt;/font&gt;\">2.1.2 推迟执行脚本<font color='red'><code>defer</code></font><a title=\"#2.1.2-推迟执行脚本&lt;font-color='red'&gt;defer&lt;/font&gt;\" href=\"#2.1.2-推迟执行脚本&lt;font-color='red'&gt;defer&lt;/font&gt;\"></a></h3>\n<p>HTML4.01定义了<code>defer</code>属性，表示脚本在执行时不会改变页面的结构。即脚本会被延迟到整个页面都解析完毕后再运行</p>\n<blockquote>\n<p>告诉浏览器立即下载，但延迟执行</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;example.js&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- if XHTML </span></span><br><span class=\"line\"><span class=\"comment\">\tdefer=&quot;defer&quot;</span></span><br><span class=\"line\"><span class=\"comment\">\t--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>HTML5规范要求脚本应该按照他们出现的顺序执行，且均会在DOMContentLoaded事件之前执行；</p>\n<p>但实际中，推迟执行的脚本不一定总会按照顺序执行或者再DOMContentLoaded事件之前执行；</p>\n<p>因此最好只包含一个这样的脚本。</p>\n<blockquote>\n<p>对<code>defer</code>属性的支持时从IE4、Firefox3.5、Safari5和Chrome7开始的。其他浏览器会忽略这个属性，所以还是把要延迟的脚本放在页面底部比较好</p>\n</blockquote>\n<h3 id=\"2.1.3-异步执行脚本\">2.1.3 异步执行脚本<a title=\"#2.1.3-异步执行脚本\" href=\"#2.1.3-异步执行脚本\"></a></h3>\n<p>HTML5定义了<code>async</code>属性，其与<code>defer</code>类似，都只适用于外部脚本，都会告诉浏览器立即开始下载。</p>\n<p>但<code>async</code>不能保证他们按照他们出现的次序执行</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;example1.js&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&#x27;example2.js&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- if XHTML </span></span><br><span class=\"line\"><span class=\"comment\">\tasync=&quot;async&quot;</span></span><br><span class=\"line\"><span class=\"comment\">\t--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本，所以异步脚本不应该在加载期间修改DOM。</p>\n</blockquote>\n<p>异步脚本保证会在load事件前执行，但可能会在DOMContentLoaded之前/后；</p>\n<p>使用其也会告诉页面，你不会使用document.write；</p>\n<blockquote>\n<p>Firefox3.6、Safari5和Chrome7支持异步脚本；</p>\n</blockquote>\n<h3 id=\"2.1.4-动态加载脚本\">2.1.4 动态加载脚本<a title=\"#2.1.4-动态加载脚本\" href=\"#2.1.4-动态加载脚本\"></a></h3>\n<p>因为JavaScript可以使用DOM API，所以通过向DOM中动态添加<code>script</code>元素同样可以加载指定的脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> script = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>); <span class=\"comment\">//创建</span></span><br><span class=\"line\">script.<span class=\"property\">src</span>=<span class=\"string\">&#x27;gibbarish.js&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">//默认以这种方式创建的`script`是异步加载的，相当于添加了async，但可能会有问题</span></span><br><span class=\"line\"><span class=\"comment\">//因为所有浏览器支持createElement()方法，但不是所有浏览器都支持async属性</span></span><br><span class=\"line\"><span class=\"comment\">//所以为了统一动态脚本的加载行为，可以明确将其设置为同步加载</span></span><br><span class=\"line\">script.<span class=\"property\">async</span>=<span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">head</span>.<span class=\"title function_\">appendChild</span>(script);<span class=\"comment\">//添加到页面上</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以这种方式获取的资源对浏览器预加载器是不可见的，会影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能</p>\n</blockquote>\n<p>要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&#x27;preload&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;gibberish.js&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2.1.5-xhtml中的变化\">2.1.5 XHTML中的变化<a title=\"#2.1.5-xhtml中的变化\" href=\"#2.1.5-xhtml中的变化\"></a></h3>\n<p>可扩展性文本标记语言（XHTML，Extensible HyperText Markup Language）是将HTML作为XML的应用重新包装的结果。</p>\n<p>在XTML中使用JavaScript必须指定<code>type=text/javascript</code>，HTML则可以没有。</p>\n<blockquote>\n<p>XHTML虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码</p>\n</blockquote>\n<p>在XHTML中编写代码比较严格，</p>\n<ul>\n<li>\n<p>在编写JavaScript时，小于号<code>&lt;</code>会被解释成一个标签的开始，并且由于作为开始标签的小于号后面不能有空格，所以<code>if(a &lt; b)</code>这样的代码会报错；以下是避免这种错误的方法：</p>\n<ul>\n<li>\n<p>把所有小于号<code>&lt;</code>都替换成对应的HTML实体形式<code>&amp;lt;</code>，即<code>if(a &amp;lt; b)</code></p>\n</li>\n<li>\n<p>把所有代码都包含到一个CDATA块中</p>\n<blockquote>\n<p>在XHTML/XML中，CDATA块表示文档中可以包含任意文本的区块，其内容不作为标签来解析，因此可以在其中包含任意字符</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;text/javascript&#x27;</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\">&lt;![CDATA[</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">        function compare(a , b)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">            if(a &lt; b)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">                console.log(&quot;a &lt; b&quot;);</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">            &#125;...</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">        &#125;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">    ]]&gt;</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>在兼容XHTML的浏览器中，这样能解决问题，但在不支持CDATA块的非XHTML兼容浏览器中则不行，</p>\n<p>所以CDATA比如使用JavaScript注释来抵消：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;text/javascript&#x27;</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">    //&lt;![CDATA[</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">        function compare(a , b)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">            if(a &lt; b)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">                console.log(&quot;a &lt; b&quot;);</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">            &#125;...</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">        &#125;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\">    //]]&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"language-handlebars\"></span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种格式使用于所有现代浏览器，它不仅可以通过XHTML验证，而且对XHTML之前的浏览器也能优雅地降级</p>\n</blockquote>\n<h3 id=\"2.1.6-废弃的语法\">2.1.6 废弃的语法<a title=\"#2.1.6-废弃的语法\" href=\"#2.1.6-废弃的语法\"></a></h3>\n<ul>\n<li>\n<p>type属性使用一个MIME类型字符串来标识<code>&lt;script&gt;</code>的内容，但MIME类型并没有跨浏览器标准化，即使浏览器默认使用JavaScript，在某些情况下某个无效或无法识别的MIME类型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用XHTML或<code>&lt;script&gt;</code>标签要求或包含非JavaScript代码，最佳做法式不指定type类型。</p>\n</li>\n<li>\n<p>在不支持JavaScript的浏览器（特别是Mosaic）中会把<code>&lt;script&gt;</code>元素的内容输出到页面上，解决方案是把脚本代码块包含在一个HTML注释中</p>\n</li>\n</ul>\n  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"><span class=\"comment\">&lt;!--</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"language-xml\"><span class=\"language-handlebars\">\tfunction sayHi()&#123;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"language-xml\"><span class=\"language-handlebars\">        console.log(&quot;Hi!&quot;);</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"language-xml\"><span class=\"language-handlebars\">    &#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"language-xml\"><span class=\"language-handlebars\">//--&gt;</span></span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用这种格式，Mosaic等浏览器就可以忽略<code>&lt;script&gt;</code>标签中的内容，而支持JavaScript的浏览器则必须识别这种模式，将其中的内容作为JavaScript来解析。</p>\n</blockquote>\n<p>但其实这种格式以及不再必要，而且不应该使用了。在XHTML模式下，这种格式会导致脚本被忽略，因为代码处于有效的XML注释当中。</p>\n</li>\n</ul>\n<h2 id=\"2.2-行内代码和外部文件\">2.2 行内代码和外部文件<a title=\"#2.2-行内代码和外部文件\" href=\"#2.2-行内代码和外部文件\"></a></h2>\n<p>推荐使用外部文件：</p>\n<ul>\n<li>可维护性</li>\n<li>缓存\n<ul>\n<li>浏览器会根据特定的设置缓存所有外部链接的JavaScript文件</li>\n<li>若两个页面引用到同一个文件，则该文件只需下载一次，意味着页面加载更快</li>\n</ul>\n</li>\n<li>适应未来\n<ul>\n<li>不必考虑用XHTML或前面提到的注释</li>\n<li>外部JavaScript的语法在HTML和XHTML中是一样的</li>\n</ul>\n</li>\n</ul>\n<p>在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从一个地方取得一批文件，并将它们逐个放到浏览器缓存中。通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JavaScript文件的延迟差不多。</p>\n<p>在第二个页面请求时，由于已经把应用程序切换成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在浏览器缓存中了。</p>\n<h2 id=\"2.3-文档模式\">2.3 文档模式<a title=\"#2.3-文档模式\" href=\"#2.3-文档模式\"></a></h2>\n<p>IE5.5发明了文档模式，即可以使用doctype切换文档；</p>\n<p>最初的文档模式有两种：<strong>混杂模式</strong>和<strong>标准模式</strong></p>\n<blockquote>\n<p>这两种模式的区别只体现在通过CSS渲染的内容方面，对JavaScript也有一些关联影响，或称为副作用。</p>\n</blockquote>\n<p>后来又出现了第3种文档模式：<strong>准标准模式</strong></p>\n<blockquote>\n<p>这种模式下的浏览器支持很多标准的特性，但是没有标准规定的那么严格；</p>\n<p>主要区别在如何对待图片元素周围的空白（在表格中使用图片时最明显）</p>\n</blockquote>\n<ol>\n<li>\n<p><strong>混杂模式</strong>：在所有浏览器中都以省略文档开头的doctype声明作为开关，这种约定不合理，因为混杂模式在不同浏览器中的差异很大，不使用黑科技基本上就没有浏览器一致性可言。</p>\n</li>\n<li>\n<p><strong>标准模式</strong>：通过下列几种文档类型声明开启</p>\n<ul>\n<li>\n<pre><code class=\"language-html\">&lt;!-- HTML 4.01 Strict --&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; \n&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ~~~html</span><br><span class=\"line\">  &lt;!-- XHTML 1.0 Strict --&gt;</span><br><span class=\"line\">  &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; </span><br><span class=\"line\">  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml-strict.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;!-- HTML5 --&gt;\n&lt;!DOCTYPE html&gt; \n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. **准标准模式**：通过过滤性文档类型（Transitional）和框架集文档类型（Frameset）来触发</span><br><span class=\"line\"></span><br><span class=\"line\">   * ~~~html</span><br><span class=\"line\">     &lt;!-- HTML 4.01 Transitional --&gt;</span><br><span class=\"line\">     &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; </span><br><span class=\"line\">     &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;!-- HTML 4.01 Frameset --&gt;\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ~~~html</span><br><span class=\"line\">  &lt;!-- XHTML 4.01 Transitional --&gt;</span><br><span class=\"line\">  &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; </span><br><span class=\"line\">  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml-transitional.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;!-- XHTML 1.0 Frameset --&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/xhtml1/xhtml1-frameset.dtd&quot;&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>准标准模式和标准模式非常接近，很少需要区分，而本书后面所说的标准模式，指的是除混杂模式之外的模式</p>\n</blockquote>\n<h2 id=\"2.4-&lt;noscript&gt;元素\">2.4 <code>&lt;noscript&gt;</code>元素<a title=\"#2.4-&lt;noscript&gt;元素\" href=\"#2.4-&lt;noscript&gt;元素\"></a></h2>\n<p>针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级的处理方案。</p>\n<p><code>&lt;noscript&gt;</code>元素即用于给不支持JavaScript的浏览器提供替代内容。</p>\n<blockquote>\n<p>虽然先浏览器已经100%支持JavaScript，但对于禁用JavaScript的浏览器来说，这个元素仍然有它的用处</p>\n</blockquote>\n<p><code>&lt;noscript&gt;</code>元素可以包含任何可以出现在<code>&lt;body&gt;</code>中的html元素（除<code>&lt;script&gt;</code>）;</p>\n<p>当满足如下任一条件时，浏览器将显示包含在<code>&lt;noscript&gt;</code>的内容：</p>\n<ul>\n<li>浏览器不支持脚本</li>\n<li>浏览器对脚本的支持被关闭</li>\n</ul>\n<h2 id=\"2.5-小结\">2.5 小结<a title=\"#2.5-小结\" href=\"#2.5-小结\"></a></h2>\n<p>JavaScript是通过<code>&lt;script&gt;</code>元素插入到html页面中的：</p>\n<ul>\n<li>要包含外部JavaScript文件，必须将src属性设置为要包含文件的url。文件可以跟网页在同一台服务器上，也可以位于完全不同的域</li>\n<li>所有<code>&lt;script&gt;</code>元素会依照它们在网页中出现的次序被解释，在不使用<code>defer</code>和<code>async</code>时，包含在<code>&lt;script&gt;</code>的代码必须严格按次序解释</li>\n<li>对不推迟执行的脚本，浏览器必须解释完位于<code>&lt;script&gt;</code>元素的代码，然后才能继续渲染页面的剩余部分。为此，通常把此元素放到页面末尾</li>\n<li>可以使用<code>defer</code>属性把脚本推迟到文档渲染完毕后再执行。推迟脚本的原则上按照次序执行</li>\n<li>可以使用<code>async</code>属性表示不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照次序执行</li>\n<li>通过使用<code>&lt;noscript&gt;</code>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持，则<code>&lt;noscript&gt;</code>元素中的任何内容都不会被渲染</li>\n</ul>\n","prev":{"title":"红宝书 - 第 3 章 语言基础","link":"readNotes/3"},"next":{"title":"红宝书 - 第1章 什么是JavaScript","link":"readNotes/1"},"plink":"https://shylees.github.io/readNotes/2/","toc":[{"id":"2.1-<script>元素","title":"2.1 &lt;script&gt;元素","index":"1","children":[{"id":"2.1.1-标签位置","title":"2.1.1 标签位置","index":"1.1"},{"id":"2.1.2-推迟执行脚本<font-color='red'>defer</font>","title":"2.1.2 推迟执行脚本defer","index":"1.2"},{"id":"2.1.3-异步执行脚本","title":"2.1.3 异步执行脚本","index":"1.3"},{"id":"2.1.4-动态加载脚本","title":"2.1.4 动态加载脚本","index":"1.4"},{"id":"2.1.5-xhtml中的变化","title":"2.1.5 XHTML中的变化","index":"1.5"},{"id":"2.1.6-废弃的语法","title":"2.1.6 废弃的语法","index":"1.6"}]},{"id":"2.2-行内代码和外部文件","title":"2.2 行内代码和外部文件","index":"2"},{"id":"2.3-文档模式","title":"2.3 文档模式","index":"3"},{"id":"2.4-<noscript>元素","title":"2.4 &lt;noscript&gt;元素","index":"4"},{"id":"2.5-小结","title":"2.5 小结","index":"5"}],"copyright":{"custom":"不许转载😡！！！"},"reading_time":"3657 words in 18 min"}