{"title":"导航流程 和 渲染流程","date":"2021-12-08T16:00:00.000Z","date_formatted":{"ll":"Dec 9, 2021","L":"12/09/2021","MM-DD":"12-09"},"link":"furtherNotes/further/01 导航和渲染流程","tags":["网络"],"categories":["furtherNotes"],"updated":"2021-12-08T16:00:00.000Z","content":"<h3 id=\"1.-详细流程\">1. 详细流程<a title=\"#1.-详细流程\" href=\"#1.-详细流程\"></a></h3>\n<h4 id=\"1.1-导航流程\">1.1 导航流程<a title=\"#1.1-导航流程\" href=\"#1.1-导航流程\"></a></h4>\n<ol>\n<li>\n<p><strong>用户输入</strong></p>\n<p>当用户在地址栏输入搜索关键字时，<strong>地址栏会判断输入的是搜索内容还是url</strong>。若是搜索内容，地址栏会根据浏览器的默认搜索引擎合成搜索关键字url；若是url，则会根据协议，合成完整的请求url.</p>\n</li>\n<li>\n<p><strong>资源请求过程</strong></p>\n<p>浏览器进程会通过 <strong>IPC</strong>进程间的通信 将<strong>请求url发送给网络进程</strong>，网络进程接收到请求后，会在此发起真正的url请求：</p>\n<p>首先<strong>查找本地缓存</strong>是否缓存了该资源，若有该资源的缓存，则将缓存返回；若无，则进行<strong>网络资源请求</strong>，进行<strong>DNS域名解析</strong>，获取请求域名的ip和端口号，若使用了 https 协议，还需要进行 <strong>TLS 连接</strong></p>\n<p>然后<strong>利用该 ip 与服务器进行 tcp 连接</strong>，连接后，浏览器开始<strong>构建请求头，请求行数据</strong>，并将与该域名有关的 <strong>cookie 附加到请求头</strong>中，将<strong>构建好的请求数据发送给服务器</strong></p>\n<p>服务器接收到后，根据请求数据，<strong>生成响应数据发送给网络进程</strong>，当网络进程接收到响应头和响应行数据后，开始<strong>解析响应头</strong>：</p>\n<p>​\t当返回的状态码为 <strong>301 / 302</strong> 时，说明服务器要让浏览器<strong>重定向</strong>到其他的url，网络进程会到 <strong>响应头的 location 读取重定向的地址</strong>，然后<strong>重新发送请求</strong>；若返回的是 200 ，则继续进行导航流程</p>\n<p>​\t浏览器根据 <strong>content-type</strong> 进行区分返回的类型，若返回的是 <strong>下载类型</strong>，则将其提交给<strong>浏览器的下载管理器</strong>，导航结束；若返回的是 html 页面则<strong>开始准备渲染进程</strong></p>\n</li>\n<li>\n<p>准备渲染进程</p>\n<p>默认请求下会开启一个<strong>新的</strong> 渲染进程，但是如果是开启同一个站点的页面时，会<strong>复用</strong>原来的渲染进程。此时还不能进行文档解析，文档还在网络进程中，得等到文档提交后</p>\n</li>\n<li>\n<p>提交文档阶段</p>\n<p>浏览器进程<strong>向渲染进程发送 提交文档</strong> — 响应数据 的消息，渲染进程接收到后，与网络进程<strong>创建一个可以传输数据的管道</strong>，当响应数据传输完成后，渲染进程<strong>向浏览器进程发送 确认提交文档</strong> 的消息，此时<strong>浏览器会更新页面状态</strong>，包括 地址栏url、历史状态、web页面</p>\n</li>\n<li>\n<p>渲染阶段</p>\n<p>渲染进程开始页面解析和子资源下载</p>\n</li>\n</ol>\n<h4 id=\"1.2-渲染流程\">1.2 渲染流程<a title=\"#1.2-渲染流程\" href=\"#1.2-渲染流程\"></a></h4>\n<ol>\n<li>构建 DOM 树 - dom：<strong>渲染进程</strong>将 <strong>HTML 内容</strong>转化为可以理解的 <strong>DOM 树结构</strong></li>\n<li>计算布局 - style：<strong>渲染引擎</strong>将 <strong>CSS 样式文件</strong>转化为浏览器可以理解的 <strong>stylesheets</strong>，并<strong>计算节点的样式</strong></li>\n<li>生成布局树 - layout：<strong>创建布局树</strong>，并<strong>计算元素的布局信息</strong></li>\n<li>分层 - layer：对布局树<strong>进行分层</strong>，并<strong>生成分层树</strong></li>\n<li>图层绘制 - paint：为每个图层<strong>生成绘制列表</strong>，并<strong>提交给合成线程</strong></li>\n<li>光栅化操作 - tiles raster：<strong>合成线程将图层分成图块</strong>，并在<strong>光栅化线程池中将图块生成位图</strong></li>\n<li>合成 - drawquad：合成进程将<strong>绘制图块命令</strong> drawquad 发送给浏览器进程</li>\n<li>显示 - display：浏览器进程根据 drawquad 消息<strong>合成页面，并显示</strong>在显示器上</li>\n</ol>\n<h3 id=\"2.-简便流程\">2. 简便流程<a title=\"#2.-简便流程\" href=\"#2.-简便流程\"></a></h3>\n<h4 id=\"2.1-导航流程\">2.1 导航流程<a title=\"#2.1-导航流程\" href=\"#2.1-导航流程\"></a></h4>\n<ul>\n<li>用户输入 url 并回车</li>\n<li>浏览器进程检查 url，组装协议，构成完整的 url</li>\n<li>浏览器进程通过进程间通信 IPC 把 url 请求发送给网络进程</li>\n<li>网络进程接收到url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li>\n<li>如果没有，网络进程向服务器发起 http 网络请求：\n<ul>\n<li>进行 DNS 解析，获取服务器 ip地址</li>\n<li>利用 ip 与 服务器建立 tcp 连接</li>\n<li>构建请求头信息</li>\n<li>发送请求头信息</li>\n<li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li>\n</ul>\n</li>\n<li>网络进行解析响应信息：\n<ul>\n<li>检查状态码，如果是 301 / 302，则需要重定向，从 location 读取地址，重新进行第四步，如果是 200 则继续处理请求</li>\n<li>200 响应处理：检查响应类型 Content - Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，如果是 html 则通知浏览器进程准备 渲染进程 准备渲染</li>\n</ul>\n</li>\n<li>准备渲染进程，浏览器进程检查当前 url 是否跟之前打开的渲染进程 根域名 是否相同。如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li>\n<li>传输数据，更新状态\n<ul>\n<li>渲染进程准备好后，浏览器向渲染进程发起 提交文档 消息，渲染进程 接收到消息和网络进程建立传输数据的管道</li>\n<li>渲染进程接收完数据后，向浏览器发送 确认提交</li>\n<li>浏览器进程接收到确认消息后，更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2.2-渲染流程\">2.2 渲染流程<a title=\"#2.2-渲染流程\" href=\"#2.2-渲染流程\"></a></h4>\n<ol>\n<li>构建 DOM 树</li>\n<li>计算布局</li>\n<li>生成布局树</li>\n<li>分层</li>\n<li>图层绘制</li>\n<li>光栅化操作</li>\n<li>合成</li>\n<li>显示</li>\n</ol>\n<h3 id=\"3.-相关概念-重排-重绘-合成\">3. 相关概念 重排 重绘 合成<a title=\"#3.-相关概念-重排-重绘-合成\" href=\"#3.-相关概念-重排-重绘-合成\"></a></h3>\n<h4 id=\"3.1-重排-—-更新了元素的几何属性\">3.1 重排 — 更新了元素的几何属性<a title=\"#3.1-重排-—-更新了元素的几何属性\" href=\"#3.1-重排-—-更新了元素的几何属性\"></a></h4>\n<img src=\"https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png\" style=\"zoom:67%;\" >\n<p>若 通过 js 或者 css 修改元素的几何位置，那么浏览器会<strong>触发重新布局</strong>，解析之后的一系列子阶段，这个过程是重排，重排需要更新完整的渲染流水线，所以开销最大。</p>\n<h4 id=\"3.2-重绘-—-更新元素的绘制属性\">3.2 重绘 — 更新元素的绘制属性<a title=\"#3.2-重绘-—-更新元素的绘制属性\" href=\"#3.2-重绘-—-更新元素的绘制属性\"></a></h4>\n<img src=\"https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png\" style=\"zoom:67%;\" >\n<p>若改变元素的背景颜色，那么布局阶段不会被执行，因为<strong>没有引起几何位置的交换，就直接进入了绘制阶段</strong>，然后执行之后的一系列子阶段，这个过程是重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率比重排高。</p>\n<h4 id=\"3.3-合成\">3.3 合成<a title=\"#3.3-合成\" href=\"#3.3-合成\"></a></h4>\n<img src=\"https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png\" style=\"zoom:67%;\" >\n<p>渲染引擎<strong>跳过布局和绘制，只执行后续的合成操作</strong>，这个过程是合成。eg 使用 css3的 transfrom 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。效率最高。</p>\n","prev":{"title":"v-if、v-for、v-show","link":"furtherNotes/further/05 v-if 与 v-show、v-for "},"next":{"title":"MVC MVP MVVM","link":"furtherNotes/further/02 组件中的data是函数"},"plink":"https://shylees.github.io/furtherNotes/further/01 导航和渲染流程/","toc":[{"id":"1.-详细流程","title":"1. 详细流程","index":"1"},{"id":"2.-简便流程","title":"2. 简便流程","index":"2"},{"id":"3.-相关概念-重排-重绘-合成","title":"3. 相关概念 重排 重绘 合成","index":"3"}],"copyright":{"custom":"不许转载😡！！！"},"reading_time":"1725 words in 9 min"}