{"title":"节流throttle、防抖debounce","date":"2021-11-13T16:00:00.000Z","date_formatted":{"ll":"Nov 14, 2021","L":"11/14/2021","MM-DD":"11-14"},"link":"furtherNotes/further/06 this指向 call bind apply","tags":["JavaScript"],"categories":["furtherNotes"],"updated":"2021-11-13T16:00:00.000Z","content":"<h2 id=\"call、bind、apply、this\">call、bind、apply、this<a title=\"#call、bind、apply、this\" href=\"#call、bind、apply、this\"></a></h2>\n<h3 id=\"1.-this-指向\">1. this 指向<a title=\"#1.-this-指向\" href=\"#1.-this-指向\"></a></h3>\n<p><strong><font color='red'>this 永远指向最后调用它的那个对象</font></strong>（执行时）</p>\n<p><strong>匿名函数的 this 永远指向 window</strong></p>\n<blockquote>\n<p>非严格模式 全局对象 window</p>\n<p>严格模式 全局对象是 undefined</p>\n</blockquote>\n<h3 id=\"2.-改变-this-指向\">2. 改变 this 指向<a title=\"#2.-改变-this-指向\" href=\"#2.-改变-this-指向\"></a></h3>\n<ul>\n<li>使用箭头函数</li>\n<li>函数内部使用 <code>_this = this</code></li>\n<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>\n<li><code>new</code> 实例化对象</li>\n</ul>\n<h4 id=\"2.1-箭头函数\">2.1 箭头函数<a title=\"#2.1-箭头函数\" href=\"#2.1-箭头函数\"></a></h4>\n<p><strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong></p>\n<p>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则 undefined。</p>\n<h4 id=\"2.2-_this-=-this\">2.2 _this = this<a title=\"#2.2-_this-=-this\" href=\"#2.2-_this-=-this\"></a></h4>\n<p>相当于把 this 的值 保存在另一个变量 _this</p>\n<h4 id=\"2.3-&lt;font-color='red'&gt;apply、call、bind&lt;/font&gt;\">2.3 <font color='red'>apply、call、bind</font><a title=\"#2.3-&lt;font-color='red'&gt;apply、call、bind&lt;/font&gt;\" href=\"#2.3-&lt;font-color='red'&gt;apply、call、bind&lt;/font&gt;\"></a></h4>\n<h5 id=\"2.3.1-apply\">2.3.1 apply<a title=\"#2.3.1-apply\" href=\"#2.3.1-apply\"></a></h5>\n<p>apply() 方法调用一个函数，其具有一个指定的 this 值，以及 作为一个数组（类数组对象）通过的参数</p>\n<p><code>func.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>\n<p>thisArg：在 func 函数运行时指定的 this 值。</p>\n<blockquote>\n<p>注：指定的 this 值并不一定是该函数执行时真正的 this 值，<strong>如果函数处于非严格模式下，则指定为 null 或 undefined 会自动指向全局对象，值为原始值的 this 会指向该原始值的自动包装对象。</strong></p>\n</blockquote>\n</li>\n<li>\n<p>argsArrays：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。</p>\n<blockquote>\n<p>如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"2.3.2-call\">2.3.2 call<a title=\"#2.3.2-call\" href=\"#2.3.2-call\"></a></h5>\n<p>call 与 apply 基本类似，只有传入参数的不同</p>\n<p><code>func.call(thisArg[, arg1[, arg2...]])</code></p>\n<ul>\n<li>call 接收的 若干个参数列表     <code>b.call(a, 1, 2)</code></li>\n<li>apply 接收 一个包含多个参数的数组  <code>b.apply(a, [1,2])</code></li>\n</ul>\n<h5 id=\"2.3.3-bind\">2.3.3 bind<a title=\"#2.3.3-bind\" href=\"#2.3.3-bind\"></a></h5>\n<p>bind() 方法<strong>创建一个新的函数</strong>，所以需要被调用。</p>\n<p><code>b.bind(a, 1, 2)()</code></p>\n<h4 id=\"2.4-函数调用\">2.4 函数调用<a title=\"#2.4-函数调用\" href=\"#2.4-函数调用\"></a></h4>\n<p>方法种类：</p>\n<ol>\n<li>\n<p>作为一个函数被调用</p>\n<blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123;...&#125;</span><br><span class=\"line\"><span class=\"title function_\">a</span>();</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li>\n<p>作为对象的方法被调用</p>\n<blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123; fn : <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123; ... &#125; &#125;;</span><br><span class=\"line\">a.<span class=\"title function_\">fn</span>();</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li>\n<p>使用构造函数调用函数</p>\n<blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"title function_\">func</span>(<span class=\"number\">18</span>)</span><br><span class=\"line\">a.<span class=\"property\">age</span>;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li>\n<p>作为函数方法调用函数（ call、apply）</p>\n<blockquote>\n<p>在 js 中，函数是对象。</p>\n<p>js 函数有自己的属性和方法，其中 call() 和 apply() 是预定义的函数方法，</p>\n<p>其可用于调用函数，两个方法的第一个参数必须是对象本事。</p>\n<p>在 严格模式，调用函数时 第一个参数会成为 this 的值，即使该参数不是一个对象</p>\n<p>在非严格模式，如果第一参数是 null / undefined，将使用全局对象替代</p>\n</blockquote>\n</li>\n</ol>\n","prev":{"title":"CDN内容分发网络","link":"furtherNotes/further/08 cdn"},"next":{"title":"触底事件","link":"furtherNotes/further/07 滚动条触底事件"},"plink":"https://shylees.github.io/furtherNotes/further/06 this指向 call bind apply/","toc":[{"id":"call、bind、apply、this","title":"call、bind、apply、this","index":"1","children":[{"id":"1.-this-指向","title":"1. this 指向","index":"1.1"},{"id":"2.-改变-this-指向","title":"2. 改变 this 指向","index":"1.2"}]}],"copyright":{"custom":"不许转载😡！！！"},"reading_time":"672 words in 3 min"}