---
title: 项目性能优化之缓存和懒加载
data: 2022/5/17 10:49
updata: 2022/5/18
tag:
  - vite
  - vue3
category:
  - workNotes
---

1. 在页面跳转的情况下，还是会有资源重新加载的情况，所以使用了 keep-alive

   1. 在 router.js 增加允许使用 keep-alive

      ```js
      import * as VueRouter from "vue-router";
      import Home from "./components/Home.vue";
      import List from "./components/List.vue";
      const router = VueRouter.createRouter({
        history: VueRouter.createWebHashHistory(),
        routes: [
          {
            path: "/",
            component: Home,
            meta: {
              name: "home",
              requiresAuth: true, //
              keepAlive: true, // 允许使用缓存
            },
          },
          {
            path: "/list/:category",
            component: List,
            meta: {
              name: "list",
              requiresAuth: true,
              keepAlive: true,
            },
          },
        ],
      });

      export default router;
      ```

   2. 在 app.js 使用 keep-alive

      ```html
      <template>
        <!-- vue3 写法 -->
        <router-view v-slot="{ Component }">
          <keep-alive v-if="$route.meta.keepAlive">
            <component :is="Component" />
          </keep-alive>
          <component v-if="!$route.meta.keepAlive" :is="Component" />
        </router-view>
        <!-- vue2 写法 -->
        <keep-alive>
          <router-view v-if="$route.meta.keepAlive"></router-view>
        </keep-alive>
        <router-view v-if="!$route.meta.keepAlive"></router-view>
      </template>
      ```

> <font color="red">如果第一个方法没有效果的话，那么要结合第二个看</font>

2. 路由回退中 router.go() 与 router.back()

   > https://blog.csdn.net/qq_42618566/article/details/91045282

   - `go()` 原页面表单中的内容会丢失
   - `back()` 原页面表单中的内容会保留
     - `back()` 后退
     - `back(0)` 刷新
     - `back(1)` 前进

3. 使用 keep-alive，第二次跳转页面后 不会 触发到原先在 onMounted 的 使页面到顶部，就会保持上个页面滚动条的滚动情况

   - 在 onActived 写一个与 onMounted 一样的逻辑
   - 页面第一次进入的时候，钩子触发的顺序是 created->mounted->activated，所以别在 mounted 和 activated 方法中写相同的逻辑代码

   ```js
   onActivated(() => {
     if (document.documentElement.scrollTop) {
       document.documentElement.scrollTop = 0;
     } else if (window.pageYOffset) {
       window.pageYOffset = 0;
     } else if (document.body.scrollTop) {
       document.body.scrollTop = 0;
     }
   });
   ```

4. 图片懒加载

   - 原理：将图片的 url 放在 `<img src="" :data-src="url" />` 的 data-src 里，当图片位于用户可视区时就将 url 放到 src 属性里
   - 判断图片是否位于可视区的方法:

     1. scroll 事件监听，用 scrollTop 等属性计算位置判断
     2. 使用 Intersection Observer
     3. Intersection Observer
        > https://juejin.cn/post/7080544007834730510 这篇文章挺全面的

   - 解决方法
     > 因为 项目是 vue3 + vant，所以使用 vant 自带的 `<van-image lazy-load></van-image>`

5. 图片懒加载的前提下，在右滑 or 轮播图切换，及非垂直滚动时做图片预加载，增加用户体验

   - 原理均类似于懒加载的原理，因为图片地址在 src 属性里时，页面就会自动加载图片资源了

   - **轮播**原理：在当前图片轮播时，就将下一张图片给加载出来，这部分是取消了懒加载啦
   - 实现:

   ```html
   <img class="w-100vw h-full relative" :src="realPic[index]" />
   ```

   ```js
   /**
    * 轮播图 图片懒加载
    *
    * imgs: 配置文件中的 banner 图片的链接
    * realPic: 真正页面使用的图片的链接
    * changePic: 轮播图 图片切换的时候触发函数，预先加载后一个图片
    */
   let imgs = [];
   for (let item of board_1) {
     imgs.push(item.banner);
   }
   let realPic = reactive([imgs[0], imgs[1]]);
   let count = ref(2);

   const changePic = limit(() => {
     let img = new Image();
     img.src = imgs[count.value];
     if (img.complete) {
       return;
     }
     if (count.value < imgs.length) {
       realPic.push(imgs[count.value]);
       count.value++;
     }
     // console.log(realPic);
   }, imgs.length - count.value);
   ```

   - **右滑**原理：所以在需要预加载的图片的 src 为 一个图片数组，初始情况下，数组为空，在懒加载的图片加载完成后就把该数组用 图片 src 填满
   - 实现

     ```html
     <template v-if="index < 4">
       <van-image
         :src="item.banner"
         class="w-full h-full"
         lazy-load
         @load="load(index)"
       ></van-image>
     </template>
     <template v-else>
       <van-image :src="preimg[index]" class="w-full h-full"></van-image>
     </template>
     ```

     ```js
     let preimg = reactive([]);

     const load = limit(() => {
       for (let i = 0; i < board_2.list.length; i++) {
         preimg.push(board_2.list[i].banner);
       }
     }, 1);
     ```

6. 计算首屏时间

   > https://blog.csdn.net/weixin_40599109/article/details/108622434

   ```js
   var t = performance.timing;
   var pageLoadTime = t.loadEventEnd - t.navigationStart;
   // 在这里pageLoadTime就是首屏时间
   ```

7. 在进入同一个有 keepalive 的组件，但是要展示不同数据时，就要合理修改 reactive 的值
