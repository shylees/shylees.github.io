---
title: vue风格指南
date: 2022/2/21 16:42
updated: 2022/2/21 17:37
comments:
tags:
 - vue
categories:
 - workNotes
layout:
permalink:
meta: true
---

## 优先级A

### 组件名为多个单词

这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。

### 组件数据必为函数
当在组件中使用 data property 的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。
> 当 data 的值是一个对象时，它会在这个组件的所有实例之间共享。当组件被重用时，因为每个组件的实例都引用了相同的数据对象，更改其中一个对象就是改变到其他使用到该组件的数据

我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了。

### prop 定义应该尽量详细

至少要指定数据类型
> 细致的 prop 定义有两个好处：
>
> 它们写明了组件的 API，所以很容易看懂组件的用法；
>
> 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。

### v-for 设置 key

以便维护内部组件及其子树的状态。

### 避免 v-if 和 v-for 一起使用

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。
所以当用在一个元素的时候，会先把所有元素遍历渲染出来，在看v-if哪些是不用渲染的

### 为组件样式设置作用域
顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的

> 这条规则只和单文件组件有关。你不一定要使用 scoped attribute。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。
>
> 不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped attribute。
>
> 这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。


Vue 使用 _ 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 _update) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。
对于 $ 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于私有 property 并不合适。
不过，我们推荐把这两个前缀结合为 $_，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。

##  优先级B
### 组件文件
### 单文件组件文件名称

单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。
> 单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。

### 基础组件名
应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V

### 单例组件名 The
只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性

这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。

### 紧密耦合的组件名
和父组件紧密耦合的子组件应该以父组件名作为前缀命名

### 自闭合组件
组件名中的单词顺序在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。

自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。

不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。
组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。

~~~html
<!-- 在单文件组件、字符串模板和 JSX 中 -->
<MyComponent/>
<!-- 在 DOM 模板中 -->
<my-component></my-component>
~~~

### 模版中的组件名大小写
对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。

>PascalCase 相比 kebab-case 有一些优势：

> 编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。
> `<MyComponent>` 视觉上比 `<my-component>` 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。
> 如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。
> 不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。

~~~html
<!-- 在单文件组件和字符串模板中 -->
<MyComponent/>
<!-- 在 DOM 模板中 -->
<my-component></my-component>

<!-- or 在所有地方 -->
<my-component></my-component>
~~~

### js/jsx 中组件名大小写
JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。

~~~js
Vue.component('MyComponent', {
  // ...
})
Vue.component('my-component', {
  // ...
})
import MyComponent from './MyComponent.vue'
export default {
  name: 'MyComponent',
  // ...
}
~~~

### 完整单词组件名
组件名应该倾向于完整单词而不是缩写。

编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。


### prop名 大小写 
在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。

**我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。**


### 多 attr 元素
多个 attribute 的元素应该分多行撰写，每个 attribute 一行。

在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。


### 模版中简单表达式
组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。

复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。

### 简单计算属性
应该把复杂计算属性分割为尽可能多的更简单的 property。

> 易于测试、易于阅读、更好的“拥抱变化”

### 带引号的 attr 值
非空 HTML attribute 值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。

在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里不写空格，导致可读性变差。

### 指令缩写
指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。

## 优先级 C
### 组件/实例的选项顺序
推荐
1. 副作用 - 触发组件外的影响
    + el
2. 全局感知 - 要求组件外的知识
    + name
    + parent
3. 组件类型 - 更改组件类型
    + functional
4. 模版修改器 - 改变模版的编译方式
    + delimiters
    + comments
5. 模版依赖 - 模版内使用的资源
    + components
    + directives
    + filters
6. 组合 - 向选项里合并 property
    + extends
    + mixins
7. 接口 - 组件接口
    + inheritAttrs
    + model
    + props/propsData
8. 本地状态 - 本地响应式 property
    + data
    + computed
9. 事件 - 通过响应式事件触发的回调函数
    + watch
    + 生命周期钩子
10. 非响应式的 property - 不依赖响应式系统的 property
    + methods
11. 渲染 - 组件输出声明描述
    + template/render
    + renderError

### 元素 attr 顺序
1. 定义 - 提供组件的选项
    + is
2. 列表渲染
    + v-for
3. 条件渲染
    + v-if
    + v-else-if
    + v-else
    + v-show
    + v-cloak
4. 渲染方式
    + v-pre
    + v-once
5. 全局感知 - 需要超越组件的知识
    + id
6. 唯一的attr
    + ref
    + key
7. 双向绑定
    + v-model
8. 其他 attr - 所有普通的绑定或未绑定的 attr
9. 事件
    + v-on
10. 内容
    + v-html
    + v-text

### 组件/实例选项中的空行
你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。

当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。

### 单文件组件的顶级元素的顺序
单文件组件应该总是让 `<script>`、`<template>` 和 `<style>` 标签的顺序保持一致。且 `<style>` 要放在最后，因为另外两个标签至少要有一个。

## 优先级D 谨慎使用

### 不在 v-if/v-else-if/v-else ➕ key
如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 <div> 元素)。

默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。


### scoped 避免出现元素选择器
在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。


### 隐性父子组件通信
应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。

一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。

问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。

### 非 flux 的全局状态管理
应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。

通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。

Vuex 是 Vue 的官方类 flux 实现，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 Vue DevTools 支持)。

