---
title: 红宝书 - 3.4数据类型
date: 2021/2/9
updated: 2021/2/15
comments:
tags:
 - js
categories:
 - readNotes
layout:
permalink:
meta: true
---

ECMAScript有6种简单数据类型/原始类型、一种复杂数据类型；

简单数据类型：Undefined、Null、Boolean、Number、String、Symbol。（Symbol是es6新增的）

复杂数据类型：Object（对象）



### 3.4.1 typeof操作符

因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。对一个值使用typeof操作符会返回下列字符串之一：

* `undefined` 值未定义
* `boolean` 值为布尔值
* `string` 值为字符串
* `number` 值为数据
* `object`  值为对象/null（因为null被认为是一个对空对象的引用）
* `function` 值为函数
* `symbol` 值为符号

~~~js
let message = "some string";
console.log(typeof message); //"string"
console.log(typeof (message)); //"string"
console.log(typeof 95)  //"number"

//typeof是一个操作符而不是函数，所以不需要参数 但也可以使用参数
~~~



### 3.4.2 Undefined类型

#### 	1.Undefined类型只有一个值⇨undefined

未经初始化的变量，默认初始值为undefined。

<font color='red'>所以给变量显示以undefined来初始化是不必要的</font>

####  	2.未初始化和未定义变量的区别：

~~~js
let message;

console.log(message);  //undefined
console.log(age);      //报错
//非严格模式下：对未声明的变量调用delete不会报错，但这个操作无用，严格模式下：会报错

console.log(typeof message);  //undefined
console.log(typeof age);      //undefined
//虽然这两个变量存在根本性差异，但他们都无法执行实际操作
~~~

建议在声明变量的同时进行初始化，这样当typeof返回undefined时，就知道是给定变量未声明。

#### 	3.用更简洁的方式检测undefined

[^假值]: 在JavaScript中，`false`、`null`、`0`、`“”`、`undefined`、`NaN`被称为假值

undefined是一个[^假值]，所以如果需要也可以用更简洁的方式检测。因为有好几个假值，所以一定要明确自己想检测的就是undefined这个字面值而不仅仅是假值。

~~~ js
let message;
if(message){}  //不会执行
if(!message){}  //会执行
if(age){}      //会报错
~~~





### 3.4.3 Null类型

#### 	1.Null类型只有一个值⇨null

逻辑上讲，null表示一个空对象指针，这也是 “typeof null” 会返回 ”object” 的原因：

~~~js
let car = null;
console.log(typeof car); //"object"
~~~

<font color='red'>在定义将来要保存对象值的变量时，建议使用null来初始化</font>，不使用其他值，这样只要检测这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用

#### 	2.null == undefined

undefined值是由null值派生的，所以ECMA-262将其定义为表面上相等：

~~~js
console.log(null == undefined);  //true
console.log(null === undefined); //false
~~~

但用途是完全不一样的：永远不必显示地将变量值设为undefined，但只要变量保存对象，而当时又无对象可保存，就要用null来填充。这样就可以保持null是空对象指针的语义，并进一步与undefined区分开

#### 	3.用更简洁的的方式检测null

null是一个[^假值]，所以如果需要也可以用更简洁的方式检测。因为有好几个假值，所以一定要明确自己想检测的就是null这个字面值而不仅仅是假值。

~~~js
let message = null;
let age;
if(message){}  //不执行
if(!message){} //执行
if(age){}      //不执行
if(!age){}     //执行
~~~



### 3.4.4 Boolean类型

#### 	1.Boolean类型有两个字面值⇨true、false

> 这两个布尔值不同于数值，因此 true != 1，false != 0。

<font color='red'>布尔值字面量 true 和 false 区分大小写，因此 True 和 False（及其他大小混写形式） 是有效的标识符</font>

#### 	2.所有其他 ECMAScript 类型的值都有相应布尔值的等价形式

要将一个其 他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：

~~~js
let message = "Hello world";
let messageAsBoolean = Boolean(message); //true
~~~

#### 	3.不同类型与布尔值之间的转换规则

| 数据类型  | 转换为true             | 转换为false    |
| --------- | ---------------------- | -------------- |
| Boolean   | true                   | false          |
| String    | 非空字符串             | “”（空字符串） |
| Number    | 非零数值（包括无穷值） | 0、NaN         |
| Object    | 任意对象               | null           |
| Undefined |                        | undefined      |

### 3.4.5 Number类型

Number 类型使用 IEEE 754 格式表示整 数和浮点值（在某些语言中也叫双精度值）。

#### 	1.不同的数值类型有不同的数值字面量格式

##### 			最基本的数值字面量格式是十进制整数，

直接写出来即可

~~~js
let intNum = 55;  
~~~

##### 			也可以用八进制（以 8 为基数）字面量表示

第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7））。如果字面量中包含的数字超出了应 有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数：

~~~js
let octalNum1 = 070; // 八进制的 56
let octalNum2 = 079; // 无效的八进制值，当成 79 处理
let octalNum3 = 08; // 无效的八进制值，当成 8 处理

//八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误
~~~

##### 			或十六进制（以 16 为基数）字面量表示

必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0~9 以 及 A~F）。十六进制数字中的字母大小写均可。

~~~js
let hexNum1 = 0xA; // 十六进制 10
let hexNum2 = 0x1f; // 十六进制 31 
~~~

> 使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值

#### 	2.浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。

> 虽然小数点前面不是必须有整数，但推荐加上

~~~js
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐
~~~

因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。在小数点后面没有数字或者是`.0`的情况下，数值就会变成整数。

~~~js
let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理
~~~

#### 	3.科学计数法

ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大 写或小写的字母 e，再加上一个要乘的 10 的多少次幂。比如：

~~~js
let floatNum = 3.125e7; // 等于 31250000 
let folatNum = 3e-17;  // 等于 0.000 000 000 000 000 03
~~~

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。

例如，<font color='red'>0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。</font>由于这种微小的舍入错误，导致很难测试特定的浮点值。

~~~js
if (a + b == 0.3) { // 别这么干！
 console.log("You got 0.3.");
} 
//这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。
~~~

#### 	4.值的范围

由于内存的限制，ECMAScript 可表示的

最小数值保存在 `Number.MIN_VALUE` 中， 5e-324；

最大数值保存在 `Number.MAX_VALUE` 中，1.797 693 134 862 315 7e+308。

如果数值超出了 JavaScript 可表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无 穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正 无穷大）表示。如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。

> 使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获 取正、负 Infinity。没错，这两个属性包含的值分别就是-Infinity 和 Infinity。

#### 	5.NaN

有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。

* 0 / 非0 ： 报错
* 0 / 0     ：NaN
* 非0 / 0 ：Infinity / - Infinity

NaN有几个独特的特性：

* 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）
* NaN 不等于包括 NaN 在内的任何值

~~~js
console.log(NaN == NaN); // false 
~~~

ECMAScript 提供了` isNaN()`函数。该函数接收一个参数，可以是任意数据类型，判断参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的 值可以直接转换成数值，如字符串"10"或布尔值。

~~~js
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1
~~~

#### 	6.数值转换

有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()`和 `parseFloat()`

`Number()`是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

##### 		Number()函数基于如下规则执行转换：

* `布尔值`，`true ` ⇨ 1，`false` ⇨ 0
* `数值`，直接返回
* `null` ⇨ 0
* `undefined` ⇨ `NaN`
* `字符串`，应用以下规则：
  * 如果包含数值字符，包括数值字符前面带加、减号的情况，⇨ 一个十进制数值
  * 如果包含有效的浮点值格式如"1.1"，⇨ 相应的浮点值
  * 如果包含有效的十六进制格式如"0xf"，⇨ 与该十六进制值对应的十进制整数值
  * 如果是空字符串（不包含字符）⇨ 0
  * 如果包含除上述情况之外的其他字符，则返回 NaN
* `对象`，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。















