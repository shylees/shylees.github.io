---
title: 节流throttle、防抖debounce 
date: 2021/11/13
updated: 2021/11/13
comments:
tags:
 - js
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 参考链接：
>
> https://www.jianshu.com/p/566c66aafa22
>
> https://juejin.cn/post/6959161295358656520


### 1. 概念

#### 1.1 应用场景

高频触发事件时，可能会频繁执行DOM操作，资源加载等，导致UI停顿甚至浏览器崩溃。

- window对象频繁的 `onresize`，`onscroll`等事件
- 拖拽的 mousemove 事件
- 射击游戏的 mousedown，keydown 事件
- 文字输入，自动完成的 keyup 事件

#### 1.2 解决方案

对于 window 和 resize 事件，实际需求大多为停止改变大于 n 毫秒后执行后续处理；而其他事件大多数的需求是以一定的频率执行后续处理。

>  针对这两种需求出现了 debounce 和 throttle 两种方式



#### 1.3 节流

高频事件触发，**但在 n 秒<font color='red'>内</font>只会执行一次**，所以节流会稀释函数的执行频率

> 比如mouseover，resize这种事件，每当有变化的时候，就会触发一次函数，这样很浪费资源。就比如一个持续流水的水龙头，水龙头开到最大的时候很浪费水资源，将水龙头开得小一点，让他每隔200毫秒流出一滴水，这样能源源不断的流出水而又不浪费。
>
> 常见例子：即时查询、不断点击、监听滚动事件触底事件



#### 1.4 防抖

**触发高频事件<font color='red'>后 </font>n 秒内函数只会执行一次**，如果n秒内高频事件再次被触发，则重新计算时间

> A和B说话，A一直bbbbbb，当A持续说了一段时间的话后停止讲话，过了10秒之后，我们判定A讲完了，B开始回答A的话；如果10秒内A又继续讲话，那么我们判定A没讲完，B不响应，等A再次停止后，我们再次计算停止的时间，如果超过10秒B响应，如果没有则B不响应。
>
> 常见例子：点击按钮、拍照、下拉触底加载下一页等、search 搜索联想、window 触发 resize



#### 1.5 防抖和节流的区别

+ 函数防抖和函数节流都是防止某一时间内频繁触发。
+ 函数防抖是在指定时间只执行一次，而函数节流是每到指定间隔时间执行一次。
+ 函数防抖是将几次操作合并为一次操作进行，函数节流使得一定时间内只触发一次函数。



### 2. 实现

~~~html
<body>
  <div> 无处理输入:<input type="text" class="non"></div>
  <div> 立即防抖处理输入:<input type="text" class="imdebounce"></div>
  <div> 非立即防抖处理输入:<input type="text" class="unimdebounce"></div>
  <div> 整合防抖处理输入:<input type="text" class="bothdebounce"></div>
  <div> 时间戳节流处理输入:<input type="text" class="stampthrottle"></div>
  <div> 定时器节流处理输入:<input type="text" class="timeoutthrottle"></div>
</body>
<script>
  function pri(obj) {
    console.log(obj.value + " " + new Date());
  }
  const non = document.querySelector('.non');
  non.addEventListener('keyup', e => {
    pri(e.target)
  })
   ...
</script>
~~~



#### 2.1 节流

> 使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。

+ **定时器：** 函数触发是在时间段内结束的时候
+ **时间戳：** 函数触发是在时间段内开始的时候

##### 2.1.1 定时器节流

~~~js
 const timenode = document.querySelector('.timeoutthrottle');
  // 定时器
  function timethrottle(func, delay) {
    let canrun;
    return function (arguments) {
      if (!canrun) {
        canrun = setTimeout(() => {
          func.call(this, arguments)
          canrun = null;
        }, delay)
      }
    }
  }

  const time = timethrottle(pri, 500);
  timenode.addEventListener('keyup', e => {
    time(e.target)
  })
~~~



##### 2.1.2 时间戳节流

~~~js
  const stampnode = document.querySelector('.stampthrottle');
  // 时间戳
  function stampthrottle(func, delay) {
    let pre = 0;    //上一次记录时间
    return function (arguments) {
      let now = new Date();
      if (now - pre >= delay) {
        func.call(this, arguments); //当前时间 - 上次时间 > 延时时间
        pre = now;
      }
    }
  }

  const stamp = stampthrottle(pri, 500);
  stampnode.addEventListener('keyup', e => {
    stamp(e.target)
  })
~~~



#### 2.2 防抖

> 将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。

+ **非立即防抖：**指的是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

+ **立即防抖：** 指的是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

  简而言之，立即执行版就是第一次事件触发后会立即执行，至少执行一次事件。

##### 2.2.1 立即防抖

~~~js
  const imnode = document.querySelector('.imdebounce');
  // 立即防抖
  // 指的是触发事件后函数会立即执行，n 秒内不触发事件才能继续执行函数的效果
  function imdebounce(func, delay) {
    let timeout;
    return function (arguments) {

      if (timeout) {
        clearTimeout(timeout);
      }
      let flag = !timeout;
      timeout = setTimeout(function () {
        // func.call(this, arguments);
        timeout = null;
      }, delay)
      if (flag) {
        func.call(this, arguments)
      }
    }
  }
  const im = imdebounce(pri, 500);
  imnode.addEventListener('keyup', e => {
    // ; debugger
    // imdebounce(pri, 500)(e.target)   //就不可以为什么
    
    im(e.target);
  })
~~~



##### 2.2.2 非立即防抖

~~~js
  const unimnode = document.querySelector('.unimdebounce');
  // 非立即防抖
  // 高频触发时 如果 触发后 delay 没有再触发 就执行函数
  function unimdebounce(func, delay) {
    let timeout;
    return function (arguments) {
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        func.call(this, arguments);
        timeout = null;
      }, delay)
    }
  }
  const un = unimdebounce(pri, 500);
  unimnode.addEventListener('keyup', e => {
    un(e.target)
  })
~~~



##### 2.2.3 结合版

~~~js

  const bothnode = document.querySelector('.bothdebounce');
  // 结合版
  function debounce(func, delay = 500, immediate = true) {
    let timeout;
    return function (arguments) {
      if (timeout) {
        clearTimeout(timeout);
      }
      if (immediate) {
        // 立即执行
        let flag = !timeout;
        timeout = setTimeout(() => {
          timeout = null;
        }, delay)
        if (flag) {
          func.call(this, arguments)
        }
      } else {
        // 非立即执行
        timeout = setTimeout(() => {
          func.call(this, arguments);
          timeout = null;
        }, delay)
      }
    }
  }

  const both = debounce(pri, 500, false);
  bothnode.addEventListener('keyup', e => {
    both(e.target)
  })
~~~

