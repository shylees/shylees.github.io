---
title: 浏览器存储详细版
date: 2021/11/20
updated: 2021/11/20
comments:
tags:
 - html5
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 由cwenjoy 项目中使用到的 localStorage 引申出来的
>
> https://www.jianshu.com/p/072e17112759


## 浏览器存储

### 常见的浏览器数据存储方案

1. Cookie
2. Web 存储 ：localStorage 和 sessionStorage
3. IndexedDB



#### 1. Cookie

##### 1.1 简介

Cookie 又称 HTTP Cookie，最初在客户端用于存储会话信息，从底层看，其作为 HTTP 协议的一种扩展实现，Cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输，因此在服务器端脚本可以读写存储的 cookie 值，因此 Cookie 通常用户存储一些通用的数据。

##### 1.2 优点

相比于其他的存储方式， Cookie 的兼容性很好

##### 1.3 缺点

+ **存储量小**，在不同的浏览器上基本都是 4kb 大小
+ **影响性能**，Cookie 会由浏览器作为请求头发送，当 Cookie 存储信息过多时，会影响特定域的资源获取效率，增加文件传输的负载
+ **只能存储字符串**
+ **安全问题**，存储在 Cookie 的任何数据可以被他人访问，因此不能再 Cookie 中存储重要信息
+ 因为第三方滥用 Cookie，所以很多人再浏览网页时会禁用 Cookie，所以得测试用户是否支持 Cookie

##### 1.4 操作

基本操作：读取、写入、删除。

cookie 中所有的名字和值都是经过 URI 编码的，所以必须使用 decodeURICompoent来进行解码才能得到 cookie 的值。

~~~js
var CookieUtil = {
    // get可根据cookie的名字获取相应的值
    get: function() {
        const cookieName = encodeURIcOMPONET(name) + "=",
               cookieStart = document.cookie.indexOf(cookieName),
               cookieValue = null
        if(cookieStart > -1) {
            const cookieEnd = document.cookie.indexOf(";", cookieStart)
            if(cookieEnd == -1) {
                cookieEnd = document.cookie.length
            }
            cookieValue = decodeURICompoent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))  
        }
        return cookieValue
    }
    // set设置一个cookie
    set: function(name, value, expires, path, domain, secure) {
        var cookieText = encodeURIComponet(name)+"="+encodeURIComponet(value)
        if(expires instanceof Date) {
            cookieText += "; expires=" + expires.toGMTString()
        }
        if(path) {
            cookieText += ";path=" + path
        }
        if(domain) {
            cookieText += "; domain" + domain
        }
        if(secure) {
            cookieText += "; secure"
        }
        document.cookie = cookieText
    }
    // 删除已有的cookie
    unset: function(name, path, domain, secure) {
        this.set(name, "", new Date(0), path, domain, secure)
    }
}
~~~



#### 2. Web 存储

web 存储机制最初作为 HTML5 的一部分被定义成 API 的形式，但由于其本身的独特性于一些原因被剥离出来，成为一个独立的标准。其包括 localStorage 对象 和 sessionStorage 对象。

其产生的主要原因：

1. 希望有一种再 cookie 之外存储会话数据的途径
2. 希望有一种存储大量可以跨会话存在的数据的机制

> 最初的 web 存储规范中包含了 sessionStorage 和 globalStorage 两种对象的定义，在支持这两个对象的浏览器中都是以 windows 对象属性的形式存在的



#### 3. localStorage 

##### 3.1 简介

localStorage 对象作为 **持久保存客户端数据**的方案 取代了 globalStorage。

从功能上讲，可以通过 localStorage 在浏览器存储键值对数据，相比于 cookie，提供了更为直观的 API，在安全上相对好一点。

虽然 localStorage 只能存储字符串，但也可以存储字符串化的 JSON 数据，因此相比 cookie ，localStorage 能存储更复杂的数据。

##### 3.2 优点

+ 提供了简单明了的 API 来进行操作
+ 更加安全
+ 可存储的数据量更大

##### 3.3 语法

~~~js
// 使用方法存储数据
localStorage.setItem("name", "Srtian")
// 使用属性存储数据
localStorage.say = "Hello world"
// 使用方法读取数据
const name = localStorage.getItem("name")
// 使用属性读取数据
const say = localStorage.say
// 删除数据
localStorage.removeItem("name")
~~~

需要传输其他格式的数据时，我们就需要将这些数据全部转换为字符串格式，然后再进行存储

获取值时将其转化回来

~~~js
const user = {name:"Srtian", age: 22}
localStorage.setItem("user", JSON.stringify(user))

var age = JSON.parse(localStorage.user)
~~~



##### 3.4 存储数据的有效期 与 作用域

通过localStorage存储的数据时永久性的，除非我们使用removeItem来删除或者用户通过设置浏览器配置来删除，负责数据会一直保留在用户的电脑上，永不过期。



localStorage的作用域限定在文档源级别的（意思就是同源的才能共享），同源的文档间会共享localStorage的数据，他们可以互相读取对方的数据，甚至有时会覆盖对方的数据。当然，localStorage的作用域同样也受浏览器的限制。



#### 4. sessionStorage

##### 4.1 简介

与 localStorage 相似，不同之处在于 localStorage里面存储的数据没有过期时间设置，而Session Storage只存储当前会话页的数据，且只有当用户关闭当前会话页或浏览器时，数据才会被清除。

##### 4.2 语法

~~~js
// 保存数据到sessionStorage
sessionStorage.setItem('name', 'Srtian');

// 从sessionStorage获取数据
var data = sessionStorage.getItem('name');

// 从sessionStorage删除保存的数据
sessionStorage.removeItem('name');

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
~~~



#### 5. indexedDB

##### 5.1 简述

由HTML5所提供的一种本地存储，用于在浏览器中储存较大数据结构的 Web API，并提供索引功能以实现高性能查找。它一般用于保存大量用户数据并要求数据之间有搜索需要的场景，当网络断开时，用户就可以做一些离线的操作。它较之SQL更为方便，不需要写一些特定的语法对数据进行操作，数据格式是JSON。

##### 5.2 语法

1. **创建数据库 并 指定数据库版本号**

   ~~~js
   // 注意数据库的版本号只能是整数
   const request = IndexedDB.open(databasename, version)
   ~~~

2. **生成处理函数**

   ~~~js
   request.onerror = function() {
       // 创建数据库失败时的回调函数
   }
   request.onsuccess = function() {
       // 创建数据库成功时的回调函数
   }
   request.onupgradeneededd = function(e) {
        // 当数据库改变时的回调函数   唯一可以修改数据库结构的地方  可以创建和删除对象存储空间以及构建和删除索引
   }
   ~~~

3. **建立对象存储空间**

   ~~~js
   // 对象存储空间仅调用createObjectStore()就可以创建。这个方法使用存储空间的名称，和一个对象参数。即便这个参数对象是可选的，它还是非常重要的，因为它可以让我们定义重要的可选属性和完善你希望创建的对象存储空间的类型。
   request.onupgradeneeded = function(event) {
       const db = event.target.result
       const objectStore = db.createObjectStore('name', { keyPath:'id' })
   }
   ~~~

4. **操作数据**

   + 添加数据

     ~~~js
     addData: function(db, storename, data) {
         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
         for(let i = 0; i < data.length; i++) {
     !        const request = store.add(data[i])
             request.onerror = function() {
                 console.error('添加数据失败')
             }
             request.onsuccess = function() {
                 console.log('添加数据成功')
             }
         }
     }
     ~~~

   + 修改数据

     ~~~js
     putData: function(db, storename, data) {
         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
         for(let i = 0; i < data.length; i++) {
     !        const request = store.put(data[i])
             request.onerror = function() {
                 console.error('修改数据失败')
             }
             request.onsuccess = function() {
                 console.log('修改数据成功')
             }
         }
     }
     ~~~

   + 获取数据

     ~~~js
     getDataByKey: function(db, storename, key) {
         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
     !    const request = store.get(key)
         request.onerror = function() {
             console.error('获取数据失败')
         }
         request.onsuccess = function(e) {
             const result = e.target.result
             console.log(result)
         }
     }
     ~~~

   + 删除数据

     ~~~js
     deleteDate: function(db, storename, key) {
         const store = store = db.transaction(storename, 'readwrite').objectStore(storename)
     !    store.delete(key)
         console.log('已删除存储空间' + storename + '中的' + key + '纪录')
     }
     ~~~

   + 关闭数据库

     ~~~js
     db.close
     ~~~

##### 5.3 优点 与其他相比

+ 拥有更大的存储空间
+ 能够处理更为复杂和结构化的数据
+ 拥有更多的交互控制
+ 每个 database 中可以拥有多个 database 和 table

##### 5.4 局限性

+ **存储空间限制**：一个单独的数据库项目大小没有限制，但可能会限制每个 IndexedDB 数据库的大小，不同浏览器有不同限制；
+ **兼容性问题**：兼容性比前面提及的存储方案差
+ **受同源策略限制**：把存储空间绑定到了创建它的站点的源，所以不能被其他源访问













