---
title: 滚轮事件
date: 2021/11/13
updated: 2021/11/13
comments:
tags:
 - js
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 参考链接：
> 
> https://developer.mozilla.org/zh-CN/docs/Web/API/WheelEvent
>
> https://juejin.cn/post/6974018969690734628
>
> https://blog.csdn.net/TXW6666/article/details/106456045
>
> https://blog.csdn.net/lijingshan34/article/details/88350456


## 滚轮事件 wheelEvent

### 1. 介绍滚轮事件

wheelEvent 接口表示用户滚动鼠标滚轮 或 类似输入设备时触发的事件。

+  **该事件为标准规定的滚轮事件接口。**早期的浏览器实现过[`MouseWheelEvent`](https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/WheelEvent)和[`MouseScrollEvent`](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseScrollEvent)两种滚轮事件接口，但这两种接口皆非标准，加之各浏览器间对其兼容性极差。

  > onmousewheel（firefox不支持）  DOMMouseScroll（只有firefox支持）
  >
  > 因而开发者应使用该标准事件接口取代这两个非标准接口。

+ **不要混淆 `wheel` 事件和 `scroll` 事件：**`wheel` 事件的默认动作取决于浏览器实现。

  因此 `wheel` 事件不一定会触发 `scroll (en-US)` 事件。即便滚轮事件引发了文档内容的滚动行为，也不表示 `wheel` 事件中的 `delta*` 值恰好反映文档内容的滚动方向。因此，不要依赖 `delta*` 属性获知文档内容的滚动方向。可在文档内容滚动事件（`scroll`）中监视target的[`scrollLeft`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollLeft)和[`scrollTop`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop)的变化以推断滚动方向。

  

### 2. wheel 的事件对象的属性

#### 2.1 触发事件

~~~js
(function(){
    document.addEventListener('wheel',(e){
    	console.log(e)                          
    })
})()
~~~



#### 2.2 <font color="red">事件对象对比</font>

在谷歌(左)和火狐打印的结果为：

+ **鼠标滚轮事件对象**

  1. **页面往下( 滚轮往下滚)**  

     <img src='./img/wheel down1.png' style="zoom:67%;float:left" >

     <img src='./img/wheel down2.jpg' style="zoom:70%;float:left" >

  2. **页面往上( 滚轮往下滚 )**

     <img src='./img/wheel up1.jpg' style="zoom:70%;float:left" >

     <img src='./img/wheel up2.jpg' style="zoom:70%;float:left" >

  

+ **触摸板滑动事件对象**

  1. **页面往下( 触摸板向上滑动 )**

     <img src="./img/chumoban_down1.jpg" style="zoom:70%; float:left;" >

     <img src="./img/chumoban_down2.jpg" style="zoom:70%; float:left" >

  2. **页面往上( 触摸板往下滑动 )**

     <img src="./img/chumoban_up1.jpg" style="zoom:70%; float:left;" >

     <img src="./img/chumoban_up2.jpg" style="zoom:70%; float:left;" >


总结：**deltalY**：页面向下：> 0 ；页面向上：< 0；

​           **wheelDelta | wheelDeltaY**：向下 : < 0；向上：>0



~~~js
window.addEventListener("wheel", function (e) {
    let evt = e || window.event;   //后面为了兼容 ie
    evt.preventDefault();          //阻止浏览器默认行为u
    if (evt.deltaY > 0 || evt.wheelDelta < 0) { ... } 
    else if (evt.deltaY < 0 || evt.wheelDelta > 0) { ... }
  },{ passive:false });
~~~



### 3. passive: false

**!`{ passive:false }`要加上**，不然滚轮滚动页面的时候会报：`Unable to preventDefault inside passive event listener`

**原因：**Chorme56+开始为了让页面滚动变得更为流畅，在 window、document 和 body 上注册的 touchstart和 touchmove 事件处理函数，会默认为是 passive: true。

> 之前：当浏览器首先对默认的事件进行响应的时候，要检查一下是否进行了默认事件的取消。这样就在响应滑动操作之前有那么一丝丝的耽误时间。
>
> 现在：google就决定默认取消了对这个事件的检查，默认时间就取消了。直接执行滑动操作。这样就更加的顺滑了。

浏览器忽略默认事件的preventDefault(), 要是手动阻止会弹出一个警告, 告诉你阻止不了!!!

**解决：**

1. `window.addEventListener('touchmove', func, { passive: false })`

2. `* { touch-action:none; }`

   > touch-action是css中的一个属性，用于设置触摸屏用户如何操纵元素的区域（例如浏览器内置的缩放功能）



###  4. 项目不足

在项目实现的时候，没办法兼容触摸板滑动，因为触摸板每次滑动的时候会触发多次滚轮事件，就会使得页面从第一个板块滑倒页面底部。

解决方案：节流防抖？

**A：**

1. 节流，页面会有一点延迟，不太友好

2. 防抖，鼠标滚动事件不会多次触发，还是处理得蛮好的，但是触摸板事件没办法像滚轮事件那样使用，好像并没有阻止到默认事件。























