---
title: 模块化历程
date: 2021/11/10
updated: 2021/11/10
comments:
tags:
 - js
 - es6
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 项目涉及到的模块化
>
> [参考的主要链接](https://juejin.cn/post/6844903744518389768)

# 前端模块化：CommonJS、AMD、CMD、ES6

## 1.模块化的理解

+ 将一个复杂的程序依据一定的规则(规范)封装成几个块（文件），并进行组合在一起
+ 块的内部数据与实现是私有的，只是想外部暴露一些接口（方法）与外部其他模块通信

## 2.模块化进化过程

#### 2.1 全局 function 模式

+ 编码：将不同的功能封装成不同的全局函数
+ 问题：污染全局命名空间，容易引擎命名冲突或数据不安全，模块成员之间看不出关系

#### 2.2 namespace 模式

+ 编码：将不同功能封装在对象属性里

+ 作用：解决了全局变量，解决命名冲突

+ 问题：数据不安全，会暴露所有模块成员，内部成员状态可以被外部改写

  ~~~js
  let myModule = {
      name:'qsh',
      foo() {
          console.log(`foo ${ this.data }`);
      }
  }
  myModule.data = 'qrc'
  myModule.foo()  // foo qrc
  ~~~

#### 2.3 IIFE 模式：匿名函数子调用（闭包）

+ 编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露成员

+ 作用：数据私有，外部只能通过暴露的方法操作

+ 问题：如果当前模块怎么依赖另一个模块

  ~~~html
  <script src='module.js'></script>
  <script>
  	myModule.foo() // foo qsh
  </script>
  ~~~

  ~~~js
  // module.js
  (function(window){
      let data = 'qsh';
      function(){
          console.log(`foo ${ this.data }`)
      }
      window.myModule = { foo }
  })
  ~~~

#### 2.4 IIFE 模式增强：引入依赖

+ 现在模块化的基石

+ 好处：保证了模块的独立性，使得模块之间的依赖关系变得明显

  ~~~js
  // module.js
  (function(window,$){
      let data = 'qsh';
      function(){
          console.log(`foo ${ this.data }`);
          $('body').css('background','red');
      }
      window.myModule = { foo }
  })(window,jQuery)
  ~~~

  ~~~html
    <!-- 引入的js必须有一定顺序 -->
    <script src="jquery-1.10.1.js"></script>
    <script src="module.js"></script>
    <script>
      myModule.foo() // foo qsh
    </script>
  ~~~



## 3.模块化的好处

+ 避免命名冲突，减少命名空间污染
+ 更好分离，按需加载
+ 更高复用性
+ 高可维护性



## 4. 引入多个`<script>`后出现的问题

+ 请求过多

  > 要依赖多个模块，这就会发送多个请求，导致请求过多

+ 依赖模糊

  > 不知道具体的依赖关系，有可能因此导致加载先后顺序出错

+ 难以维护

  > 以上原因导致了难维护性。

  模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上问题，这些问题可以通过模块化规范来解决。



## 5.模块化规范

### 5.1 CommonJS

##### 5.1.1 概述

Node 应用由模块组成，采用CommonJS 模块规范，每个文件就是一个模块，有自己的作用域。

**加载模块是同步的，只有加载完成，才能执行后面的操作。**

**在服务器端，模块的加载时运行时同步加载的；**

**在浏览器端，模块需要提前编译打包处理。**



##### 5.1.2 特点

+ 所有代码都运行在模块作用域，不会污染全局作用域
+ 模块可以多次加载，但只会在第一次加载时运行一次，然后运行结果会被缓存，再此加载的时候，就直接读取缓存结果。若要让模块再次加载，必须清除缓存。
+ 模块的加载顺序，按照其在代码出现的顺序



##### 5.1.3 基本语法

+ 导出：`module.exports = value` 或 `exports.xxx = value`

+ 导入：`require(xxx)`

  > if 第三方模块 xxx 为模块名；if 自定义模块 xxx 为文件路径



##### 5.1.4 问题

**Q:** **CommonJS 暴露的模块是什么？**

**A:** CommonJS 规范规定，每个模块内部，module 代表当前模块，module.exports 是对外的接口。**加载某个模块，其实是加载该模块的 module.exports 属性**。



**Q:** require 命令用来干什么？

**A:** 用于**加载模块文件**。其基本功能是，**读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错。**



##### 5.1.5 模块的加载机制

输入的是被输出的值的拷贝。模块内部的变化就影响不到这个输出的值。

> 其实是 **按值传递(原始类型) 和 [按共享传递(引用类型)](./es 中函数的参数都是按值传递的.md)**

这与ES6模块化有重大差异。



##### 5.1.6 服务器端实现

1. 下载 node.js
2. 创建项目结构 npm init （package name 不能有中文名）
3. 下载第三方模块 npm install uniq –save
4. 定义模块代码
5. 运行 js 代码 node xxx.js



##### 5.1.7 浏览器端实现

1. 创建项目结构 dist + src + index.html + package.json
2. 下载 browserify 全局 -g 局部 –save-dev
3. 定义模块代码 借助 browserify 打包 xxx.js 文件打包编译，（直接导入html 会报错）
4. 导报处理js  根目录运行 browserify js/src/app.js -o js/dist/bundle.js
5. index.html 引入` <script type="text/javascript" src="js/dist/bundle.js"></script>`



### 5.2 AMD

##### 5.2.1 概述

CommonJS 加载模块是同步的，只有加载完成，才能执行后面的操作。

**AMD 则是非同步加载模块，允许指定回调函数。**



##### 5.2.2 特点

+ 定义方法非常清晰
+ 不会污染全局变量
+ 清楚显示依赖关系
+ 可用于浏览器环境，允许非同步加载模块，指定回调函数，可以根据动态加载模块



##### 5.2.3 适用情况

因为 **node.js** 主要用于服务器编程，模块文件已经存在本地硬盘，所以加载比较块，不用考虑非同步加载的方式，所以 **CommonJS 比较适用**。

如果是浏览器环境，要从服务器端加载模块，就必须采用非同步，因此**浏览器一般采用 AMD**。

> AMD 比 CommonJS 在浏览器端实现 早



##### 5.2.4 基本语法

+ 导出：

  ~~~js
  // 定义没有依赖的模块
  define(function(){
      return 模块
  })
  
  // 定义有依赖的模块
  define(['module1','module2'],function(m1,m2){
      return 模块
  })
  ~~~

+ 导入：

  ~~~js
  require(['module1','module2'],function(m1,m2){
      ...
  })
  ~~~



##### 5.2.5 使用require.js

> RequireJS 是一个工具库，主要用于客户端的模块管理。其遵守 AMD 规范。**其基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。**

AMD 在浏览器实现的步骤：

1. 下载引入 require.js  [官网](http://www.requirejs.cn/) [github](https://github.com/requirejs/requirejs) 

   将 require.js 导入项目： js/libs/require.js

2. 创建项目结构  js > libs + module + main.js      < + index.html

3. 定义 require.js 的模块代码

   ~~~js
   // data.js
   define(function(){
       function getmsg(){
           return 'data'
       } 
       return { getmsg };
   })
   
   //alterdata.js
   define(['data','jquery',function(data,$){
       function showmsg(){
           alter(data.getmsg());
           $('body').css('background', 'green')
       }
       return { showmsg };
   }])
   
   //main.js
   (function(){
       require.config({
           baseUrl:'js/',
           path:{      // 映射
               alterdata:'./modules/alterdata',
               data:'./module/data',
               jquery:'./libs/jquery-1.10.1'   //jQuery 报错
           }
       })
       require(['alterdata'],function(alterdata){
           alterdata.showmsg()
       })
   })()
   ~~~

   ~~~html
   <script data-main="js/main" src="js/libs/require.js"></script>
   ~~~

   

### 5.3 CMD

##### 5.3.1 基本概念

**CMD 专门用于浏览器端，模块异步加载，使用时才会加载执行**。其整合了 CommonJS 和 AMD 的特点。在 Sea.js 种，所有 JavaScript 模块都遵循 CMD 规范。



##### 5.3.2 基本语法

+ 导出：

  ~~~js
  // 定义没有依赖的模块
  define(function(require, exports, module){
      exports.xxx = val;
      module.exports = val;
  })
  
  // 定义有依赖的模块
  define(function(require, exports, module){
      // 同步引入依赖模块
      const module2 = require('./module2')
      // 异步引入依赖模块
      require.async('./module3',(m3) => {
          
      })
      
      exports.xxx = val;
  })
  ~~~

+ 导入：

  ~~~js
  define(function(require){
      let m1 = require('./module1');
      m1.show()
  })
  ~~~



##### 5.3.3 sea.js 使用

1. 下载sea.js 并引入 js/libs/sea.js  [官网](seajs.org/)  [github](github.com/seajs/seajs)

2. 创建项目结构  js > libs + module < +  index.html

3. 定义sea.js 模块代码

4. 引入index.html 

   ~~~html
   <script type="text/javascript" src="js/libs/sea.js"></script>
   <script type="text/javascript">
     seajs.use('./js/modules/main')
   </script>
   ~~~

   

### 5.4 ES6

##### 5.4.1 基本概念

ES6 模块的设计思想是**尽量的静态化**，使得**编译时就能确定模块的依赖关系，以及输入和输出的变量**。CommonJS 和 AMD 都只能在**运行时**确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。



##### 5.4.2 ES6 模块化语法

+ 导出：export { xxx }  / export default xxx
+ 导入：import { xxx } from …   /  import xxx from …



##### 5.4.3 <font color='red'>ES6 模块与 CommonJS 模块的差异</font>

1. **CommonJS 输出的是值的拷贝；ES6 Module 输出的是值的引用**

   > ES6 Module 的运行机制与 CommonJS 不一样。**ES6 Module 是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。**

2. **CommonJS 是运行时加载；ES6 Module 时编译时输出接口**

   > 因为 CommonJS 加载的是一个对象，即 module.exports 属性，该对象只有在脚本运行完才会生成。
   >
   > 而 ES6 Module 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成



##### 5.4.4  ES6-Babel-Browserify 使用

使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包js

1. 定义package.json 文件
2. 安装babel-cil，babel-preset-es2015 和 browserify
3. 定义 .babelrc 文件 
4. 定义模块代码
5. 导入index.html



## 6. 总结

+ CommonJS规范主要用于**服务端编程**，加载模块是**同步**的，有缓存，这并不适合在浏览器环境，因为**同步意味着阻塞加载，浏览器资源是异步加载的**，因此有了AMD CMD解决方案。
+ AMD规范在**浏览器环境中异步加载模块**，而且可以**并行加载**多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
+ CMD规范与AMD规范很相似，都用于**浏览器编程**，**依赖就近，延迟执行**，可以很容易在Node.js中运行。不过，依赖　SPM 打包，模块的加载逻辑偏重。
+ **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。











