---
title: 判断数据类型
date: 2021/12/15
updated: 2021/12/15
comments:
tags:
 - js
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

>
> 通过 手写深拷贝 的 数据的类型判断 方法有点感兴趣
>
> https://juejin.cn/post/6992848107004231687
>
> 有问题：https://juejin.cn/post/7004778999226302477
>
> 原理：https://juejin.cn/post/6844904081803182087


## 4种 判断数据类型的方式

### 0. 数据类型

数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt、Object

> Symbol 是 es6 中引入的一种 原始数据 类型，表示独一无二的值
>
> BigInt 是 es2020 引入的用于解决 js 中数字只能到 53 个二进制位 的问题

1. 基本数据类型

   Undefined、Null、Boolean、Number、String、Symbol（es6）、BigInt（es2020）

2. 引用数据类型

   Object：Array、Function、Date、RegExp、Error、Arguments 等

### 1. typeof

#### 1.1 使用

typeof 基本类型 返回相应的类型，除了 null 返回 object

typeof 引用类型 返回 object ，除了 函数 返回 function

~~~js
typeof '5'             // string
typeof 5               // number
typeof null            // object  ！
typeof undefined       // undefined
typeof true            // boolean
typeof Symbol('5')     // symbol
typeof 5n              // bigint
typeof new Object();   // object
typeof new Function(); // function ！
~~~

**Q:** typeof 作用于未定义的变量，会报错吗？

A: 不会报错，返回"undefined"

**Q:** typeof Number(1) 的返回值？

A: "number"。

> typeof Nmuber(1)  // ‘number’
>
> typeof String(‘1’)    // ‘string’
>
> typeof Array(1,2) === typeof new Array(1,2)  // ‘object’
>
> Number 和 String 作为普通函数调用的时候，把参数转化为相应的原始数据类型，也就是**类似于做一个强制类型转换的操作**，而不是默认当做构造函数调用。注意和 Array 区分，Array(...) 等价于 new Array(...)

**Q:** typeof new Number(1) 的返回值

A: ‘object’

#### 1.2 原理

不同对象**在底层都表示为二进制**，在 Javascript 中二进制低三位存储其类型信息

+ 000：对象

+ 001：整数

+ 010：浮点数

+ 100：字符串

+ 110：布尔值

  null：全0

### 2. instanceof

#### 2.1 使用

+ 是用来判断 变量的原型链上是否有构造函数的 prototype 属性（两个对象是否属于原型链的关系），不一定能获取对象的具体类型

+ 不适用判断原始类型的值，只能用于判断对象是否从属关系

> instanceof 的结果并不一定是可靠的，因为在 **ECMAScript7** 规范中可以通 过自定义 Symbol.hasInstance 方法来覆盖默认行为

~~~js
3 instanceof Number // false 
'3' instanceof String // false
true instanceof Boolean // false

[] instanceof Array; // true
[] instanceof Object; // true

var date = new Date()   date instanceof Date // true 
var number = new Number()  number instanceof Number // true 
var string = new String()  string instanceof String // true 

// 空对象{} 的判断
let obj1 = {}  obj1 instanceof Object  // true
let obj2 = Object.create(null)  obj2 instanceof Object  // false
let obj3 = Object.create({})  obj3 instanceof Object // true
~~~

#### 2.2 原理

`instanceof`  判断 变量的**原型链上是否有构造函数的 prototype 属性**

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/5/170a84f72826fa18~tplv-t2oaga2asx-watermark.awebp">



### 3. __proto\_\_.constructor

原理：每一个实例对象都可以通过 constructor 来访问它的构造函数，其实也是根据原型链的原理来的

> 由于undefined和null是无效的对象，因此是没有constructor属性的,这两个值不能用这种方法判断.、

~~~js
'5'.__proto__.constructor === String // true  String 应该是类型
[5].__proto__.constructor === Array // true 

let date = new Date(); date.__proto__.constructor === 	Date // true
undefined.__proto__.constructor // Cannot read property '__proto__' of undefined
null.__proto__.constructor // Cannot read property '__proto__' of undefined
~~~



### 4. Object.prototype.toString

+ 返回对象的类型字符串，隐藏可以用来判断一个值的类型
+ 因为实例对象可能会自定义 toString 方法，会覆盖 Object.prototype.toString，所以在使用时，最好加上 call
+ 所有数据类型都可以用这个方法进行检测，且十分精准

~~~js
Object.prototype.toString.call('5') // "[object String]"  字符串
Object.prototype.toString.call(5) // [object Number]
Object.prototype.toString.call([5]) // [object Array]
Object.prototype.toString.call(true) // [object Boolean]
Object.prototype.toString.call(undefined) // [object Undefined]
Object.prototype.toString.call(null) // [object Null]
Object.prototype.toString.call(new Function()); // [object Function]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(new RegExp()); // [object RegExp]
Object.prototype.toString.call(new Error()); // [object Error]
~~~



### 5. 总结

+ typeof 适合基本类型和 function 类型的检测，无法判断 null 和 object
+ instanceof 适合自定义对象，也可以用来检测原生对象，在不同的 iframe 和 window 间检测时失效，还需要注意 Object.create(null) 对象的问题
+ constructor 基本能判断所有类型，除了 null 和 undefined，但是 constructor 容易被修改，也不能跨 iframe 使用
+ toString 能判断所有类型，可将其封装为全能的 DateType() 判断所有数据类型