---
title: 深拷贝浅拷贝
date: 2021/12/14
updated: 2021/12/14
comments:
tags:
 - js
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 面试专栏：https://vue3js.cn/interview/JavaScript/copy.html#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8
>
> 深拷贝浅拷贝：https://juejin.cn/post/7013603488315736072
>
> messagechannel：https://www.jianshu.com/p/4f07ef18b5d7
>
> 深拷贝函数：https://www.cnblogs.com/wangyong1997/p/13577725.html

## 深拷贝 与 浅拷贝

在日常生	产环境当中，使用完美方案—`lodash.cloneDeep`，面试问起来的话，重点使用递归实现，JSON、Object.assgin、MessageChannel都可以作为补充。

### 1. 数据类型存储

+ 基本类型：栈内存

  > number、null、undefined、boolean、string、symbol、bigint

+ 引用类型：堆内存，引用数据类型的变量是一个指向堆内存中事对象的引用，存在栈中

  > function、object、array、date、regexp、map、set



+ 浅拷贝：基本类型，拷贝数据；引用类型，拷贝内存地址；即共用引用类型数据。

  > `=` 从第一层的引用类型就是共享内存地址
  >
  > 浅拷贝是**拷贝一层**，深层次的引用类型则共享内存地址
  >
  > **修改第一层的基本数据类型，是不会修改到其他对象的；**
  >
  > **但是修改第一层引用类型下面的值时，全都是在操作一个内存地址的值**

+ 深拷贝：基本类型 和 引用类型都拷贝数据，不存在共用数据的现象

  > 修改任何对象的属性都不会改变另一个对象的属性



前提为拷贝类型为引用类型的情况下：

- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址
- 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址



### 2. 浅拷贝

1. `Object.assign(target,source[,source2])`  // Object Array
2. 扩展运算符 `...`  // Object Array
3. `Array.prototype.slice --- arrO.slice(0)`  // Array
4. `Array.prototype.concat --- arrO.concat()` // Array

~~~js
let obj = {
    a:'aaa1',
    b:{
        b1:'bbb1'
    }
}
let arr = [0,[10,11]]

// =
let obj2 = obj;
obj2.a = 'aaa2'; // obj2.a === obj.a = 'aaa2'

// assign
let obj3 = Object.assign({},obj);
obj3.a = 'aaa3';     // obj3.a = 'aaa3'  obj.a = 'aaa2'  // obj.a 基本类型
obj3.b.b1 = 'bbb3';  // obj3.b === obj.b = { b1: 'bbb3'}  // obj 跟着变化

// ...
let obj4 = {...obj};
obj4.a = 'aaa4';    // obj.a = 'aaa2' obj4.a = 'aaa4'
obj4.b.b1 = 'bbb4'; // obj.b.b1 === obj4.b.b1 = 'bbb4'

// slice
let arr2 = arr.slice(0);
arr2[0] = 20;    // arr2[0] = 20  arr[0] = 0
arr2[1][1] = 22; // arr[1] === arr2[1] = [11,22];

//concat
let arr3 = arr.concat();
~~~



### 3. 深拷贝

1. `JSON.parse(JSON.stringify())`
2. `Jquery.extend()`
3. `_.cloneDeep()`
4. `MessageChannel`
5. 手写循环递归



~~~js
// JSON.parse(JSON.stringify(obj))
let obj5 = JSON.parse(JSON.stringify(obj))
obj5.a = 'aaa5';     // obj5.a = 'aaa5' obj.a = 'aaa2'
obj5.b.b1 = 'bbb5';  // obj5.b.b1 = 'bbb5'  obj.b.b1 = 'bbb4'

// jquery.extend
const $ = require('jquery');
let obj6 = $.extend(true, {}, obj);

// _.cloneDeep
const _ = require('lodash');
let obj7 = _.cloneDeep(obj)
~~~

JSON.parse 的问题：

+ 会忽略 `undefined` 和 `symbol`
+ 不可以对 `Function ` 进行拷贝，因为 JSON 格式字符串不支持 Function，在序列化时会自动删除
+ 不支持循环对象的拷贝（对象的某个属性的值为其自己）
+ 不能正确处理new Date
+ 不能处理正则
+ 不能处理 new Error()

但遇到的深拷贝的场景很少，而且 99% 用 JSON.stringify 就可以解决

##### 3. ! `_.cloneDeep`

> 这是最最最最完美的深拷贝的方式，它已经将会出现问题的各种情况都考虑在内了，所以在日常项目开发当中，建议使用这种成熟的解决方案.
>
> 其实lodash解决循环引用的方式，就是用一个栈记录所有被拷贝的引用值，如果再次碰到同样的引用值的时候，不会再去拷贝一遍，而是利用之前已经拷贝好的。



##### 4.`MessageChannel`

MessageChannel 允许我们创建一个新的消息通道，并通过其 postMessage 发送数据，ommessage 接收数据

> 简单来说，`MessageChannel`创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过`postMessage`发送数据，而一个端口只要绑定了`onmessage`回调方法，就可以接收从另一个端口传过来的数据。

###### 4.1 使用 MessageChannel

~~~js
const channel = new MessageChannel();   // 创建了一个管道
var port1 = channel.port1;
var port2 = channel.port2;             // 获取实例的两个端口 只读
port1.onmessage = function(event) {
    console.log("port1收的数据：" + event.data);
}
port2.onmessage = function(event) {
    console.log("port2收的数据：" + event.data);
}
port1.postMessage("port1发的数据");  // port2收的数据：port1发的数据
port2.postMessage("port2发的数据");
~~~



###### 4.2 使用其进行深拷贝

MessageChannel 的 postMessage 传递数据也是 深拷贝的，与 web worker 的postMessage 一样，而且可以**拷贝 undefined 和 循环引用的对象**

但拷贝**有函数的对象时，会报错**。而且是在 **异步**的

~~~js
function deepcopy(obj){
    return new Promise((resolve) => {
        const {port1, port2} = new MessageChannel();
        // port2将port1 传过来的 obj 返回出去 obj此时就是深拷贝后的
        port2.onmessage = event => resolve(event.data); 
        port1.postMessage(obj);
    })
}
// copy 就是传出来的 深拷贝后的值
deepcopy(obj).then((copy) => {
    let copyobj = copy;  // copyobj 已经不等于 obj了 copy == copyobj ！= obj
})
~~~



##### 5. 手写循环递归

> 判断一个对象的字段是否引用了这个对象或这个对象的任意父级，如果引用了父级，那么就直接返回同级的新对象，反之，进行递归的那套流程。

~~~js
function deepCopy(obj, cache = new WeakMap()){
    if(Object.prototypr.toString.call(obj) === '[object Function]'){
        return new Function('return ' + obj.toString()).call(this);
    }
    if(obj == null || typeof obj !== 'object'){  
        // == null 包含了 null 和 undefined
        // typeof 除 function 外的引用类型都是 object
        // 所以 不是funciton又不是其他引用类型的话 就是基本数据类型了
        return obj;
    }
    // 以下是对 除 function 外的引用类型的处理
    if(Object.prototype.toString.call(obj) === '[object Date]'){
        return new Date(obj);
    }
    if(Objcet.prototype.toString.call(obj) === '[object RegExp]'){
        return new RegExp(obj);
    }
    if(Objcet.prototype.toString.call(obj) === '[object Error]'){
        return new Error(obj);
    }
    if(cache.get(obj)){
        return cache.get(obj);
    }
    let copyObj = Object.prototype.toString.call(obj) === '[object Array]' ? [] : {};
    // let copyObj = Array.isArray(obj) ? [] : {};
    // let copyObj = new obj.constructor();
    cache.set(obj,copyObj); // 此时 copyObj 还没有数据，下面会进行添加
    for(const key in obj){
    	if(obj.hasOwnPrototype(key)){  // 用for in为什么还要判断key是否为obj的自身属性
// 辉哥说 因为 for in 遍历的是 可迭代的变量，当在其原型链上时，也是可迭代的，但是却不是本身属性
            // 递归拷贝
            copyObj[key] = deepCopy(obj[key],cache)
        }
    }
    return copyObj;
}
~~~



