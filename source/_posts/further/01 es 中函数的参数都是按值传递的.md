---
title: 展开讲讲红宝书提到的“es中...按值传递”
date: 2021/11/11
updated: 2021/11/11
comments:
tags:
 - js
categories:
 - furtherNotes
layout:
permalink:
meta: true
---

> 第4版红宝书 4.1 提到 ECMAScript 中所有函数的值都是按值传递的 



### 按值传递

>  原始值 很好理解，就是将值拷贝一份 成为参数，这个参数与外界原来的值，就没有任何联系了

这里展开讲讲引用值



~~~js
let person = { 
    age: 18 
}
function add (per) {
    per.age++;
    console.log(per);
}

add(person);        // { age: 19 }
console.log(person) // { age: 19 }
~~~

 这个例子的输出结果显然 就不符合 **按值传递**，是不是意味着 应该是 **按引用传递**呢？我们再看一个例子：

~~~js
let person = {
    age: 18
}
function add(per){
    per = 20;
    console.log(per);
}

add(person);         //20
console.log(person); // { age: 18 }
~~~

这个例子的输出结果就有点 **按值传递** 了。



那为什么会有这两种这么迷惑的结果呢？这就引出了第三种值的传递方式：**按共享传递**。

顺便回顾下我们上面有说到的两种值的传递方式：

+ **按值传递**：把值复制给另一个变量
+ **按引用传递**：把引用对象传给另一个变量，想到于两个变量指向同一个引用

+ **按共享传递**：把对象的引用副本传递给另一个变量



**所以，就上面的例子来说，修改 `per.age` 会直接修改到原值，但直接修改 `per` 并不会修改原值。**



其实拷贝副本也算是一种值的拷贝，所以红宝书直接认为是按值传递也没有说不过去。



总结：若参数为 原始类型 就是  按值传递，若参数为 引用类型 就是 按共享传递



