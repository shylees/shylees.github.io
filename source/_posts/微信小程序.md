---
title: 微信小程序
date: 2021/8/3
updated: 2021/8/6
comments:
tags:
 - 小程序
categories:
 - learningNotes
layout:
permalink:
meta: true
---

## 1.软件介绍

### 1.1 下载

[官网](https://mp.weixin.qq.com/cgi-bin/wx)

注册 –> 登录 -> 注册appID -> [下载](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)微信开发者工具 -> 安装 -> 创建项目

[介绍](https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html)开发者工具的工具栏

### 1.2 配置文件介绍

#### 1.2.1 app.json 全局配置

+ page : 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 `.json`, `.js`, `.wxml`, `.wxss` 四个文件进行处理。

  未指定 `entryPagePath` 时，数组的第一项代表小程序的初始页面（首页）。

  **小程序中新增/减少页面，都需要对 pages 数组进行修改。**

+ window : 用于设置小程序的状态栏、导航条、标题、窗口背景色。

+ tabBar : 通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

~~~js
{
 "page":[
     "pages/index/index",
     "pages/log/log"
 ],
 "window": {
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",             //下拉加载的位置
    "backgroundTextStyle": "light"            //下拉加载的logo
  }
}
~~~



#### 1.2.2 index.json 页面配置

每一个小程序页面也可以使用 `.json` 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 `app.json` 的 `window` 中相同的配置项。

~~~js
{
  "usingComponents": {},
    //app.json 的 window 配置一样
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",             //下拉加载的位置
    "backgroundTextStyle": "light"            //下拉加载的logo
}
~~~

> 可以手动关闭下拉刷新窗口  if 没用调用 也不会报错
>
>index.js
>
>wx.stopPullDownRefresh();



#### 1.2.3 sitemap.json 配置

用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 `sitemap.json` ，则默认为所有页面都允许被索引；



## 2.模板语法

### 2.0 wxml 标签

> vscode使用“微信小程序开发”插件

1. `<text> == <span> ` 
2. `<view> == <div>`
3. `<checkbox> 复选框`



### 2.1 数据绑定

~~~js
//demo01.js

Page({
    //页面的初始数据
    data:{
        msg:'hello mina',
        isChecked:false
    }
})
~~~

~~~html
<!-- demo01.wxml -->

<!-- 1.在文本中使用 -->
<view> {{ msg }} </view>

<!-- 2.在属性中使用 -->
<view data-msg="{{ msg }}">自定义属性</view>

<!-- 3.使用bool充当属性时 “ 和 { 之间不要留空格 否则会导致识别失败 -->
<checkbox checked="{{isCheck}}"></checkbox>
~~~



### 2.2 运算

运算 => 表达式

可以在 `{{ }}` 中加入表达式

> 表达式 => 简单 运算 数字运算 拼接 逻辑运算
>
> ​               数字加减 字符串拼接 三元表达式
>
> 语句 => 复杂代码段 
>
> ​           if else   switch   do while   for



~~~html
<view>{{ 1+1 }}</view>       2
<view>{{ '1'+'1' }}</view>   11
<view>{{ 10%2===1 ? '奇数' : '偶数' }}</view> 偶数
~~~



### 2.3 列表渲染

#### 2.3.1 列表循环

1. wx:for=“{{ 数组或者对象 }}” 

   wx:for-item=“循环项name”  

   wx:for-index=“循环项索引”

2. wx:key=“唯一的值”  -> 为了提高列表性能 

   wx:key=“*this”        -> 表示你的数组是一个普通数组[]  *this表示循环项

3. 出现循环嵌套 以下绑定名称 不能重名

   wx:for-item="item" wx:for-index="index"

4. 默认情况下（一层循环）不用写 

   wx:for-item="item" wx:for-index="index"

#### 2.3.2 对象循环

1. wx:for=“`{{` 数组或者对象 `}}`” 

   wx:for-item=“对象的值”  

   wx:for-index=“对象的键”

2. 最好把 item index 的名称 修改下 item,index => value,key

3. wx:key=“对象的任何一个属性”

~~~js
//demo01.js
Page({
 data: {
     ...
    person: {
      id: 123,
      name: '富婆',
      height: '166',
    },
    list: [
      { id: 0, name: 'zero' },
      { id: 1, name: 'one' },
      { id: 2, name: 'two' }
    ]

  },
})

~~~

~~~html
  ----列表循环 wx:for-------
  
<view wx:for="{{list}}" wx:for-item="item" wx:for-index="index" wx:key="id">
  索引:{{index}}
  ----
  值:{{item.name}}
</view>

  ----对象循环 wx:for-------

<view wx:for="{{person}}" wx:for-item="value" wx:for-index="key" wx:key="id">
  属性:{{key}}
  ----
  值:{{value}}
</view>
~~~



#### 2.3.3 block 标签

相当于一个占位符

写代码的时候 会有 

页面运行后 这个标签直接不存在

~~~html
<block wx:for="{{person}}" wx:for-item="value" wx:for-index="key" wx:key="id">
  属性:{{key}}
  ----
  值:{{value}}
</view>

==>

属性:id ---- 值:123 属性:name ---- 值:富婆 属性:height ---- 值:166
~~~



### 2.4 条件渲染

1. wx:if=“`{{`true/false`}}`”    <font color='red'>使用添加删除元素</font>

2. 三选一

   wx:if=“`{{}}`”

   wx:elif=“`{{}}`”

   wx:else 

3. hidden     <font color='red'>使用display:none</font>

   在标签直接加入

   hidden=“`{{`true`}}`”

> if 不是频繁切换显示 使用 wx:if    使用添加删除元素
>
> if 频繁切换 使用hidden                使用display:none       所以使用hidden 不要用 display属性

~~~html
 <view>
  <view>条件渲染</view>
  <view wx:if="{{true}}">if -> true</view>
  
  <view wx:if="{{false}}">if</view>
  <view wx:elif="{{true}}">elif</view>
  <view wx:else>else</view>
   
   <view hidden>hidden1</view>
   <view hidden="{{true}}">hidden -> true</view>
   <view hidden="{{false}}">hidden -> false</view>
</view>
~~~



## 3.事件绑定

### 3.1 input双向绑定

1. 给input标签绑定input事件 绑定关键子 bindinput
2. 通过事件源e 获取输入框的值 e.detail.value
3. 使用 this.setData({ num:e.detail.value }) 绑定数据的值

### 3.2 button 点击事件

1. 点击事件 绑定关键字 bindtap
2. 不能在事件中 (1) 传参  要使用data-自定义属性传 
3. 使用事件源e 中获取dataset中的值 获取参数

~~~html
<input type="text" bindinput="handleInput" />
<button bindtap="handletap" data-num="{{1}}" >+</button>
<button bindtap="handletap" data-num="{{-1}}" >-</button>
<view>
  {{num}}
</view>
~~~

~~~js
Page({
  data: {
    num: 0
  },
  //输入框input事件的执行逻辑
  handleInput(e) {
    this.setData({
      num: e.detail.value
    })
  },
  //加减按钮的事件
  handletap(e) {
    this.setData({
      num: this.data.num + e.currentTarget.dataset.num
    })
  },
})
~~~



## 4. wxss样式

### 4.1 尺寸单位

rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。

> if 在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

> if 存在这样一个需求 设计稿 page 宽 ， 存在一个元素 100px 宽  要求页面适配
>
> page px = 750rpx  =>  1px = 750rpx / page px  => 100px = 750rpx * 100 / page

在wxss里写的时候 可以 使用calc

+ 可以使用 + - * / ，% px em rem 
+ 可以混合使用各种单位
+ 用 + - 时 其前后必有空格，* / 可无 但建议保留
+ 数字与单位之间不留空格



### 4.2 样式导入

使用`@import`语句可以导入外联样式表，`@import`后跟需要导入的外联样式表的**相对路径**，用`;`表示语句结束。

~~~css
@import "..wxss" 
~~~



### 4.3 选择器

除了不支持 * 全局选择 ，其他都与 css 一样



### 4.4 使用less

1. 下载插件 easy less

2. 在vs code 的设置中加入如下配置

~~~js
"less.compile":{
    "outExt":".wxss"
}
~~~

3. 在编写样式的地方，建立.less文件 正常编辑即可



## 5. 常见组件

常用的布局组件

view，text，rich-text，button，image，navigator，icon，swiper，radio，checkbox，等



### 5.1 view 

[官方](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)属性 

| 属性                   | 类型    | 默认值 | 必填 | 说明                                                         | 最低版本                                                     |
| :--------------------- | :------ | :----- | :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| hover-class            | string  | none   | 否   | 指定按下去的样式类。当 `hover-class="none"` 时，没有点击态效果 | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-stop-propagation | boolean | false  | 否   | 指定是否阻止本节点的祖先节点出现点击态                       | [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-start-time       | number  | 50     | 否   | 按住后多久出现点击态，单位毫秒                               | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hover-stay-time        | number  | 400    | 否   | 手指松开后点击态保留时间，单位毫秒                           | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |



### 5.2 text 

+ 文本标签
+ 只能嵌套text
+ 只有这个标签 可以长按文字复制   selectable
+ 可以对空格 回车 进行编码            decode      (if没有的话 像`&nbsp;`这种符号会原样显示)

> decode可以解析的有`&nbsp; &gt; &amp; &apos; &ensp; &emsp;`



### 5.3 image

+ 因为后期打包上线 不能超过2兆

​       所以会把很多 静态资源放在网络上 [软件：图床 将本地图片 放到网络上]

+ image组件默认宽度320px、高度240px
+ 可以直接设置懒加载

属性：

| 属性      | 类型    | 默认值      | 必填 | 说明                                                   | 最低版本                                                     |
| :-------- | :------ | :---------- | :--- | :----------------------------------------------------- | :----------------------------------------------------------- |
| src       | string  |             | 否   | 图片资源地址                                           | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| mode      | string  | scaleToFill | 否   | 图片裁剪、缩放的模式                                   | [1.0.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| lazy-load       | boolean        | false                  | 否        | 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 | [1.5.0 ](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

mode属性的值：

+ scaleToFill ： 默认，不保持宽高比，使图片的宽高完全拉伸至填满 
+ aspectFit ：常用，保持宽高比，使图片的长边能完全显示出来
+ aspectFill ：少用，保持宽高比，使图片的短边能完全显示出来
+ widthFix ：常用，保持宽高比，宽度不变，高度自动变化
+ heightFix ： 保持宽高比，高度不变，宽度自动变化
+ top、bottom、center、left、right、top left、top right、bottom left、bottom right ： 不缩放图片，只显示图片的..区域（相当于background-position）



### 5.4 swiper 轮播图

+ swiper(轮播图外层容器) > swiper-item (轮播项)
+ swiper存在默认宽(100%)高(150px)  如果里面要用到image也是有默认宽高的(320px * 240px) swiper不会被里面撑开
+ 要计算swiper 和 image 的宽高
+ 属性：
  + autoplay 自动播放
  + interval 轮播时间 ms
  + circular 循环轮播
  + indicator-dots 显示 指示器/分页器/索引器
  + indicator-color 指示器未选中颜色
  + indicator-active-color 指示器选中颜色

~~~html
<!-- 先找出 原图的宽高 等比例 给swiper 定宽高
原图 520 * 280px 
swiper 宽 / 高 = 原图 宽 / 高
height: swiper 宽 * 原图 高 / 宽 = 100vw * 280px / 520px -->
<swiper autoplay interval="2000" circular indicator-dots>
	<swiper-item> <image mode="widthFix" src="..." /></swiper-item>
	<swiper-item> <image mode="widthFix" src="..." /></swiper-item>
	<swiper-item> <image mode="widthFix" src="..." /></swiper-item>
</swiper>
~~~

~~~css
swiper{
  width: 100%;
  height: calc(100vw * 280 / 520);
}

image{
  width: 100%;
}
~~~





### 5.5 navigator 超链接

导航组件 navigator  块级标签

属性：

+ url：当前小程序内的跳转链接
+ targer：在哪个目标上发生跳转，默认当前小程序 self(自己 默认) / miniProgram(其他小程序)
+ open-type：跳转方式
  + navigate：默认，保留当前页面，跳转应用内某页面，不能跳转tabbar页面
  + redirect：关闭当前页面，跳转应用内某页面，不能跳转tabbar页面
  + switchTab：跳转tabBar页面，并关闭其他所有页面
  + reLaunch：关闭所有页面，打开到应用内某页面
  + navigateBack：关闭当前页面，返回上一页面，可通过getCurrentPages()获取当前页面栈
  + exit：退出小程序，target=”miniProgram”时使用



### 5.6 rich-text [富文本](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)

相当于v-html

~~~html
<rich-text nodes="{{html}}"></rich-text>
~~~

~~~js
Page({
    data:{
        //1. 字符串 <div>hello</div>
        html:""
        //2. 对象形式
    }
})
~~~



### 5.7 button 

#### 5.7.1 外观属性

[官网](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

+ size 尺寸：default(默认) / mini(小尺寸)

+ type 颜色：default(灰色) / primary(绿色) / warn(红色)
+ plain 背景透明
+ loading 文字前面 + 加载logo
+ open-type 开发功能 ：…

#### 5.7.2 开放功能

+ open-type 的值：
  + contact 打开客服对话  需要在微信小程序的后台配置
    1. 只能真机调试
    2. 将小程序的appid 由测试号 改为自己的 appid
    3. 登录 微信小程序官网 添加 客服-微信
    4. 
  + share 转发当前小程序到微信朋友  不能发到朋友圈
  + getPhoneNumber 获取当前用户手机号码信息 结合事件  if非企业小程序 就没有权限获取
    1. 绑定事件 bindgetpphonenumber
    2. 在回调函数中 通过参数来获取信息 / 事件源e
    3. 获取的信息加密了 
    4. 需要用户自己搭建小程序后台服务器 在其解析 返回到小程序才能看到
  + getUserInfo 获取当前用户的个人信息
    1. 绑定事件 bindgetuserinfo
    2. 可以获取到
  + launchApp 在当前小程序 直接打开app
    1. 需要先在app 中 通过app 打开小程序
    2. 然后在小程序中 点击这个button 才能打开 app
  + openSetting 打开小程序内置的 授权页面
    1. 只会出现用户曾经授权过的
  + feedback 打开小程序内置的 意见反馈页面
    1. 只能真机调试



### 5.8 icon 

属性:

+ type：图标类型 success, success_no_circle, info, warn, waiting, cancel, download, search, clear
+ size：默认23 ，数值越大 图标越大
+ color：与css颜色同



### 5.9 radio

radio-group > radio

可以使用color属性 换颜色

选择单选框 触发的事件 bindchange 

需求：选择 在页面中显示选择的内容

~~~html
<radio-group bindchange="handleChange">
	<radio value="male">男</radio>
    <radio value="female">女</radio>
</radio-group>

<view>您选择的是：{{gender}} </view>
~~~

~~~js
Page({
    data:{
        gender:""
    },
    handleChange(e){
        let gender = e.detail.value;
        this.setData({
            gender
        })
    }
})
~~~



### 5.10 checkbox

checkbok-group > checkbox

可以使用color属性 换颜色

~~~html
<checkbox-group bindchange="handleChange">
	<checkbox value="{{item.value}}" wx:for="{{list}}" wx:key="id">{{item.name}}</checkbox>
</checkbox-group>

<view>您选择的是：{{checkedlist}} </view>
~~~

~~~js
Page({
    data:{
        list:[
            {id:'1',name:'apple',value:'apple'},
            {id:'2',name:'pear',value:'pear'},
            {id:'3',name:'grape',value:'grape'},
        ],
        checkedlist:[]
    },
    handleChange(e){
        const checkedlist = e.detail.value;
        this.setData({
            checkedlist
        })
    }
})
~~~



### 5.11 scroll-view 滚动视图区域

属性：

> 使用竖向滚动时，需要给[scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，[2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)起支持传入单位(rpx/px)。
>
> less 使用 calc 希望css 原样使用  height:~’calc(100vh - 90rpx)’

+ scroll-x：允许横向滚动
+ scroll-y：允许纵向滚动
+ scroll-top：设置竖向滚动条位置 
+ scroll-left：设置横向滚动条位置



> 点击 其他标签 使本来轮动到一定距离的页面 在顶部显示

~~~html
<scroll-view scroll-top="{{scrollTop}}" bindTap="handleChange">
~~~

~~~js
data(){
    scrollTop:0
},
handleChange(){
    setData({
        //重新设置 右侧内容的scroll-view标签的距离顶部的距离
        this.scrollTop:0
    })
}
~~~





## 6.自定义组件

### 6.1 使用自定义组件

1. 新增组件

   <img src="https://s1.328888.xyz/2022/04/09/XaM80.jpg"  style="zoom:80%; float:left " >

2. 定义组件  在组件的 json 文件中进行自定义组件声明

   ~~~json
   //在组件Tabs.json
   {
       "component":true
   }
   ~~~

3. 声明组件 在要使用组件的 json 文件中声明组件

   ~~~json
   //demo.json
   {
     "usingComponents": {
       "Tabs":"../../components/Tabs/Tabs"        //组件名称:相对路径
     }
   }
   ~~~

4. 使用组件 在要使用的页面 使用

   ~~~html
   <!-- demo.wxml -->
   <Tabs></Tabs>
   ~~~




### 6.2 注意事项

在页面 .js 文件中 事件回调函数 放在 与data 同层级

在组件 .js 文件中 事件回调函数 放在 与data 同层级 的 methods：{} 中



### 6.3 父向子组件传值 - 通过属性传递

1. 在父组件wxml里 给子`<tabs>`组件 定义属性 
2. 在子组件js里 的 properties 接收值  属性名aaa : { type:数据类型,value:”” }
3. 就可以直接在子组件wxml里使用了

~~~html
//com.wxml
<Tabs aaa="bbb"></Tabs>
~~~

~~~js
//tabs.js
Component({
  //组件的属性列表
  properties: {
    aaa: {
      type: String,
      value: ""
    }
  }
 })
~~~

~~~html
//tabs.wxml
 <view>{{aaa}}</view>
~~~



###  6.4 子向父组件传值 - 通过事件传递

1. 子组件 点击事件 bindtap = ‘handleitemchange’ 触发 handleitemchange 事件

   通过 this.triggerEvent( ‘父组件自定义事件名称 itemChange’ , 要传递的参数) 触发 父组件 的 binditemChange 事件 传递给父组件信息

2. 父组件 自定义事件 binditemChange = ‘handleItemChange’ 被触发 自身处理事件

   通过 handleItemChange(){} 函数 接受 参数 处理事件



> 代码中 如果 只是 父向 子组件 传 tabs ， 其他业务逻辑在子组件编写 也是会有效果的
>
> 但是 是因为 在子组件 接收到 tabs 后 处理 逻辑时 setData 后 把tabs 放在了子组件 的data里 
>
> 父组件的值并没有改到



~~~html
//父组件.wxml
<Tabs aaa="bbb" tabs="{{tabs}}" binditemChange="handleItemChange"></Tabs>

//子组件.wxml
<view ... bindtap="itemchange" >{{item.value}}</view>
~~~

~~~js
//子组件.js
Component({
  properties: {
    tabs: {
      type: Array,
      value: []
    }

  },
  data: {},
  methods: {
    // 父子组件之间的通信
    itemchange(e) {   //子组件 bindtap 触发的名字
      const { index } = e.currentTarget.dataset;
      this.triggerEvent('itemChange', { index }); //父组件自定义事件名 bind + '...'
    }
  }
})
~~~

~~~js
//父组件.js
Page({
  data: {
    tabs: [
      { id: 1, value: "首页", isActive: true },
      { id: 2, value: "新闻", isActive: false },
      { id: 3, value: "同城", isActive: false },
      { id: 4, value: "我的", isActive: false }
    ]
  },
  handleItemChange(e) {  //父组件自定义事件值 
    // 接受传递过来的参数
    const { index } = e.detail;
    let { tabs } = this.data;
    tabs.forEach((v, i) => i === index ? v.isActive = true : v.isActive = false)
    this.setData({  //修改数据
      tabs
    })
  },
})
~~~



### 6.5 slot 插槽

其实就是一个占位符 直接写在组件标签里面，这些里面的东西就会替换slot

~~~html
//父组件
<Tabs>
  <view>
    111
  </view>
</Tabs>

//子组件
<view class="tabs">
 <slot></slot> 
</view>
~~~



### 6.6 组件的其他属性

​	Component 里面的[属性](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)

| 定义段     | 类型       | 是否必填 | 描述                                                         |      |
| :--------- | :--------- | :------- | :----------------------------------------------------------- | :--- |
| properties | Object Map | 否       | 组件的对外属性，是属性名到属性设置的映射表                   |      |
| data       | Object     | 否       | 组件的内部数据，和 `properties` 一同用于组件的模板渲染       |      |
| observers  | Object     | 否       | as vue watch — 组件数据字段监听器，用于监听 properties 和 data 的变化，参见 [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) |      |
| methods    | Object     | 否       | 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 [组件间通信与事件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html) |      |
|            |            |          |                                                              |      |
| created    | Function   | 否       | as vue created — 组件生命周期函数-在组件实例刚刚被创建时执行，注意此时不能调用 `setData` ) |      |
| attached   | Function   | 否       | as vue mounting — 组件生命周期函数-在组件实例进入页面节点树时执行) |      |
| ready      | Function   | 否       | as vue mounted  — 组件生命周期函数-在组件布局完成后执行)     |      |
| moved      | Function   | 否       | as vue updated  — 组件生命周期函数-在组件实例被移动到节点树另一个位置时执行) |      |
| detached   | Function   | 否       | as vue destoryed  — 组件生命周期函数-在组件实例被从页面节点树移除时执行) |      |



## 7. 生命周期

#### 7.1 应用 app.js 生命周期 

+ 全局最外层是App({})

+ onLaunch() : 触发：应用第一次启动时;

  ​                    作用：应用第一次启动时，获取用户个人信息

+ onShow() : 触发：应用被用户看到时

  ​                  作用：对应用的数据或页面效果 重置

+ onHide() : 触发：应用被隐藏时

  ​                作用：暂定 或 清除定时器

+ onError() : 触发：应用代码发生了报错的时候

  ​                  作用：收集用户的错误信息，通过异步请求，将错误信息发到后台

+ onPageNotFound() : 触发：应用第一次启动时，找不到第一个入口页面

  ​                                作用：通过js重新跳转到第二个首页 wx.navigateTo({url:’…’}) 不能跳转到tabbar页面



#### 7.2 页面 demo.js 生命周期

+ data : 页面初始数据

+ onLoad : 页面加载完毕 发送异步请求初始化页面

+ onShow : 页面显示 

+ onReady : 页面渲染完毕

+ onHide : 页面隐藏 切后台/跳链接

+ onUnload : 页面卸载  点击超链接 open-type 的值中 有包含关闭页面的才ok ：redirect、reLaunch、navigateBack

+ onPullDownRefresh : 监听用户的下拉刷新操作 进行页面数据 效果 的刷新操作

+ onReachBottom : 监听页面上拉触底事件 需要让页面 上下滚动 

+ onShareAppMessage : 点击右上角转发操作

+ onPageScroll : 页面滚动

+ onResize : 页面尺寸发生改变 小程序 横屏/竖屏切换 

  > 开启页面横批 在页面的json文件 ＋
  >
  > { “pageOrientation”:”auto”}
  >
  > 然后在模拟器中就可以找到 切换模式 按钮

+ onTabItemTap : 当前页面 tabbar 页面 点击自己的 tab 键时



## 8.异步请求

### 8.1 使用 wx-request 

[官网位置](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)

一般将异步请求写在页面周期函数的 onLoad 里

<img src="https://s1.328888.xyz/2022/04/09/XaECy.jpg">

~~~js
//index.js
Page({
  onLoad: function (options) {
    wx.request({
      url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin',
      success: (result) => {
        console.log(result);
      },
      fail: (err) => { console.log(err); },
      complete: () => { }
    });
  },
})


//to be function
Page({
  onLoad: function (options) {
    getSiwperImage()
  },
  getSwiperImage(){
    wx.request({
      url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin',
      success: (result) => {
        console.log(result);
      },
      fail: (err) => { console.log(err); },
      complete: () => { }
    });
  }
})
~~~



### 8.2 优化异步请求es6 promise 

> 方便嵌套

1. 在 request 新建 index.js 到处 封装好的 Promise 的request
2. 在要用到 异步请求 的页面 index.js 导入 request 用来发送请求的方法

~~~js
//在 request 新建 index.js
export const request = (params) => {
  return new Promise((resolve, reject) => {
    wx.request({
      ...params,
      success: (res) => {
        resolve(res);
      },
      fail: (err) => {
        reject(err)
      }
    })
  })
}
~~~

~~~js
//页面 index.js 
import { request } from '../../request/index.js'
Page({
 onLoad: function (options) {
    request({ url: 'https://service-dxtrccme-1302998929.gz.apigw.tencentcs.com/release/accordin' }).then(res => {
      this.setData({
        swiperlist: res.data.data
      })
    })
 },
})
~~~



### 8.3 提取公共接口路径

~~~js
//在 request 新建 index.js
export const request = (params) => {
    //定义公共接口路径
  const baseUrl = 'https://...'
  return new Promise((resolve, reject) => {
    wx.request({
      ...params,
       
      url:baseUrl+params.url,  
        
      success: (res) => {
        resolve(res);
      },
      fail: (err) => {
        reject(err)
      }
    })
  })
}
~~~



### 8.4 es7 的 async 语法

es7 的 async 号称是解决 回调的 最终方案

异步 -> 同步

> 因为小程序 明确指明支持 es6 -> es5
>
> 所以写es7 语法会比较麻烦 如果设配比较旧 设备的时候 还是用es6 的promise

1. 小程序开发工具中，勾选 es6 转 es5 语法
2. [下载facebook的regenerator库中的](https://github.com/facebook/regenerator/blob/master/packages/runtime/runtime.js)
3. 在小程序目录新建文件 lib/runtime/runtime.js 将代码拷贝进去
4. 在需要使用anync的地方引入 import regeneratorRuntime from ‘../../lib/runtime/runtime’



~~~js
//第9 本地存储 中 有一个 function getCates()  将这个方法 使用async 和 await
//也用上了baseurl
import regeneratorRuntime from ‘../../lib/runtime/runtime’

async getCates(){
    //1.使用es7 的 async await发送请求  
     const res = await request({ url:"/categories" });
     this.Cates = res.data.message;
             
     // 把接口中的数据存入本地存储
     wx.setStorageSync("cates",{time:Data.now(),data:this.Cates});
   
     let leftMenuList = this.Cates.map(v => v.cat_name);
     let rightMenuList = this.Cates[0].children;
     this,setData({
          leftMenuList,
          rightMenuList
      })
}
~~~



### 8.5 将显示加载中的logo封装在请求中

加载中的[官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showLoading.html)

~~~js
//计同时发送请求的数据
let ajaxtime = 0;
export const request = (params) => {
   ajaxtime++;
  //显示加载中
  wx.showLoading({
      title:"加载中",
      mask:true
  })
    
  //定义公共接口路径
  const baseUrl = 'https://...'
  return new Promise((resolve, reject) => {
    wx.request({
      ...params,
       
      url:baseUrl+params.url,  
        
      success: (res) => {
        resolve(res);
      },
      fail: (err) => {
        reject(err)
      },
        
      complete:() => {
          ajaxtime--;
          //无论 所以同步请求都完成  成功还是失败 都执行
          //关闭加载
          if(ajaxtime === 0){
              wx.hideLoading();
          }
          
      }
    })
  })
}

~~~



### 8.6 request 封装中增加 header 头部信息

~~~js
//计同时发送请求的数据
let ajaxtime = 0;
export const request = (params) => {
    //判断url 中的特点 if 有 /my/ 就得加 header 私有路径
    let header = {...params.header};
    if(params.url.includes("/my/")){
        //拼接
        header["Authorization"] = wx.getStorageSync("token");
    }
    
    
   ajaxtime++;
  //显示加载中
  wx.showLoading({
      title:"加载中",
      mask:true
  })
    
  //定义公共接口路径
  const baseUrl = 'https://...'
  return new Promise((resolve, reject) => {
    wx.request({
      ...params,
       
      url:baseUrl+params.url,  
        
      success: (res) => {
        resolve(res);
      },
      fail: (err) => {
        reject(err)
      },
        
      complete:() => {
          ajaxtime--;
          //无论 所以同步请求都完成  成功还是失败 都执行
          //关闭加载
          if(ajaxtime === 0){
              wx.hideLoading();
          }
          
      }
    })
  })
}

~~~





## 9.本地存储

web 与 小程序 中 本地存储的区别

+ 代码 web：localStorage.setItem(“key”,”value”)

  ​                 localStorage.getItem(“key”)

  ​       小程序：wx.setStorageSync(“key”,”value”)

  ​                     wx.getStorageSync(“key”)

+ 存的时候 是否会做类型转换

  ​     web：存数据时 会调用toString() 把数据转换成字符串

  ​    小程序：不会进行数据转换  即 传的是什么数据类型 取的就是什么类型的



小程序本地存储的过程

1. 判断本地存储 有无旧数据  {time:Data.now() , data:[…]}
2. if 无旧数据 直接发送请求 存入 本地存储
3. if 有 同时 旧数据没有过期 就直接使用本地存储的数据



~~~js
Page({
    data(){
        leftMenuList:[],
        rightMenuList:[]
    },
    Cates:[],
    onLaod():function(options){
    	//1.获取本地存储中的数据 
    	const Cates = wx.getStorageSync("cates");
    	//2.判断
    	if(!Cates){
            //发送请求
            this.getCates();
        }else{
            //是否过期  10s  
            if(Data.now() - Cates.time > 1000 * 10){
                //过期 发送请求
                this.getCates();
            }else{
                //使用旧数据
                this.Cates = Cates.data;
                let leftMenuList = this.Cates.map(v => v.cat_name);
                let rightMenuList = this.Cates[0].children;
                this,setData({
                    leftMenuList,
                    rightMenuList
                })
            }
        }
	},
    //获取数据
     getCates(){
         request({url:"..."}).then(res => {
             this.Cates = res.data.message;
             
             // 把接口中的数据存入本地存储
             wx.setStorageSync("cates",{time:Data.now(),data:this.Cates});
             
             
             let leftMenuList = this.Cates.map(v => v.cat_name);
             let rightMenuList = this.Cates[0].children;
             this,setData({
                 leftMenuList,
                 rightMenuList
             })
         })
     }
})
~~~



## 10 效果

### 10.1 previewImage[将图片放大预览](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html)

wx.previewImage({
  			current: '', // 当前显示图片的http链接
  			urls: [] // 需要预览的图片http链接列表
		})



### 10.2 showToast[显示弹框](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)

wx.showToast(){

​	title:””,

​	icon:””,

​	mask:true //防抖

}



### 10.3 getSetting[获取权限状态](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html)

wx.getSetting({

​	success:(res) => {

​			

​	}

})



### 10.4 chooseAddress[获取收货地址]()

之前有过的

wx.chooseAddress({

​	success:(res) => {

​		…

​	}

})



### 10.5 showModal [显示弹窗](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html)

wx.showModal({
  		title: '提示',
  		content: '这是一个模态弹窗',
  		success (res) {
    			if (res.confirm) {
      				console.log('用户点击确定')
    			} else if (res.cancel) {
      				console.log('用户点击取消')
    			}
  		}
		})



### 10.6 支付

+ 支付流程 ：创建订单 -> 准备支付 -> 发起微信支付 -> 查询订单



### 10.7 chooseImage [选择图片](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html)

wx.chooseImage({

​	count:9,   //同时选择的最大图片数量

​	sizeType:[‘original’ , ‘compressed’],   //图片格式  原图 压缩

​	sourceType:[‘album’ , ‘camera’],  //图片来源 相册 照相机

​	success:(result) => {

​		this.Data({

​			chooseImages = […this.data.chooseImages,…result.tempFilePaths]    //拼接 图片数组

​		})

​	}

})



