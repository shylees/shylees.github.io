---
title: 04 vue模块化开发
date: 2021/3/15
updated: 2021/3/21
comments:
tags:
 - vue
 - webpack
categories:
 - learningNotes
layout:
permalink:
meta: true
toc: true
---

## 1.什么是模块化

使用模块作为出口：

+ 在匿名函数内定义一个对象
+ 给对象添加各种需要暴露到外面的属性和方法（不需要暴露的直接定义即可）
+ 最后将要暴露的对象返回 并且在外面使用一个moudleB接受

在main.js使用：

+ 只需要使用属于自己模块化的属性和方法即可

这就是模块化最基础的封装，事实上模块的封装还有很多高级的话题：

+ 以下就是最简单的模块的原始雏形
+ 目前前端模块化开发已经有了很多既有的规范，以及应对的方案

常见的模块化规范：

+ CommonJS、AMD、CMD、es6的Modules



### 1.1 原始的模块化

~~~js
//这样在别的文件 又不会产生命名冲突 又可以使用曾经声明过的变量 直接使用moduleB.flag
//早期自己的模块化使用
var moduleB = (function(){
    //导出的对象
    var obj = {};
    var name = "red";
    var flag = true;
    
    obj.flag = flag;
    
    return obj;
}())
~~~

### 1.2 CommonJS

~~~js
//aaa.js

var name ='ming';
var flag = true;
function sum(num1,num2){
    return num1+num2;
}

//导出语法  必须要有底层支撑才能解析代码 比如node
module.exports = {
    flag:flag,
    sum
}
~~~

~~~js
//mmm.js

//导入
var {flag,sum} = require('./aaa.js');  //对象的解构
 //===
var aaa = require('./aaa.js');
var flag = aaa.flag;
var sum = aaa.sum;
~~~



### 1.3 es6的模块化的导入导出

~~~html
<!-- html 使用type=‘module’就可以 使用模块化 不会出现命名冲突 -->
<script src='aaa.js' type='module'></script>
<script src='bbb.js' type='module'></script>
<script src='mmm.js' type='module'></script>
~~~



~~~js
//aaa.js
var name = 'ming';
var age = 18;
var flag = true;

function sum(num1,num2){
    return num1 + num2;
}

if(flag){
    console.log(sum(20,30))
}

//1.导出方式一：导出给其他js使用本js的变量
export{
	flag,sum
}
//2.导出方式二：定义时就导出变量
export var num1 = 1000;
export var height =  1.88;

//3.导出函数/类
export function mul(num1,num2){
    return num1+num2;
}
export class Person{
    run(){
        console.log('running')
    }
}

//4.export default
//某些情况下，一个模块中包含某个功能 我们不希望给这个功能命名 而且想让导入者可以自己来命名
//在同一个模块中只能有一个
const address = 'bj'
export default address;

export default function(arg){
    console.log(arg);
}
~~~



~~~js
//mmm.js
//1.导入{}定义的变量
import {flag} from "./aaa.js";

if(flag){
    console.log('xiaoming');
}
//2.直接导入export定义的变量
import {num1, height} from "./aaa.js";

//3.导入export的function
import {mul,Person} from "./aaa.js";

const p = new Person();
p.run();

//4.导入export default 导入aaa.js默认导出的东西
import addr from "./aaa.js";

//5.统一全部导入
import * as aaa from "./aaa.js";
aaa.flag; 
~~~

## 2.webpack详解

### 2.1 认识webpack

At its core，webpack is a static module bundler for modern JavaScript applications

从本质上，**webpack**是一个现代的JavaScript应用的**静态模块**打包工具

+ 模块、打包
  + 打包工具：grunt、gulp、webpack

#### 2.1.1前端模块化

+ 除了ES6的模块化的底层是靠浏览器的支撑外，其他都需要借助别其他的工具，才能进行模块化开发

+ 并且在通过模块化开发完成项目后，还需要处理模块间的各种依赖，并且将其进行整合打包

+ 而webpack其中一个核心就是让我们可能进行模块化开发，并且回帮助我们处理模块间的依赖关系

#### 2.1.2 打包

+ 将webpack中各种资源模块进行打包合并成一个/多个包
+ 在打包过程中，还可以对资源进行处理，比如压缩图片、scss->css、将es6语法转换成es5语法等

#### 2.1.3 和grunt/gulp的对比

<img src="https://s1.328888.xyz/2022/04/09/XOPH1.png">

### 2.2 webpack的安装（p76）

webpack为了可以正常运行 必须依赖node环境 

node环境为了可以正常的执行很多代码，必须其中包含各种依赖的包

npm工具（node packages manager）

+ 安装node.js Node.js自带了软件包管理工具npm
  + 查看node版本：cmd：node -v 版本大于8.9
+ 全局安装webpack（安装3.6.0 因为vue cli2依赖该版本）
  + 使用npm安装：cmd： npm install webpack@3.6.0 -g
+ 局部安装webpack
  + `--save-dev`是开发时依赖，项目打包后不需要使用的
+ 全局安装后，还需要局部安装：
  + 在终端直接执行webpack命令，使用的全局安装的webpack
  + 当在package.json中定义了script时，其中包含了webpack命令，那么使用的是局部webpack

### 2.3 webpack的起步 （p77）

> **通过vs code 运行webpack进行打包时，报错webpack : 无法加载文件 D:\nodejs\node_global\webpack.ps1，因为在此系统上禁止运行脚本。**
>
> 解决方案：
>
> 1. 以管理员身份运行vs code
> 2. 执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的
> 3. 执行：set-ExecutionPolicy RemoteSigned
> 4. 这时再执行get-ExecutionPolicy，就显示RemoteSigned

dist文件夹里的就是打包的东西，把这个给服务器就好了

~~~js
//main.js
//1.使用commonjs的模块化规范
const { add, mul } = require('./mathUtils.js');

console.log(add(20, 30));
console.log(mul(20, 30));

//2.使用es6的模块化规范
import { name, age, height } from "./info"
console.log(name, age, height);
~~~

~~~js
//mathUtils.js
function add(num1, num2) {
    return num1 + num2;
}

function mul(num1, num2) {
    return num1 * num2;
}

export { add, mul }
~~~

~~~js
//info.js
//es6的模块化
export const name = "why";
export const age = 20;
export const height = 1.88;
~~~

> 打包到./dist/dundle.js

<img src='https://s1.328888.xyz/2022/04/09/XaerO.jpg' style="zoom:67%;" >

~~~html
    <script src="./dist/bundle.js"></script>
~~~

### 2.4 webpack的配置（p78-82）

#### 2.4.1 入口出口的配置

~~~js
//index.html同目录下 新建webpack.config.js

//动态获取绝对路径 必须要有path包 下载npm init
//包名 当时：meetwebpack
//出口 当时：index.js
//会生成一个package.json  如果想依赖node.js 一般都会需要 
//这里path有依赖 这里会全局搜
const path = require('path');

//直接用webpack代替webpack ./src/main.js ./dist/dunble.js

//在packae.js 中设置"build:'webpack'" 用npm run build 映射 webpack
module.exports = {
    //入口
    entry: './src/main.js',
    //出口
    output: {
        //路径 不能使用相对路径 动态获取绝对路径 
        //对两路径进行拼接  __dirname 全局变量 保存当前文件的路径
        path: path.resolve(__dirname, 'dist'),
        //文件名
        filename: 'bundle.js'
    },
}
~~~

#### 2.4.2 局部安装webpack

怎么直接在控制台打上webpack就能让main.js打包成bundle.js

因为全局webpack的版本可能跟本地不一样 所以还得下载个本地的webpack

> 在package.json中 下载本地webpack后(npm install webpack@3.6.0 - - save-dev) 会自动生成 
>
> 开发时依赖–“devDependencies”：{“webpack”：“^3.6.0”}
>
> 后面会讲到运行时依赖–“dependencies”:{}

只要在命令行/cmd里面使用的都是终端 使用的都是全局的webpack ：webpack

在package.json定义的scripts优先运行本地  npm run build  / ./node_modules/webpack.config.js

<img src='https://s1.328888.xyz/2022/04/09/XayZP.jpg'>

<img src='https://s1.328888.xyz/2022/04/09/Xau7q.jpg'>

### 2.5 loader的使用

#### 2.5.1webpack中使用css文件的配置

##### 2.5.1.1 介绍

+ 加载css、图片、包括一些高级的将ES6转成ES5代码、将TypeScript转成ES5代码、将scss、less转成css、将.jsx、.vue转成js等等
+ 这些webpack本身能力做不到，但其扩展对应的loader就可以

loader使用过程：

+ 步骤一：通过npm安装需要使用的loader
+ 步骤二：在webpack.config.js中的modules关键字下进行配置

大部分loader可以在webpack官网中找到，并且学习对应的用法

##### 2.5.1.2 产生依赖

因为要有依赖才能打包，所以在main.js设置css的依赖

~~~js
//main.js

//3.依赖css文件
require('./css/normal.css')
~~~

##### 2.5.1.3 loader

因为直接使用的话会报错 说没有找到适合的loader  然后就去官网https://webpack.js.org (英文网址)/https://webpack.js.com （中文网址）找

> css-loaderrhttps://webpack.js.org/loaders/css-loader/只负责加载 不负责解析 生效

>  style-loaderhttps://webpack.js.org/loaders/style-loader/:将模块的导出作为样式添加到DOM

> 
>
> 如果报UnhandledPromiseRejectionWarning: TypeError: this.getResolve is not a function
>
> 可能是loader版本过高 可以在install时下载 较低版本
>
>  npm install --save-dev css-loader@3.3.0
>
> npm install --save-dev style-loader@1.0.0

<img src='https://s1.328888.xyz/2022/04/09/XaJkS.png' style="zoom:70%;" >

<img src='https://s1.328888.xyz/2022/04/09/Xag9m.png' style="zoom:70%;" >

<img src='https://s1.328888.xyz/2022/04/09/Xa9WA.png' style="zoom:70%;" >

##### 2.5.1.4 对配置文件的解释

~~~js
    module: {
        rules: [{
            //正则表达式：匹配所有css文件 去应用下面2loader
            test: /\.css$/i,
            //css-loader只负责加载 不负责解析 生效
            //还得再下载一个style-loader:将模块的导出作为样式添加到DOM
            //使用多个loader时 从右到左
            use: ["style-loader", "css-loader"],
        }, ],
    },
~~~

#### 2.5.2 less文件处理

~~~less
//special.less

@font-face: 50px;
@fontColor: orange;

body {
    font-size: @font-face;
    color: @fontColor;
}
~~~

~~~js
//main.js

//4.依赖less文件
require('./css/special.less');
~~~

文件编写–>终端打包–>报错 说要一个对应的loader处理文件 –>less-loader@4.1.0–>配置文件

~~~js
			{
               test: /\.less$/i,
               use: [{
                    loader: "style-loader",
                }, {
                    loader: "css-loader",
                }, {
                    loader: "less-loader", // compiles Less to CSS
                }]
            }
~~~

#### 2.5.3 图片处理

css引用图片–>file loader–>url loader + file loader@3.0.1–>配置文件

~~~js
//package.json
	output: {
        //路径 不能使用相对路径 动态获取绝对路径 
        //对两路径进行拼接  __dirname 全局变量 保存当前文件的路径
        path: path.resolve(__dirname, 'dist'),
        //文件名
        filename: 'bundle.js',
        //!!!只要在以后任何有url的地方都会在前面加上dist
        publicPath: 'dist/'
    },

		{
                test: /\.(png|jpg|gif)$/i,
                use: [{
                    loader: 'url-loader',
                    options: {
                        //使用小于限制时，会将图片编译成base64位字符串 显示出来
                        limit: 5000,
                        //若大于限制，会要使用'file roader'@3.0.1进行加载 安装就好
                        //base64不需要打包直接从网上获取
                        //但大于就会将图片进行打包放在dist中  哈希生成名字-->32位hash值 防止名字重复
                        //所以要加上路径 在output里+“publicPath: 'dist/'”
                    },
                }, ],
            },
~~~

处理生成的图片名称：

+ 将所有图片放在img，跟原来图片一样的名，同时防止重复

  img/name.hash:8.ext

~~~js
{
                test: /\.(png|jpg|gif)$/i,
                use: [{
                    loader: 'url-loader',
                    options: {
                        limit: 5000,
                        //if img/name 那文件==name.png
                        name: 'img/[name].[hash:8].[ext]'
                    },
                }, ],
            },
~~~

#### 2.5.4 es6转es5的babel-loader

官网babel loader–>

安装：`npm install --save-dev babel-loader@7 babel-core babel-preset-es2015`

配置webpack.config.js文件

~~~js
 {
                test: /\.js$/,
                //排除 src外的文件夹
                exclude: /(node_modules|bower_components)/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['es2015']
                    }
                }
            }
~~~

> 这样的话 打包好的js 就没有es6属性了

### 2.6 webpack中配置Vue

####  2.6.1 引入vue.js

要在项目中使用Vue.js，就需要对其产生依赖，所以先安装

~~~js
npm install vue --save  //因为后续在实际项目中会使用到vue，所以并不是开发时依赖的
//当时是 vue@2.5.21  我的是vue@2.6.12
~~~

> 会被安装到 node_modules里  就可以把vue当成一个模块

然后在任何一个文件就可以引用 vue

~~~js
//main.js

//5.使用Vue.js开发
import Vue from 'vue'  //没有文件名 就会在 上述包里 找vue 
~~~

编写-> 打包 -> 打开 -> 报错

原因：

> vue有两个版本 ：
>
> 1. runtime-only 代码中不能有任何的template 不会编译
> 2. runtime-complier 可以编译template
>
> 报的错就是 因为使用的就是runtime-only版本

解决：

> 修改webpack的配置 添加：
>
> ~~~js
> //webpack.config.js  
> //与entry同级
> 
>     resolve: {
>         //别名
>         alias: {
>             //在进行 import Vue from 'vue 操作时 会看vue是否指向 下面的文件夹 
>             'vue$': 'vue/dist/vue.esm.js'
>         }
>     },
> ~~~

重新打包 ->运行就可以了

####  2.6.2 el和template的区别（一）

+ 因为后面开发 只用一个index.html  在使用组件时 就必要的会修改index.html 
+ 但html模板在之后的开发中，不希望手动来频繁修改

所以 

~~~html
<!-- 在html中只保留这个代码 -->
<body>
    <div id="app">
    </div>
    <script src="./dist/bundle.js"></script>
</body>
~~~

~~~js
//在vue实例中 使用template  template会替换掉 el挂载的元素

const app = new Vue({
    el: "#app",
    template: `<div><h2>{{ message }}</h2></div>`,
    data: {
        message: 'hello webpack!'
    }
})
~~~

#### 2.6.3 完善

将上述

##### 抽取到组件中：

~~~js
const App = {
    template: `
    <div>
        <h2>{{ message }}</h2>
        <button @click='butClick'>按钮</button>
    </div>
    `,
    data() {
        return {
            message: 'hello webpack!'
        }
    },
    methods: {
        btnClick() {
            alert();
        }
    }
}
	
new Vue({
    el: "#app",
    template: '<App />',
    components: {
        App
    },
    data: {}
})
~~~



##### 抽取对象

~~~js
//App.js

export default {
    template: `
    <div>
        <h2>{{ message }}</h2>
        <button @click='butClick'>按钮</button>
    </div>
    `,
    data() {
        return {
            message: 'hello webpack!'
        }
    },
    methods: {
        btnClick() {
            alert();
        }
    }
}
~~~

~~~js
//main.js

//5.使用Vue进行开发
import Vue from 'vue'
import App from './vue/app'   //默认导出  不需要大括号

new Vue({
    el: "#app",
    template: '<App />',
    components: {
        App
    },
    data: {}
})
~~~

##### 分离app.js 的js与模板

~~~vue
//app.vue

<template>
  <div class="title">
    <h2>{{ message }}</h2>
    <button @click="butClick">按钮</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      message: "hello webpack!",
    };
  },
  methods: {
    btnClick() {
      alert();
    },
  },
};
</script>

<style scoped>
.title {
  color: red;
}
</style>
~~~

~~~js
//main.js

//5.使用Vue进行开发
import Vue from 'vue'
// import App from './vue/app'
import App from './vue/app.vue'


new Vue({
    el: "#app",
    template: '<App />',
    components: {
        App
    },
    data: {}
})
~~~

运行后 会报错 因为使用了.vue文件  要配loader

##### 配置vue-loader

~~~js
//安装 vue-loader  vue-template-compiler
npm install vue-loader  vue-template-compiler --save-dev

//webpack.config.js配置文件
{
    test:/\.vue$/,
    use:['vue-loader']
}
~~~

> 报错的话 可能是vue-loader版本太高  可以修改低于14的版本  ‘^13.0.0’  然后再终端 npm install 重新下载 然后就可以了

##### 组件化使用

~~~vue
//Cpn.vue

<template>
  <div>
    <h2>{{ message }}</h2>
  </div>
</template>

<script>
export default {
  name: "Cpn",
  data() {
    return {
      message: "Cpn组件",
    };
  },
};
</script>

<style scoped>
</style>
~~~

~~~vue
//app.vue
//import Cpn from "./Cpn.vue";
//注册 组件 compontents: {Cpn,},
//使用组件  单/双标签 都可 <Cpn></Cpn>
<template>
  <div class="title">
    <h2>{{ message }}</h2>
    <button @click="butClick">按钮</button>
    <Cpn></Cpn>
  </div>
</template>

<script>
import Cpn from "./Cpn.vue";   

export default {
  name: "App",
  components: {
    Cpn,
  },
  data() {
    return {
      message: "hello webpack!",
    };
  },
  methods: {
    btnClick() {
      alert();
    },
  },
};
</script>

<style scoped>
.title {
  color: green;
}
</style>
~~~

> 如果在 import 时想要简写 .vue 什么的 可以在 webpack.config.js  的 resolve添加
>
> ~~~js
> //webpack.config.js 
>  extensions:['.js','.vue','.css']
> ~~~

### 2.7 横幅plugin的使用

1.  认识plugin

+ plugin是插件的意思，通常是用于对某个现有的架构进行扩展
+ webpack中的插件，就是对webpack现有功能的各种扩展

2. loader和plugin区别

+ loader主要用于转换某些类型的模块，转换器
+ plugin是插件，是对webpack本身的扩展，扩展器

3. plugin的使用过程

+ 步骤一：通过npm安装需要使用的plugins
+ 步骤二：在webpack.config.js中的plugins中配置文件

#### 2.7.1 添加版权的plugin

该插件名字BannerPlugin,属于webpack自带的插件

~~~js
//webpack.config.js

//添加版权的Plugin
const webpack = require('webpack');

module.exports={
    ...
        plugins: [
        new webpack.BannerPlugin('最终版权归lsy所有')
    ]
}

//进入相应的文件夹 运行 能在 打好包的文件第一行看见 /*! 最终版权归lsy所有 */
~~~



#### 2.7.2 打包html的plugin

+ 在开发时，index.html文件是存放在项目根目录下的，但真实发布时，发布的是dist的内容，但是dist没有index.html时，打包文件也就没有意义
+ 所以需要将html打包到dist中，这时就能用HtmlWebpackPlugin插件

HtmlWebpackPlugin插件可以：

1. 自动生成的一个index.html文件 可以指定模板来生成
2. 将打包的js文件自动通过script标签插入到body

安装HtmlWebpackPlugin插件：

~~~js
npm install html-webpack-plugin@3.2.0 --save-dev  //老师是@3.2.0
~~~

修改配置webpack.config.js文件中plugins部分：

+ 这里的template表示根据什么模板来生成index.html
+ 需要删除之前在output中添加的publicPath属性
+ 否则插入script标签中的src可能会有问题

~~~js
//webpack.config.js

//添加打包html的plugin
const HtmlWebpackPlugin = require('html-webpack-plugin');

    plugins: [
        //添加版权
        new webpack.BannerPlugin('最终版权归lsy所有'),
        //打包html
        new HtmlWebpackPlugin()
    ]

~~~

运行 发现 在dist中 有index文件：

1. 没有必须的`<div id='app'></div>`

   > 建立一个模板  原来的index 即根目录下的index body里只留下 上述代码作为模板
   >
   > ~~~html
   > <body>
   >     <div id="app">
   >     </div>
   > </body>
   > ~~~
   >
   > 再在打包的地方 引入模板
   >
   > ~~~js
   >         new HtmlWebpackPlugin({
   >             template: 'index.html'
   >         })
   > ~~~

2. src的地址有错

   > 在webpack.config.js 中注释掉    publicPath: 'dist/'

   再运行就可以了



#### 2.7.3 js压缩的Plugin（发布阶段使用）

+ 在项目发布之前，必然要队js等文件进行压缩处理
+ 使用第三方插件uglifyjs-webpack-plugin，并且指定版本号，与CLI2保持一致

~~~js
npm install uglifyjs-webpack-plugin@1.1.1 --save-dev
~~~

修改配置文件

~~~js
//webpack.config.js

//添加压缩js的plugin
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');

    plugins: [
        //添加版权
        new webpack.BannerPlugin('最终版权归lsy所有'),
        //打包html
        new HtmlWebpackPlugin({
            template: 'index.html'
        }),
        //压缩js文件
        new UglifyjsWebpackPlugin()
    ]
~~~

> 但在开发时不建议使用  因为不方便调试代码
>
> 在发布阶段 再加进来



### 2.8 搭建本地服务器（开发阶段使用）

+ webpack提供了一个可选的本地开发服务器，这个服务器基于node.js搭建，内部使用express框架，可以实现**让浏览器自动刷新显示修改后的结果**

安装

~~~js
npm install --save-dev webpack-dev-server@2.9.1
~~~

+ devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：
  + contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，这里填写`./dist`
  + port：端口号
  + inline：页面实时刷新
  + historyApiFallback：在SPA页面中，依赖HTML5的history模式

配置webpack.config.js文件的配置

~~~js
//webpack.config.js  与pulgin同级
    //搭建本地服务器
    devServer: {
        contentBase: './dist',
        inline: true, //是否实时监听
    }
        
~~~

 跑起来 是通过 webpack-dev-server

> 因为是再局部安装的 所以跑起来 说找不到命令 
>
> 所以在终端 应该找本地的 `./node_modules/.bin/webpack-dev-server `

但是有更简洁的方式：

~~~json
//package.json

"scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "build": "webpack",
        "dev": "webpack-dev-server"
    },
~~~

终端输入`npm run dev`  就会出现本地可以运行的地址 

点进去 后修改代码 进去就会发现 页面也刷新了

> 停止服务  ：`ctrl + c `

停止服务后 可以再次打包 就可以了



> 因为手动点地址进去可能有点麻烦 ，所以
>
> `"dev": "webpack-dev-server --open"`
>
> 就会自动打开了



### 2.9 配置文件的分离

+ 因为有些是开发时需要 有些是发布时需要

  > 开发：
  >
  > ~~~js
  > module.exports = {
  > 
  >     //搭建本地服务器
  >     devServer: {
  >         contentBase: './dist',
  >         inline: true, //是否实时监听
  >     }
  > }
  > ~~~
  >
  > 生产时：
  >
  > ~~~js
  > //添加压缩js的plugin
  > const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');
  > 
  > module.exports = {
  > 
  >     plugins: [
  >         //压缩js文件
  >         new UglifyjsWebpackPlugin()
  >     ],
  > 
  > }
  > ~~~

+ 安装webpack-merge 对两个文件进行合并

~~~js
npm install webpack-merge@4.1.5 --save-dev
~~~

+ 合并文件

  > 生产时：
  >
  > ~~~js
  > //生产时
  > 
  > //添加压缩js的plugin
  > const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin');
  > 
  > //合并两个文件
  > const webpackMerge = require('webpack-merge');
  > 
  > //导入baseConfig
  > const baseConfig = require('./base.config');
  > 
  > module.exports = webpackMerge(baseConfig, {
  >     plugins: [
  >         //压缩js文件
  >         new UglifyjsWebpackPlugin()
  >     ],
  > 
  > })
  > ~~~
  >
  > 开发时：
  >
  > ~~~js
  > //开发时
  > 
  > //合并两个文件
  > const webpackMerge = require('webpack-merge');
  > 
  > //导入baseConfig
  > const baseConfig = require('./base.config');
  > 
  > module.exports = webpackMerge(baseConfig, {
  > 
  >     //搭建本地服务器
  >     devServer: {
  >         contentBase: './dist',
  >         inline: true, //是否实时监听
  >     }
  > })
  > ~~~

+ 此时webpack.config.js就可以删了

+ 然后运行的时候就会报错 说没有‘webpack.config,js’配置文件，

  此时就需要在package.json中，指定要用的配置文件

  > ~~~js
  > //webpack.json 
  > //手动指定执行文件
  >     "scripts": {
  >         "test": "echo \"Error: no test specified\" && exit 1",
  >         "build": "webpack --config ./bulid/prod.config.js",
  >         "dev": "webpack-dev-server --open --config ./build/dev.config.js"
  >     },
  > ~~~

+ 然后就发现 被打包到build文件夹下面 的dist中了

  > 将路径改正确
  >
  > ~~~js
  > //原‘dist’      
  > //../是因为后面使用了 build/base.config.js
  > path: path.resolve(__dirname, '../dist'),
  > ~~~
  >
  > 

  

  

