---
title: 03 vue组件开发
date: 2021/3/12
updated: 2021/3/15
comments:
tags:
 - vue
categories:
 - learningNotes
layout:
permalink:
---


## 1. 组件化

### 1.1 什么是组件化

+ 将一个完整的页面分成很多个组件
+ 每个组件都用于实现页面的一个功能块
+ 每一个组件又可以进行细分

### 1.2 Vue组件化思想

+ 组件化是Vue.js中的重要思想
  + 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用
  + 任何的应用都会被抽象成一颗组件树
+ 组件化思想的应用
  + 尽可能将页面拆分成一个个小的、可以复用的组件
  + 使代码更方便组织和管理，扩展性也更强



### 1.3 注册组件的基本步骤

1. 调用`Vue.extend()`创建组件构造器
2. 调用`Vue.component()`注册组件
3. 在Vue实例的作用范围内使用组件



## 2.组件化的基本使用

### 2.1 步骤解析

1. Vue.extend():
   + 调用Vue.extend()创建的是一个组件构造器
   + 通常在创建组件构造器时，传入template代表我们自定义组件的模板
   + 该模板就是在使用到组件的地方，要显示的html代码
   + 事实上，这种写法在Vue2.x的文档已经看不到了，会直接使用语法糖的形式
2. Vue.component():
   + 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给起一个组件的标签名称
   + 需要传递两个参数：1. 注册组件的标签名 2. 组件构造器
3. 组件必须挂载在某个Vue实例下，否则不会生效



### 2.2 代码演示

~~~html
<div id="app">
    <!-- 3.使用组件 -->
    <my-cpn></my-cpn>
</div>
<script>
	//1.创建组件构造器对象  如果有多个标签的话 需要有一个根
    const cpnC = Vue.extend({
        template:`
				<div>
    				<h2>我是标题</h2>
					<p>我是内容</p>
    			</div>`
    })
    
    //2.注册组件
    Vue.component('my-cpn',cpnC);
    
    //new Vue不能写在前面
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello'
        }
    })
</script>
~~~



## 3.全局组件和局部组件

全局组件：可以在多个Vue实例下面使用；通过Vue.component()注册的组件

局部组件：只能在当前Vue实例下使用；注册的组件时挂载在某个实例中

~~~js
Vue.component('cpn',cpnC); //2.注册组件，全局组件

const app = new Vue({
    el:"#app",
    data:{},
    components:{      //局部组件  用的比较多
        //cpn使用组件时的标签名
        cpn:cpnC;
    }
})
~~~



## 4.父组件和子组件

+ 组件之间存在层级关系
+ 其中一种非常重要的关系就是父子组件的关系

~~~html
<div id="app">
    <cpn2></cpn2>
    <!-- <cpn1></cpn1> 如果要使用这个组件 要在全局或者在Vue实例注册组件  -->
</div>
<script>
	//1.创建第一个组件构造器（子组件）
    const cpnC1 = Vue.extend({
        template:`
					<div>
    					<h2>标题1</h2>
    				</div>
				`
    })
    
	//2.创建第二个组件构造器（父组件）
    const cpnC1 = Vue.extend({
        template:`
					<div>
    					<h2>标题2</h2>
						<cpn1></cpn1>
    				</div>
				`,
        components:{
            cpn1:cpnC1;
        }
    })
    
    //root 组件
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        compontents:{
            cpn2:cpnC2
        }
    })
</script>
~~~



## 5. 组件语法糖

+ 主要是省去了调用Vue.extend()的步骤，可以直接使用一个对象来代替

~~~js
//1.全局组件注册的语法糖
Vue.component('cpn1',{
    template:`
				<div>
    				<h2>标题1</h2>
    			</div>
			`
})

//2.局部组件注册
const app = new Vue({
    el:"#app",
    data:{},
    temponents:{
        'cpn2':{
            template:`
					<div>
    					<h2>标题2</h2>
    				</div>
				`,
        }
    }
})
~~~



## 6.组件模板抽离的写法

+ Vue提供了两种方案来定义HTML模块内容：
  1. 使用<script>标签 :type="text/x-template" 
  2. 使用<template>标签

~~~html
<div id="app">
    <cpn></cpn>
</div>

<!-- 1.使用<script>标签 -->
<script type="text/x-template" id="cpn">
	<div>
   		<h2>标题1</h2>
    </div>
</script>

<!-- 2.使用<template>标签 -->
<template id = "cpn">
	<div>
   		<h2>标题2</h2>
    </div>
</template>

<script>
//1.注册一个全局组件
    Vue.comonent('cpn',{
        template:'#cpn'
    })
    
  	const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        }
    })
</script>
~~~

## 7.组件数据存放的问题

### 7.1 用法

+ 组件是一个单独功能模块的封装：
  + 这个模块又属于自己的HTML模板，也应该有属于自己的数据data
+ 组件的数据不能保存再顶层Vue实例中
  + 组件对象也有一个data属性（也可以有methods等属性）
  + 只是这个data属性必须是一个函数
  + 而且这个函数返回一个对象，对象内部保存着数据

~~~html
<div id="#app">
    <my-cpn></my-cpn>
</div>

<template id="cpn">
    <div><h2>
        {{title}}
        </h2></div>
</template>

<script>
    //1.注册全局组件
    Vue.component('cpn',{
        template:"#cpn",
        data(){
            return {
                title:'abc'
            }
        }
    })
    
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello'
        }
    })
</script>
~~~

### 7.2 ！组件中的data为什么是函数（p58）

为了传值不传址，使用函数时组件与组件之间的数据不会相互影响



## 8.父子组件的通信

+ 在开发中，往往一些数据需要从上层传递到下层
  + 比如在一个页面中，我们从服务器请求到了很多的数据
  + 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示
  + 这个时候，并不会让子组件再次发送一个网络请求，而是让大组件将数据传递给小组件
+ 如何进行父子/大小组件间的通信呢?Vue官方提到
  + 通过props向子组件传递数据
  + 通过自定义事件$emit向父组件发送消息

### 8.1 props基本用法——父–>子

+ 在组件中，使用选项props来声明需要从父级接收到的数据
+ props的值有两种方式：
  1. 字符串数组，数组的字符串就是传递时的名称
  2. 对象，对象可以设置传递时的类型，也可以设置默认值等

~~~html
<div id='app'>
    <cpn v-bind:cmovies="movies" :cmessage="message"></cpn>
    <!-- 这就已经把值从父组件传到子组件了 必须要使用v-bind -->
</div>

<template id="cpn">
    <div>
        <p v-for="item in cmovies">{{item}}</p>
        <h2>{{cmessage}}</h2>
    </div>
</template>

<script>
    //父传子:props
    const cpn = {
        template:"#cpn",
        props:['comvies','cmessage'],
        data(){
            return{}
        },
        methods:{
            
        }
    }
    
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
            movies:['海王','海贼王','海尔兄弟']
        },
        components:{
            cpn
        }
    })
</script>
~~~

#### 8.1.1 props数据验证

+ 上述props选项使用一个数组
+ 除数组外，可以使用对象，当需要对props进行类型等验证时，就需要对象写法了
+ 验证支持的数据类型：
  + String、Number、Boolean、Array、Object、Date、Function、Symbol
+ 若有自定义构造函数时，验证也支持自定义的类型



~~~js
    const cpn = {
        template:"#cpn",
        //数组形式
        props:['comvies','cmessage'],
        //字符串形式
        props:{
            //1.类型限制
            cmovies:Array,
            cmessage:String,
            
            //2.提供一些默认值 默认值在没有传递的时候会显示 v-bind没有传时
            //required 为true时 说明这个属性是必传的 否则会报错
            cmessage:{
            	type:String,
                default:'aaaa'
                required:true
        	}
            
            //类型是对象/数组时，默认值必须是一个函数
            cmovies:{
            	type:Array,
            	//default:[]  这样会报错
            	default(){
            		return []
        		}
        	}
        },
        data(){
            return{}
        },
        methods:{
            
        }
    }
~~~

#### 8.1.2 props驼峰标识

在组件的应用不适合用驼峰  应该要用-

~~~html
<div id="app">
    <!-- 在组件的应用不适合用驼峰  应该要用- -->
    <cpn :c-info="info" :chile-my-message="message"></cpn>
</div>

<template id='cpn'>
    <div>
        <h2>{{cInfo}}</h2>
        <p>{{chileMyMessage}}</p>
    </div>
</template>

<script>
	const cpn = {
        template :"#cpn",
        props:{
            cInfo:{
                type:Object,
                default(){
                    return {}
                }
            }
        },
        childMyMessage:{
            type:String,
            default:''
        }
    }
    
    const app = new Vue({
        el:"#app",
        data:{
            info:{
                name:"why",
                age:18,
                height:1.88
            },
            message:'hello'
        },
        components:{
            cpn
        }
    })
</script>
~~~

### 8.2 子传父

+ 如果需要子组件传递数据或事件到父组件中：应该使用自定义事件来完成
+ 什么时候需要定义事件？
  + 当子组件需要向父组件传递数据时，就要用到自定义事件
  + v-on可以用来监听自定义事件
+ 自定义事件的流程
  + 在子组件中，通过$emit()来触发事件
  + 在父组件中，通过v-on来监听子组件事件

~~~html
<!-- 父组件模板 -->
<div id="app">
    <!-- 不能使用驼峰 -->
	<cpn @itemclick="cpnClick"></cpn>
</div>

<!-- 子组件模板 -->
<template id="cpn">
    <div>
        <button v-for="item in categories" @click="btnClick(item)">{{item.name}}</butto>
    </div>
</template>

<script>
    //1.子组件
    const cpn = {
        template:"#cpn",
        data(){
            return {
                categories:[
                    {id:'aaa',name:'热门推荐'},
                    {id:'bbb',name:'手机数码'},
            		{id:'ccc',name:'家用电器'},
            		{id:'ddd',name:'电脑办公'},
                ]
            }
        },
        methods:{
            btnClick(item){
                //传给父组件 自定义事件  子组件 发射 
                this.$emit('itemclick',item);
            }
        }
    }
    
    //2.父组件
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        components:{
            cpn
        },
        methods:{
            itemClick(item){
             	 console.log('itemclick',item);   
            }
        }
    })
</script>
~~~



### 8.3 父子组件的访问方式 ：

+ 有时候需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件
  + 父组件访问子组件：是使用`$children` `$refs`
  + 子组件访问父组件：使用`$parent`

#### 8.3.1 父访问子 $children/$refs

+ `this.$children`是一个数组类型，包含了所有的子组件对象
+ 通过遍历，取出所有子组件的message状态

##### 1. $children

因为返回的是数组的形式，所以如果要添加便签的话就很麻烦 所以一般开发不使用这样的方法

一般只有拿到所有子组件的信息的时候，才会使用$children

~~~html
<div id="app">
    <cpn></cpn>
    <cpn></cpn>
    <cpn></cpn>
    <button @click="btnClick">按钮</button>
</div>

<template id="cpn">
    <div>
        我是子组件
    </div>
</template>

<script>
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        methods:{
            btnClick(){
                console.log(this.$children); //可以利用这个得到 子组件的各种属性 以数组的形式
                this.$children[0].showMessage(); //然后调用
                //if 有多个组件要渲染
                for(let c of this.$children){
                    console.log(c.name);
                }
            }
        }
        components:{
            cpn:{
                template:"#cpn",
        		data(){
        			reutrn{
                        name:'我是子组件的name'
                    }
    			},
                medthods:{
                    showMessage(){
                        console.log('showMessage');
                    }
                }
            }
        }
    })
</script>
~~~



##### 2.$refs

对象类型 默认空对象  必须在组件加  ref=‘aaa’ 

一般都是使用这个属性

~~~html
<div id="app">
    <cpn></cpn>
    <cpn></cpn>
    <cpn ref='aaa'></cpn>
    <button @click="btnClick">按钮</button>
</div>

<template id="cpn">
    <div>
        我是子组件
    </div>
</template>

<script>
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        methods:{
            btnClick(){
                console.log(this.$refs);  
                //如果没有在组件标签绑定 那返回空对象 若有绑定 就会返回有名字的对象 
                //名字会作为这个对象的key
                console.log(this.$refs.aaa);
                console.log(this.$refs.aaa.name);
            }
        }
        components:{
            cpn:{
                template:"#cpn",
        		data(){
        			reutrn{
                        name:'我是子组件的name'
                    }
    			},
                medthods:{
                    showMessage(){
                        console.log('showMessage');
                    }
                }
            }
        }
    })
</script>
~~~



#### 8.3.2 子访问父\$parent和  $root

用得很少，复用性不强

~~~html
<div id='app'>
    <cpn></cpn>
</div>

<template id='cpn'>
    <ccpn></ccpn>
</template>

<template id='ccpn'>
    <div>
       <h2>我是子组件</h2> 
       <button @click='btnClick'></button>
    </div>
</template>

<script>
	const app = new Vue({
        el:"#app",
        data:{
            message:"hello",
        },
        components:{
            cpn:{
                template:"#cpn",
                data(){
                    return {
                        name:'我是cpn组件的name'
                    }
                }
            },
            components:{
                ccpn:{
                    template:"#ccpn",
                    methods:{
                        btnClick(){
                            //1.访问父组件$parent
                            console.log(this.$parent);
                            console.log(this.$parent.name);
                            
                            //2.访问根组件$root
                            console.log(this.$root);
                            console.log(this.$root.message);
                        }
                    }
                }
            }
        }
        
    })
</script>
~~~

## 9.组件化高级（p69-72）

### 9.1插槽 slot

#### 9.1 组件化插槽

1. slot为插槽的意思，目的是让我们原来的设备具有更多的扩展性

+ 组件化插槽是为了让我们封装的组件更加具有扩展性
+ 让使用者可以决定组件内部的一些内容到底展示什么

2. 如何去封装以京东导航栏为例子的这类组件：抽取共性，保留不同

+ 将共性抽取到组件中，将不同暴露为插槽
+ 一旦预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容



#### 9.2 插槽的基本使用

1. 基本使用
2. 默认值
3. 多个值时，会全部替换进去

~~~html
<div id='#app'>
    <cpn></cpn>
    <cpn>
        <button>按钮</button>
    </cpn>   <!-- 会把这个button放入插槽里 如果里面有多个 那也会全部显示出来 -->
    <cpn></cpn>
</div>

<template id="cpn">
	<div>
        <h2>我是组件</h2>
        <solt><span>如果没有传进想要的标签 就会默认显示插槽里的内容</span></solt>
    </div>
</template>

<script>
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        components:{
            cpn:{
                template:"#cpn",
            }
        }
    })
</script>
~~~

### 9.2 具名插槽slot

~~~html
<div id='#app'>
    <cpn></cpn>
    <cpn>
        <span solt="center">标题</span>
        <!-- 如果没有加solt的属性 只会替换那些没有名字的插槽 -->
    </cpn>  
    <cpn></cpn>
</div>

<template id="cpn">
	<div>
        <solt name='left'><span>左边</span></solt>
        <solt name='center'><span>中间</span></solt>
        <solt name='right'><span>右边</span></solt>
    </div>
</template>

<script>
    const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        components:{
            cpn:{
                template:"#cpn",
            }
        }
    })
</script>
~~~



### 9.3 编译作用域

+ 父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译

~~~html
<div id='app'> 
    <cpn v-show='isShow'></cpn> <!-- 使用实例的isShow -->
</div>

<template id='cpn'>
    <h2>我是组件</h2>
    <button v-show="isShow">按钮</button> <!-- 使用组件的isShow -->
</template>

<script>
	const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
            isShow:true,
        },
        component:{
            cpn:{
                template:'#cpn',
                data(){
                    return {
                        isShow:false,
                    }
                }
            }
        }
    })
</script>
~~~

### 9.4 作用域插槽

+ 父组件替换插槽的标签，但是内容由子组件来提供

~~~html
<div id="app">
    <cpn></cpn>
    <cpn>
    <!-- 目的是 获取组件中的pLanguage -->
        <!-- 在2.5.x以下的版本 只能使用template 但是后面的版本可以直接 使用div-->
        <!-- 通过solt引用 下面插槽对象  下面用的solt.data 用的就是下面的data	==planage-->
        <template slot-scope='solt'>
            <span v-for='item in  solt.data'>{{item}} - </span>
        </template>
    </cpn>
        <cpn>
 		 <template slot-scope='solt'>
             <!-- 以‘ - ’分割 -->
            <span>{{solt.data.join(' - ')}}</span>
        </template>
    </cpn>
</div>

<template id='cpn'>
	<div>
        <!-- data是随便取的名字 意味着data指向pLanguage -->
        <solt :data='pLanguages'>
        	<ul><li v-for='item in pLanguages'>{{item}}</li></ul>
        </solt>
    </div>
</template>

<script>
	const app = new Vue({
        el:"#app",
        data:{
            message:'hello',
        },
        component:{
            cpn:{
                template:"#cpn",
                data(){
                    return {
                        pLanguages:['js','java','python','c']
                    }
                }
            }
        }
    })
</script>
~~~































