---
title: js webAPI--offset、client、scroll
date: 2021/3/6
updated: 2021/3/8
comments:
tags:
 - js
categories:
 - learningNotes
layout:
permalink:
meta: true
---

### 1.元素偏移量offset系列

#### 1.1 offset概述

offset就是偏移量的意思，使用offset系列相关属性可以<font color='red'>动态</font>的得到该元素的位置（偏移）、大小等。

* 获取元素距离**带有定位**的父元素的位置
* 获得元素自身的大小
* 返回的数值**不带单位**

offset 系列常用属性：

| offset系列常用属性   | 作用                                                   |      |
| -------------------- | ------------------------------------------------------ | ---- |
| element.offsetParent | 返回作为该元素**带有定位**的父级元素 if都无 则返回body |      |
| element.offsetTop    | 返回元素相对**带有定位**父元素上方的偏移               |      |
| element.offsetLeft   | 返回元素相对**带有定位**父元素左边框的偏移             |      |
| element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度，不带单位      |      |
| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，不带单位      |      |

~~~html
    <style>        
        .father {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 150px;
            background-color: antiquewhite;
        }
        
        .son {
            width: 100px;
            height: 100px;
            margin: 20px;
            background-color: brown;
        }
    </style>
</head>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
    <script>
        let father = document.querySelector('.father');
        let son = document.querySelector('.son');
        //1.可以得到元素的偏移量
        console.log(father.offsetTop); //150 if加上padding 150
        console.log(son.offsetLeft); //if.father 没有定位 : 170  if.father 加上定位 :20 if.father 加上padding 40

        //2.可以得到元素的大小
        console.log(father.offsetHeight); //240  包含padding+border+width

        //3.返回带有定位的父元素 or 返回body
        console.log(son.offsetParent); //返回最近一级有定位的父亲
        console.log(son.parentNode); //返回亲父亲
    </script> 
~~~

#### 1.2 offset 与 style 区别

offset：

+ offset 可以得到任意样式表中的样式值
+ offset 系列获得的数值是没有单位的
+ offsetWidth 包含padding + border + width
+ offsetWidth 等属性是只读属性，只能获取不能赋值
+ <font color='red'>所以，我们想要获取元素大小位置，用 offset 更合适</font>



style：

+ style 只能得到行内样式表中的样式值
+ style.width 获得的是带有单位的字符串
+ style.width 获得不包含 padding 和border 的值
+ style.width 是可读写属性，可以获取也可以赋值
+ <font color='red'>所以，我们想要给元素更改值，则需要用style</font>



~~~html
<style>
    .box{
        width:200px;
        height:200px;
    }
</style>
<html>
    <div class='box'></div>
</html>
<script>
	let box = document.querySelector('.box');
    console.log(box.offsetWidth); //200
    console.log(box.style.width); //若无行内 则不输出 if .box加上 style='width：200px'  200px
    //offsetwidth 赋值 对box/12行 输出 无影响
    //.style.width 就会改值
</script>
~~~

#### 1.3  案例之获取鼠标相对于盒子的位置

> 盒子在页面中的距离 box.offsetLeft box.offsetTop
>
> 鼠标在页面中的坐标 e.pageX e.pageY

~~~html
    <style>
        * {
            margin: 0;
            margin: 0;
        }
        
        .box {
            width: 200px;
            height: 200px;
            margin: 50px;
            background-color: brown;
        }
    </style>

    <div class="box"></div>

    <script>
        let box = document.querySelector('.box');
        box.addEventListener('click', function(e) {
            let x = e.pageX - box.offsetLeft;
            let y = e.pageY - box.offsetTop;
            console.log(x, y);
        })
    </script>
~~~

#### 1.4 案例之模态框的拖拽

原理：鼠标按下并且移动，松开鼠标

事件：鼠标按下mousedown 鼠标移动mousemove 鼠标松开mouseup

过程：鼠标移动过程中，获得最新的值赋值给模态框的left和top值

模态框的位置：鼠标的坐标减去鼠标在盒子内的坐标

~~~html
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        
        div {
            position: relative;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            width: 300px;
            height: 150px;
            background-color: plum;
        }
        
        .hide {
            position: absolute;
            top: 0px;
            right: 5px;
        }
    </style>

    <p class="show">点击弹出</p>
    <div class="model">
        <span class="hide">x</span>
    </div>

    <script>
        let show = document.querySelector('.show');
        let model = document.querySelector('.model');
        let hide = document.querySelector('.hide');

        show.addEventListener('click', function() {
            model.style.display = 'block';
        })

        model.addEventListener('mousedown', function(e) {
            //1.鼠标按下，获得鼠标在盒子内的坐标 —— 不变的
            let clickX = e.pageX - model.offsetLeft;
            let clickY = e.pageY - model.offsetTop;
            // console.log(clickX, clickY);
            //2.鼠标移动过程中，获得最新的值 变的长度-不变的长度 赋值给模态框的left和top值
            document.addEventListener('mousemove', move);

            function move(ec) {

                model.style.left = ec.pageX - clickX + 'px';
                model.style.top = ec.pageY - clickY + 'px';
            }

            //3.鼠标弹起 移除鼠标移动事件
            document.addEventListener('mouseup', function() {
                document.removeEventListener('mousemove', move);
            })
        })

        hide.addEventListener('click', function() {
            this.arentNode.style.display = 'none';
        })
    </script>
~~~



### 2.元素可视区client系列 

client就是客户端的意思，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                    |
| -------------------- | ------------------------------------------------------- |
| element.clientTop    | 返回元素上边框的大小                                    |
| element.clientLeft   | 返回元素左边框的大小                                    |
| element.clientWidth  | 返回自身包括padding、内容区的宽度、不包含边框，不带单位 |
| element.clientHeight | 返回自身包括padding、内容区的高度、不包含边框，不带单位 |



### 3.元素scroll系列

#### 3.1元素scroll系列属性

scroll就是滚动的的意思，使用scroll系列相关属性可以动态得到该元素的大小、滚动距离等。

| scroll系列属性       | 作用                                 |
| -------------------- | ------------------------------------ |
| element.scrollTop    | 返回被卷去的上侧距离，不带单位       |
| element.scrollLeft   | 返回被卷去的左侧距离，不带单位       |
| element.scrollWidth  | 返回自身实际宽度 不含边框，不带单位  |
| element.scrollHeight | 返回自身实际高度，不含边框，不带单位 |

> element.scrollWidth ：if内容超过宽度 则比宽度大，包含padding，可以说是实际内容的大小

<img src='https://s1.328888.xyz/2022/04/09/XnWs2.png' style="zoom:50%;" >

#### 3.2 页面被卷去的头部

如果浏览器的高/宽度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，称为页面被卷去的头部。滚动条在滚动时会触发onscroll事件。

~~~js
div.addEventListener('scroll',function(){
    console.log(div.scrollTop);
})
~~~



#### 3.3 案例之返回顶部

+ 需要用到页面滚动事件scroll 因为是<font color='red'>页面滚动，所以事件源是document</font>
+ 滚动到某个位置，就是判断页面被卷去的上部值
+ <font color='red'>页面被卷去的头部：可以通过window.pageYOffset获得</font> (如果是页面被卷曲的左侧 <font color='red'>window.pageXOfffset</font>)
+ 注意，<font color='red'>元素</font>被卷去的头部是<font color='red'>element.scrollTop</font>，如果是<font color='red'>页面</font>被卷去的头部则是<font color='red'>window.pageYOffset</font>

~~~html
    <div class="slider-bar">
        <span class="goBack">返回顶部</span>
    </div>
    <div class="header w">头部区域</div>
    <div class="banner w">banner区域</div>
    <div class="main w">主体部分</div>

    <script>
        //1.获取元素
        var sliderbar = document.querySelector('.slider-bar');
        var banner = document.querySelector('.banner');


        //但我们侧边栏固定定位之后应该变化的值
        let tops = sliderbar.offsetTop - banner.offsetTop;
        //获取main 主体元素
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');

        //2.页面滚动事件 scroll
        document.addEventListener('scroll', function() {

            //3.当页面被卷去的头部   大于等于banner区域  侧边栏改为固定定位
            if (window.pageYOffset >= banner.offsetTop) {
                sliderbar.style.position = 'fixed';
                sliderbar.style.top = tops + 'px'; //tops 得再外面定义 不然值会变的
            } else {
                sliderbar.style.position = 'absolute';
                sliderbar.style.top = '300px';
            }


            //4.当页面滚动到main 盒子就显示goback模块
            if (window.pageYOffset >= main.offsetTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';
            }

        })
</script>
~~~



#### 3.4 页面被卷去的头部兼容性解决方案

因此被卷去的头部通常有如下几种写法：

1. 声明了DTD(`<!DOCTYPE html>`)，使用`document.documentElement.scrollTop`

2. 未声明DTD，使用`document.body.scrollTop`

3. 新方法`window.pageYOffset `和 `window.pageXOffset` ，IE9开始支持

   ~~~js
   function getScroll(){
       return{
           left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
           top:window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
       };
   }
   
   //使用时 getScroll().left
   ~~~



### 三大系列总结

| 三大系列大小对比    | 作用                                |
| ------------------- | ----------------------------------- |
| element.offsetWidth | 返回自身+padding+边框，内容区的宽度 |
| element.clientWidth | 返回自身+padding，内容区的宽度      |
| element.scrollWidth | 返回自身实际宽度，+padding          |

<img src='https://s1.328888.xyz/2022/04/09/XnzVM.png'>

#### 主要用法：

1. offset 系列：获取元素的位置 <font color='red'>offsetLeft   offsetTop</font>
2. client 系列：获取元素大小  <font color='red'>clientWidth   clientHeight</font>
3. scroll系列：获取滚动距离  <font color='red'>scrollTop   scrollLeft</font>
4.  <font color='red'>页面的滚动距离</font>通过 <font color='red'>window.pageXOffset</font> 获得















