---
title: 月影讲js - 字节青训营
date: 2022/1/17
updated: 2022/1/17
comments:
tags:
 - js
 - 青训营
categories:
 - learningNotes
layout:
permalink:
meta: true
---

1. 通过 html css 触发事件
  ~~~html
  <input id="modeCheckBox" type="checkbox"></input>
  <div class="content">
    <label id="modeBtn" for="modeCheckBox"></label>
  </div>
  // 点击 label 就会选择 input[type="checkbox"]
  <style>
      #modeCheckBox:checked + .content{
          background-color:black;
      }
      
  </style>

  ~~~

2. 组件 — 自定义事件 — 解耦

   ~~~js
   // 自定义事件
   const detail = {index: idx};
   const event = new CustomEvent('slide',{bubbles:true, detail}) 
   this.contailer.dispatchEvent(event)
   
   let dom = document.querySelector('#app');
   // 绑定事件， 传递过来的值可以通过ev.detail 来获取
   dom.addEventListener('log-in',(ev) => {
       const { detail } = ev;
       console.log(detail);  // hello
   })
   // 派发事件，需要传入两个参数，一个是事件类型，另外一个是一个对象，detail就是传递过去的值
   dom.dispatchEvent(new CustomEvent('log-in',{
       detail:'hello'
   }))
   ~~~

   web页面抽出来一个个包含模板 html、功能 js 和 样式 css

   设计原则：封装性、正确性、扩展性、复用性

   实现步骤：结构设计、展现效果、行为设计（API 功能    Event 控制流 — 解耦）

   三次重构：

   + 使用插件：code.h5jun.com/weru/edit?js,output
   + 模板化：code.h5jun.com/weru/3/edit?js,output
   + 组件框架：code.h5jun.com/vata/4/edit?js,output

3. 过程抽象

   为了让“只执行一次”的**需求覆盖不同的事件处理，可以将这个需求剥离出来，这个过程就是过程抽象**

    once：code.h5jun.com/zoqop/edit?js,output

   **高阶函数：函数作为函数的 参数 或者 返回值，常用于函数装饰器**

   > 接收一个函数作为参数，返回另一个参数，eg：
   >
   > ~~~js
   > // 等价装饰 0级高阶函数 等价范式
   > // 调用次函数装饰器 相当于 直接调用 fn  
   > function HOF0(fn){
   >     return function(...args){
   >         return fn.apply(this,args);
   >     }
   > }
   > ~~~
   >
   > 

   > 常用的高阶函数：
   >
   > + once
   >
   >   ~~~js
   >   function limit(fn,times = 1){
   >       return function(...args){
   >           return times-- > 0 ? fn.apply(this,args) : null; 
   >       }
   >   }
   >   function foo = limit(() => {
   >       console.log('foo')
   >   },2)
   >   ~~~
   >
   > + throttle：code.h5jun.com/gale/1/edit?js,output
   >
   >   ~~~js
   >   function throttle(fn,dur){
   >       var timer;
   >       return function(...args){
   >           if(timer == null){
   >               fn.apply(this,arguments);
   >               timer = setTimeout(()=>{
   >                   cleanTimeout(timer);
   >               },dur)
   >           }
   >       }
   >   }
   >   ~~~
   >
   > + debounce：code.h5jun.com/wik/edit?js,output
   >
   >   ~~~js
   >   function debounce(fn, dur){
   >       dur = dur || 100;
   >       var timer;
   >       return function(){
   >           clearTimeout(time);
   >           timer = setTimeout(()=>{
   >               fn.apply(this,arguments);
   >           },dur);
   >       }
   >   }
   >   ~~~
   >
   > + consumer ：code.h5jun.com/roka/7/edit?js,output   res + i = res 
   >
   >   ​                       code.h5jun.com/bucu/3/edit?js,output     hit + 123
   >
   >   ~~~js
   >   function consumer(fn,time){
   >       let tasks = [],timer;
   >       return function(...args){
   >           tasks.push(fn.bind(this,...args));
   >           if(timer == null){
   >               timer = setInterval(() => {
   >                   tasks.shift().call(this);
   >                   if(tasks.length <= 0){
   >                       clearTnterval(timer);
   >                       timer = null;
   >                   }
   >               },time)
   >           }
   >       }    
   >   }
   >   ~~~
   >
   > + lterative：code.h5jun.com/kapef/edit?js,output  批量操作
   >
   >   ~~~js
   >   const inIterable = obj => 
   >         obj != null %% typeof obj[Symbol.iterator] === 'function';
   >   
   >   function iterative(fn){
   >       return function(subject, ...rest){
   >           if(inIterable(subject)){
   >               const ret = [];
   >               for(let obj of subject){
   >                   ret.push(fn.apply(this,[obj, ...rest]));
   >               }
   >               return ret;
   >           }
   >           return fn.apply(this,[subject, ...rest]);
   >       }
   >   }
   >   ~~~
   >
   >   

   为什么使用高阶函数：减少系统的纯函数、便于测试

   > pure纯函数：输入确定后输出就是确定的，便于做单例测试 add(x,y)
   >
   > impure非纯函数：依赖外部环境，setColor次序，时间，次数不同结构不同 
   >
   >    （操作dom都非）可以用纯函数 iterative 包 setColor 得到一个纯函数

4. 编程范式

   命令式：关心执行过程 

   和 

   声明式：不关心

   ~~~js
   // 声明式 三态
   function toggle(... actions){
       return function(...args){
           let action = actions.shift();
           actions.push(action);
           return action.apply(this,args);
       }
   }
   
   swicher.onclick = toggle(
       evt => evt.target.className = 'off',
       evt => evt.target.className = 'on'
   )
   ~~~

   

5. 案例

   1. 交通灯
   
   2. 洗牌
   
      ~~~js
      function shuffle(cards){
          const c = [...cards];
          for(let i = c.length; i > 0; i--){
              const pindex = Math.floor(Math.random() * i);
              [c[pindex],c[i-1]] = [c[i-1], c[pindex]];
          }
          return c;
      }
      
      // 抽牌
      // code.h5jun.com/zamuv/edit?js,console
      function * draw(cards){
          const c = [...cards];
          for(let i = c.length; i > 0; i--){
              const pindex = Math.floor(Math.random() * i);
              [c[pindex],c[i-1]] = [c[i-1], c[pindex]];
              yield c[i-1];
          }
      }
      ~~~
   
      
   
   3. 是否是4的幂
   
   4. 分红包
   
      > 利用了抽牌的思路：code.h5jun.com/luba/edit?js,console
