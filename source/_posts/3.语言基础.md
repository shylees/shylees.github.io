---
title: 红宝书 - 第 3 章 语言基础
date: 2021/1/29
updated: 2021/1/30
comments:
tags:
 - js
categories:
 - readNotes
layout:
permalink:
meta: true
---


任何语言的核心所描述的都是真语言再最基本的层面上如何工作，涉及语法、操作符、数据类型以及内置功能、再此基础上才可以构建复杂的解决方案。ECMA-262以一个名为ECMAScript的伪语言的形式，定义了JavaScript的所有这些方面。

本章的内容主要基于ECMAScript第6版。

## 3.1 语法

### 3.1.1 区分大小写

ECMAScript中一切都区分大小写。无论是变量、函数名、操作符，都区分大小写。

### 3.1.2 标识符

**标识符**：变量、函数、属性、函数参数的名称。

命名规则：

* 第一个字符必须是字母/下划线_/美元符号$
* 剩下的字符可以是字母/下划线/美元符号/数字
* 关键字、保留字、true、false、null不能作为标识符

> 标识符中的字母可以是扩展ASCII中的字母，也可以是Unicode的字母字符。

按照惯例，ECMAScript标识符使用驼峰大小写形式。

> 虽然不是强制性，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以是最佳实现

### 3.1.3 注释

`//` 单行注释

`/*` 多行注释 `*/`

### 3.1.4 严格模式

ECMAScript 5 增加了严格模式的概念。其是一种不同的JavaScript解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。

* 要对整个脚本启用严格模式，在脚本开头加上：`use strict;`

看起来像没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。

* 也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头就可以：

  ~~~JavaScript
  function do(){
      use strict;
  }
  ~~~



> 严格模式会影响JavaScript执行的很多方面；所有现代浏览器都支持严格模式



### 3.1.5 语句

* ECMAScript语句以分号结尾，虽然不是必需的，但推荐加上。

> 加分号便于开发者通过删除空行来压缩代码（如果没有分号，只删除空行，则会导致语法错误）
>
> 也有助于在某些情况提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误

* 多条语句可以合并到代码块中`{}`。

* `if`之类的控制语句只在执行多条语句时必须有代码块。



## 3.2 关键字与保留字

ECMA-262描述了一组**保留的关键字**，这些关键字有特殊用途，比如表示控制语句的开始和结束… 按照规定，保留的关键字不能用作标识符或属性名。

ECMA-262 第6版规定的所有关键字如下：

| break    | do       | in         | typeof |
| -------- | -------- | ---------- | ------ |
| case     | else     | instanceof | var    |
| catch    | export   | new        | void   |
| class    | extends  | return     | while  |
| const    | finally  | super      | with   |
| continue | for      | switch     | yield  |
| debugger | function | this       |        |
| default  | if       | throw      |        |
| delete   | import   | try        |        |

规范中也描述了一组**未来的保留字**，同样不能用作标识符或属性名。以下是ECMA-262 第6版 为将来保留的所有词汇

* 始终保留 `enum`
* 严格模式下保留`implement` `package` `public` `interface` `protected` `static` `let` `private` 
* 模块代码中保留 `await`

> 这些词汇不能用作标识符，但还能用作对象的属性名。一般来说，不推荐使用。



## 3.3 变量

ECMAScript变量是松散类型的，即变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。

有3个关键字可以声明变量：

1. `var` ：在ECMAScript的所有版本中都可以使用
2. `const` ：ECMAScript 6 及更晚的版本中使用
3. `let` ：ECMAScript 6 及更晚的版本中使用

### 3.3.1 ` var`关键字

要定义变量，可以使用`var`操作符，后面跟变量名： `var message`

ECMAScript实现变量初始化，因此可以同时定义变量并设置它的值：`var message = "hi";`

> 像这样初始化变量不会将它表示为字符串类型，只是简单的赋值而已；
>
> 随后不仅可以改变保存的值，也可以改变值的类型

~~~javascript
var message = "hi";
message = 100; //合法，但不推荐
~~~

1. **var声明作用域**

   使用`var`操作符定义的变量会成为包含它的函数的局部变量。

   > 比如，使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：

   ~~~JavaScript
   function test(){
       var message = "hi"; //局部变量
   }
   test();
   console.log(message); //出错
   ~~~

   <font color='red'>在函数内定义变量时省略var操作符，可以创建一个全局变量</font>

   ~~~javascript
   function test(){
       var message = "hi"; //全局变量
   }
   test();
   console.log(message); // “hi”
   ~~~

   > 不推荐这么做，在局部作用域中定义的全局变量很难维护。
   >
   > 也会造成困扰，因为不能瞬间断定省略var是不是有意为之。
   >
   > 在**严格模式**下，如果像这样给未声明的变量赋值，会导致抛出ReferenceError。

   如果定义多个变量，可以在一条语句中用逗号分隔每个变量：

   ~~~javascript
   var message = "hi",
       found = false,
       age = 29;
   //因为ECMAScript时松散类型的，所以可以使用不同数据类型初始化的变量可以用一条语句来声明
   ~~~

   > 在**严格模式**下，不能定义`eval`和`arguments`的变量，否则会导致语法错误

2. **var声明提升**

   <font color='red'>使用`var`声明的变量会自动提升到函数作用域顶部</font>

   ~~~JavaScript
   function foo(){
       console.log(age);
       var age = 26;
   }
   foo(); //undefined
   ~~~

   上述代码等同于

   ~~~javascript
   function foo(){
       var age;    //所谓的“提升”
       console.log(age);
       age = 26;
   }
   foo(); //undefined
   ~~~



### 3.3.2 let声明

* `let`声明的范围的块作用域，而`var`声明的范围是函数作用域

  > 块作用域是函数作用域的子集

  ~~~javascript
  //var
  if(true){
      var name= 'Matt';
      console.log(name); //Matt
  }
  console.log(name); //Matt
  
  //let
  if(true){
      let age = 26;
      console.log(age); //26
  }
  console.log(age); //ReferenceError:age没有定义
  ~~~

* `let`不允许同一个块作用域出现冗余声明

   ~~~javascript
   var name;
   var name;
   
   let age;
   let age; //SyntaxError; 标识符age
   ~~~

* 已经声明JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域

   嵌套使用相同的标识符不会报错，因为同一个块中没有重复声明

   
 1. **暂时性死区**：

    `let`声明的变量不会在作用域中被提升

    ~~~javascript
    //name会被提升
    console.log(name);  //undefined
    var name = 'Matt';
    
    //age不会被提升
    console.log(age);   //ReferenceError:age没有定义
    let age = 26;
    ~~~

    在解析代码时，JavaScript引擎也会注意出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let声明之前的执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出`ReferenceError`

 2. **全局声明**：

    与`var`不同，使用`let`在全局作用域中声明的变量不会成为`window`对象的属性

    ~~~javascript
    var name = 'Matt';
    console.log(window.name); //'Matt'
    
    let age = 26;
    console.log(window.age); //undefined
    ~~~

    不过`let`声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免`SyntaxError`，必须确保页面不会重复声明同一个变量

 3. **条件声明**：

    在使用`var`声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。

    `let`的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，也就不可能在没有声明的情况声明它。

    ~~~html
    <script>
    	var name = 'Maiy';
        let age = 26;
    </script>
    
    <script>
    	//假设脚本不确定页面是否已经声明了同名变量  那可以假设还没声明过
        var name = 'Matt';  //没有错误，因为可以被作为一个提升声明来处理  不需要检查之前是否声明过同名变量
        
        let age = 36; //如果之前声明过，这里会报错
    </script>
    ~~~

    使用`try/catch`语句或`typeof`操作符也不能解决，因为条件块中`let`声明的作用域仅限于该块。

    ~~~html
    <script>
    	let name = 'Maiy';
        let age = 26;
    </script>
    
    <script>
    	//假设脚本不确定页面是否已经声明了同名变量  那可以假设还没声明过
        if(typeof name === 'undefined'){
            let name;
            //name 被限制在if块作用域内  这个赋值形同全局赋值
        }
        name = 'Matt';
       
        try{
            console.log(age);  //若无声明过则会报错
        }
        catch(error){
            let age;
            //age被限制在catch块的作用域内  这个赋值形同全局赋值
        }
        age = 26;
    </script>
    ~~~

    > 对于let不能依赖条件声明模式

 4. **for循环中的let声明**：

    在`let`出现之前，`for`循环定义的迭代变量会渗透到循环体外部;

    改使用`let`之后，就没有这个问题了，因为迭代变量的作用域仅限于`for`循环块内部；

    ~~~javascript
    for(var i = 0 ; i < 5 ; ++i){
        //循环逻辑
    }
    console.log(i); // 5
    
    for(let i = 0 ; i < 5 ; ++i){
        //循环逻辑
    }
    console.log(i); //ReferenceError：i没有定义
    ~~~

    在使用`var`时，最常见的问题就是对迭代遍历的奇特声明和修改：

    ~~~javascript
    for(var i = 0 ; i < 5 ; i++){
        setTimeout( () => console.log(i) , 0)   //5 5 5 5 5
    }
    //因为在退出循环时，迭代变量保存的是导致循环退出的值，所以在之后执行超时逻辑是，所有的i都是同一个变量，因而输出同一个值
    
    for(let i = 0 ; i < 5 ; i ++){
        setTimeout( () => console.log(i) , 0)   //1 2 3 4 5
    }
    //使用let迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个setTimeout引用的都是不同的变量实例。
    ~~~

    > 这种每次迭代声明一个独立变量实例的行为适用于所有风格for循环，包括`for-in`和`for-of`循环

    

   ### 3.3.3 const声明

`const`的行为于`let`基本相同，唯一一个重要的区别：

用`const`声明变量时，必须同时初始化变量，且尝试修改`const`声明的变量会导致运行错误。

~~~javascript
const age = 26;
age = 36; //TypeError：给常量赋值

//const也不允许重复声明
const name = 'Matt';
const name = 'Maiy'; //SyntaxError

//const声明的作用域也是块
const name = 'MAtt';
if(true){
    const name = 'Maiy';
}
console.log(name); //MAtt
~~~

`const`声明的限制只适用于它指向的变量的引用。

即如果`const`变量引用的是一个对象，那么修改这个对象内部的属性并 不违反`const`的限制

~~~javascript
const person = {};
person.name = 'Matt'; //没有语法错误
~~~

不能用`const`来声明迭代变量，因为迭代变量会自增

~~~javascript
for(const i = 0 ; i <  ; i ++){} //TypeError:给常量赋值
~~~

若只想用`const`声明一个不会被修改的`for`循环变量，也是可以的。

即每次迭代只是创建一个新变量，这对`for-of`和`for-in`循环特别有意义

   ~~~javascript
let i = 0;
for(const j = 7 ; i < 5 ; i ++){
    console.log(j);    // 7 7 7 7 7 
}

for(const key in a: 1 , b: 2){
    console.log(key);  //a b
}

for(const value of [1,2,3,4,5]){
    console.log(value); //1 2 3 4 5
}
   ~~~



###  3.3.4声明风格及最佳实践

1. 不使用`var`

   限制自己只使用`let`和`const`有助于提升代码质量，因为变量有了明确的作用域、声明位置、以及不变的值。

2. `const`优先，`let`次之

   使用`const`声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。

   只在提前知道未来会有修改时，再改用`let`.

   > 这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。



## 3.4 数据类型



   

   



































